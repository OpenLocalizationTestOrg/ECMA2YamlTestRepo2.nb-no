### YamlMime:ManagedReference
items:
- uid: Microsoft.VisualBasic.FileSystem
  id: FileSystem
  children:
  - Microsoft.VisualBasic.FileSystem.ChDir(System.String)
  - Microsoft.VisualBasic.FileSystem.ChDrive(System.Char)
  - Microsoft.VisualBasic.FileSystem.ChDrive(System.String)
  - Microsoft.VisualBasic.FileSystem.CurDir
  - Microsoft.VisualBasic.FileSystem.CurDir(System.Char)
  - Microsoft.VisualBasic.FileSystem.Dir
  - Microsoft.VisualBasic.FileSystem.Dir(System.String,Microsoft.VisualBasic.FileAttribute)
  - Microsoft.VisualBasic.FileSystem.EOF(System.Int32)
  - Microsoft.VisualBasic.FileSystem.FileAttr(System.Int32)
  - Microsoft.VisualBasic.FileSystem.FileClose(System.Int32[])
  - Microsoft.VisualBasic.FileSystem.FileCopy(System.String,System.String)
  - Microsoft.VisualBasic.FileSystem.FileDateTime(System.String)
  - Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Boolean@,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Byte@,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Char@,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.DateTime@,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Decimal@,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Double@,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int16@,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int32@,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int64@,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Single@,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.ValueType@,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.String@,System.Int64,System.Boolean)
  - Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Array@,System.Int64,System.Boolean,System.Boolean)
  - Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FileLen(System.String)
  - Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)
  - Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Boolean,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Byte,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Char,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.DateTime,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Decimal,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Double,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int16,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int32,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int64,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Single,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.ValueType,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FilePut(System.Object,System.Object,System.Object)
  - Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.String,System.Int64,System.Boolean)
  - Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Array,System.Int64,System.Boolean,System.Boolean)
  - Microsoft.VisualBasic.FileSystem.FilePutObject(System.Int32,System.Object,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FileWidth(System.Int32,System.Int32)
  - Microsoft.VisualBasic.FileSystem.FreeFile
  - Microsoft.VisualBasic.FileSystem.GetAttr(System.String)
  - Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Boolean@)
  - Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Byte@)
  - Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Char@)
  - Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.DateTime@)
  - Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Decimal@)
  - Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Double@)
  - Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int16@)
  - Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int32@)
  - Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int64@)
  - Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Object@)
  - Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Single@)
  - Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.String@)
  - Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)
  - Microsoft.VisualBasic.FileSystem.Kill(System.String)
  - Microsoft.VisualBasic.FileSystem.LineInput(System.Int32)
  - Microsoft.VisualBasic.FileSystem.Loc(System.Int32)
  - Microsoft.VisualBasic.FileSystem.Lock(System.Int32)
  - Microsoft.VisualBasic.FileSystem.Lock(System.Int32,System.Int64)
  - Microsoft.VisualBasic.FileSystem.Lock(System.Int32,System.Int64,System.Int64)
  - Microsoft.VisualBasic.FileSystem.LOF(System.Int32)
  - Microsoft.VisualBasic.FileSystem.MkDir(System.String)
  - Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])
  - Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])
  - Microsoft.VisualBasic.FileSystem.Rename(System.String,System.String)
  - Microsoft.VisualBasic.FileSystem.Reset
  - Microsoft.VisualBasic.FileSystem.RmDir(System.String)
  - Microsoft.VisualBasic.FileSystem.Seek(System.Int32)
  - Microsoft.VisualBasic.FileSystem.Seek(System.Int32,System.Int64)
  - Microsoft.VisualBasic.FileSystem.SetAttr(System.String,Microsoft.VisualBasic.FileAttribute)
  - Microsoft.VisualBasic.FileSystem.SPC(System.Int16)
  - Microsoft.VisualBasic.FileSystem.TAB
  - Microsoft.VisualBasic.FileSystem.TAB(System.Int16)
  - Microsoft.VisualBasic.FileSystem.Unlock(System.Int32)
  - Microsoft.VisualBasic.FileSystem.Unlock(System.Int32,System.Int64)
  - Microsoft.VisualBasic.FileSystem.Unlock(System.Int32,System.Int64,System.Int64)
  - Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])
  - Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])
  langs:
  - csharp
  name: FileSystem
  nameWithType: FileSystem
  fullName: Microsoft.VisualBasic.FileSystem
  type: Class
  summary: "Den <xref uid=&quot;langword_csharp_FileSystem&quot; name=&quot;FileSystem&quot; href=&quot;&quot;> </xref> modulen inneholder prosedyrer som brukes til å utføre filen, katalog eller mappe og system-operasjoner. Den <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funksjonen gir deg bedre produktivitet og ytelse i i/u-operasjoner enn å bruke den <xref uid=&quot;langword_csharp_FileSystem&quot; name=&quot;FileSystem&quot; href=&quot;&quot;> </xref> modul. Hvis du vil ha mer informasjon, se <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "Denne modulen støtter nøkkelord i Visual Basic språk og kjøretid biblioteket medlemmer som har tilgang til filer og mapper."
  example:
  - "This example uses the `GetAttr` function to determine the attributes of a file and directory or folder.  \n  \n [!code-vb[VbVbalrCatRef#25](~/add/codesnippet/visualbasic/t-microsoft.visualbasic._17_1.vb)]"
  syntax:
    content: >-
      [Microsoft.VisualBasic.CompilerServices.StandardModule]

      [System.Security.SecurityCritical]

      public sealed class FileSystem
  inheritance:
  - System.Object
  implements: []
  inheritedMembers: []
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.ChDir(System.String)
  id: ChDir(System.String)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: ChDir(String)
  nameWithType: FileSystem.ChDir(String)
  fullName: Microsoft.VisualBasic.FileSystem.ChDir(String)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Endrer gjeldende katalog eller mappe. Den <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funksjonen gir deg bedre produktivitet og ytelse i i/u-operasjoner enn den <xref uid=&quot;langword_csharp_ChDir &quot; name=&quot;ChDir &quot; href=&quot;&quot;> </xref>funksjonen. Hvis du vil ha mer informasjon, kan du se <xref:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory*>.</xref:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory*>"
  remarks: "Den `ChDir` funksjonen endrer standardmappen, men ikke standardstasjon. For eksempel hvis standardstasjonen C, følgende setning endrer standardmappen på stasjon D, men C forblir standardstasjonen: [!code-vb [VbVbalrCatRef&#39;](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._177_1.vb) ] du kan gjøre relativ directory endringer er ved å skrive inn to punktum, som følger: [!code-vb [VbVbalrCatRef&#40;](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._177_2.vb) ]       >  [!IMPORTANT] > den `ChDir` funksjonen krever ubehandlet Kodetillatelse, noe som kan påvirke kjøringen i delvis klarert situasjoner. Hvis du vil ha mer informasjon, se <xref:System.Security.Permissions.SecurityPermission>og.</xref:System.Security.Permissions.SecurityPermission>"
  example:
  - "This example uses the `ChDir` function to change the current directory or folder.  \n  \n [!code-vb[VbVbalrCatRef#41](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._177_3.vb)]"
  syntax:
    content: public static void ChDir (string Path);
    parameters:
    - id: Path
      type: System.String
      description: "Kreves. En <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;> </xref> uttrykk som identifiserer hvilke katalog eller mappe blir nye standardmappen eller mappen. `Path`kan inneholde stasjonen. Hvis ingen stasjon er angitt, <xref uid=&quot;langword_csharp_ChDir&quot; name=&quot;ChDir&quot; href=&quot;&quot;> </xref> endrer standardmappen eller mappe på gjeldende stasjon."
  overload: Microsoft.VisualBasic.FileSystem.ChDir*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>Path</code>er tom."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "Ugyldig stasjon er angitt, eller stasjonen er ikke tilgjengelig."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.ChDrive(System.Char)
  id: ChDrive(System.Char)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: ChDrive(Char)
  nameWithType: FileSystem.ChDrive(Char)
  fullName: Microsoft.VisualBasic.FileSystem.ChDrive(Char)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Endrer gjeldende stasjon."
  remarks: "Den `ChDrive` funksjonen krever uforvaltet kode tillatelse, noe som kan påvirke kjøringen i delvis klarert situasjoner. Hvis du vil ha mer informasjon, se <xref:System.Security.Permissions.SecurityPermission>og [kode tilgangstillatelser](http://msdn.microsoft.com/en-us/e5ae402f-6dda-4732-bbe8-77296630f675).</xref:System.Security.Permissions.SecurityPermission>"
  example:
  - "This example uses the `ChDrive` function to change the current drive. The function throws an exception if the drive does not exist.  \n  \n [!code-vb[VbVbalrCatRef#32](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._181_1.vb)]"
  syntax:
    content: public static void ChDrive (char Drive);
    parameters:
    - id: Drive
      type: System.Char
      description: "Kreves. Strenguttrykk som angir en eksisterende stasjon. Hvis du angir en tom streng (&quot;&quot;), gjeldende stasjon endres ikke. Hvis den `Drive` argumentet er en flere tegnstreng <xref uid=&quot;langword_csharp_ChDrive&quot; name=&quot;ChDrive&quot; href=&quot;&quot;> </xref> bruker bare den første bokstaven."
  overload: Microsoft.VisualBasic.FileSystem.ChDrive*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Ugyldig stasjon er angitt, eller stasjonen er ikke tilgjengelig."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.ChDrive(System.String)
  id: ChDrive(System.String)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: ChDrive(String)
  nameWithType: FileSystem.ChDrive(String)
  fullName: Microsoft.VisualBasic.FileSystem.ChDrive(String)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Endrer gjeldende stasjon."
  remarks: "Den `ChDrive` funksjonen krever uforvaltet kode tillatelse, noe som kan påvirke kjøringen i delvis klarert situasjoner. Hvis du vil ha mer informasjon, se <xref:System.Security.Permissions.SecurityPermission>og [kode tilgangstillatelser](http://msdn.microsoft.com/en-us/e5ae402f-6dda-4732-bbe8-77296630f675).</xref:System.Security.Permissions.SecurityPermission>"
  example:
  - "This example uses the `ChDrive` function to change the current drive. The function throws an exception if the drive does not exist.  \n  \n [!code-vb[VbVbalrCatRef#32](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._225_1.vb)]"
  syntax:
    content: public static void ChDrive (string Drive);
    parameters:
    - id: Drive
      type: System.String
      description: "Kreves. Strenguttrykk som angir en eksisterende stasjon. Hvis du angir en tom streng (&quot;&quot;), gjeldende stasjon endres ikke. Hvis den `Drive` argumentet er en flere tegnstreng <xref uid=&quot;langword_csharp_ChDrive&quot; name=&quot;ChDrive&quot; href=&quot;&quot;> </xref> bruker bare den første bokstaven."
  overload: Microsoft.VisualBasic.FileSystem.ChDrive*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Ugyldig stasjon er angitt, eller stasjonen er ikke tilgjengelig."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.CurDir
  id: CurDir
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: CurDir()
  nameWithType: FileSystem.CurDir()
  fullName: Microsoft.VisualBasic.FileSystem.CurDir()
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Returnerer en streng som representerer gjeldende bane. Den <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref> gir deg bedre produktivitet og ytelse i i/u-operasjoner enn <xref uid=&quot;langword_csharp_CurDir&quot; name=&quot;CurDir&quot; href=&quot;&quot;> </xref>. Hvis du vil ha mer informasjon, kan du se <xref:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory*>.</xref:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory*>"
  remarks: ''
  example:
  - "This example uses the `CurDir` function to return the current path.  \n  \n [!code-vb[VbVbalrCatRef#65](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._123_1.vb)]"
  syntax:
    content: public static string CurDir ();
    parameters: []
    return:
      type: System.String
      description: "En streng som representerer gjeldende bane."
  overload: Microsoft.VisualBasic.FileSystem.CurDir*
  exceptions: []
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.CurDir(System.Char)
  id: CurDir(System.Char)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: CurDir(Char)
  nameWithType: FileSystem.CurDir(Char)
  fullName: Microsoft.VisualBasic.FileSystem.CurDir(Char)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Returnerer en streng som representerer gjeldende bane. Den <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref> gir deg bedre produktivitet og ytelse i i/u-operasjoner enn <xref uid=&quot;langword_csharp_CurDir&quot; name=&quot;CurDir&quot; href=&quot;&quot;> </xref>. Hvis du vil ha mer informasjon, kan du se <xref:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory*>.</xref:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory*>"
  remarks: ''
  example:
  - "This example uses the `CurDir` function to return the current path.  \n  \n [!code-vb[VbVbalrCatRef#65](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._203_1.vb)]"
  syntax:
    content: public static string CurDir (char Drive);
    parameters:
    - id: Drive
      type: System.Char
      description: "Valgfritt. <xref uid=&quot;langword_csharp_Char&quot; name=&quot;Char&quot; href=&quot;&quot;></xref>uttrykket som angir en eksisterende stasjon. Hvis ingen stasjon er angitt, eller hvis `Drive` er en tom streng (&quot;&quot;), <xref uid=&quot;langword_csharp_CurDir&quot; name=&quot;CurDir&quot; href=&quot;&quot;> </xref> banen for gjeldende stasjon."
    return:
      type: System.String
      description: "En streng som representerer gjeldende bane."
  overload: Microsoft.VisualBasic.FileSystem.CurDir*
  exceptions: []
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Dir
  id: Dir
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Dir()
  nameWithType: FileSystem.Dir()
  fullName: Microsoft.VisualBasic.FileSystem.Dir()
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Returnerer en streng som representerer navnet på en fil, katalog eller mappe som samsvarer med et angitt mønster eller filattributt eller volumnavnet til en stasjon. Den <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref> gir deg bedre produktivitet og ytelse i i/u-operasjoner enn den <xref uid=&quot;langword_csharp_Dir&quot; name=&quot;Dir&quot; href=&quot;&quot;> </xref> funksjonen. Se <xref:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo*>for mer informasjon.</xref:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo*>"
  remarks: "Den `Dir` funksjonen støtter bruk av flere tegn (`*`) og ett tegn (`?`) jokertegn å angi flere filer.       `VbVolume`Returnerer volumnavnet for stasjonen i stedet for et bestemt filnavn.       Du må oppgi en `PathName` første gang du kaller den `Dir` funksjonen. Du kan gjøre etterfølgende kall til for å hente neste element i `Dir` -funksjonen uten parametere.      > [!IMPORTANT] > Til å kjøre på riktig måte, den `Dir` funksjonen krever den <xref:System.Security.Permissions.FileIOPermissionAccess>og <xref:System.Security.Permissions.FileIOPermissionAccess>Flagg for <xref:System.Security.Permissions.FileIOPermission>skal gis til koden som kjører.</xref:System.Security.Permissions.FileIOPermission> </xref:System.Security.Permissions.FileIOPermissionAccess> </xref:System.Security.Permissions.FileIOPermissionAccess> Hvis du vil ha mer informasjon, se <xref:System.Security.Permissions.FileIOPermission>, <xref:System.Security.SecurityException>, og [kode tilgangstillatelser](http://msdn.microsoft.com/en-us/e5ae402f-6dda-4732-bbe8-77296630f675).</xref:System.Security.SecurityException> </xref:System.Security.Permissions.FileIOPermission>       Den `Attributes` argumentet nummereringsverdier er som følger: |||   |-|-|-|   | Verdien | Konstant | Beskrivelse |   | `Normal`|`vbnormal`| Standard. Angir filer uten attributter. |   | `ReadOnly`|`vbReadOnly`| Angir skrivebeskyttede filer og filer uten attributter. |   | `Hidden`|`vbHidden`| Angir skjulte filer og filer uten attributter. |   | `System`|`vbSystem`| Angir systemfiler og filer uten attributter. |   | `Volume`|`vbVolume`| Angir volumnavnet. Hvis alle andre attributter er angitt, `vbVolume` ignoreres. |   | `Directory`|`vbDirectory`| Angir kataloger eller mapper og filer også uten attributter. |   | `Archive`|`vbArchive`| Filen er endret siden forrige sikkerhetskopiering. |   | `Alias`|`vbAlias`| Filen har et annet navn. |      > [!NOTE] > Disse opplistinger er angitt i Visual Basic-språket og kan brukes hvor som helst i koden i stedet for de faktiske verdiene."
  example:
  - "This example uses the `Dir` function to check if certain files and directories exist.  \n  \n [!code-vb[VbVbalrCatRef#3](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._44_1.vb)]"
  syntax:
    content: public static string Dir ();
    parameters: []
    return:
      type: System.String
      description: "En streng som representerer navnet på en fil, katalog eller mappe som samsvarer med et angitt mønster eller filattributt eller volumnavnet til en stasjon."
  overload: Microsoft.VisualBasic.FileSystem.Dir*
  exceptions: []
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Dir(System.String,Microsoft.VisualBasic.FileAttribute)
  id: Dir(System.String,Microsoft.VisualBasic.FileAttribute)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Dir(String,FileAttribute)
  nameWithType: FileSystem.Dir(String,FileAttribute)
  fullName: Microsoft.VisualBasic.FileSystem.Dir(String,FileAttribute)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Returnerer en streng som representerer navnet på en fil, katalog eller mappe som samsvarer med et angitt mønster eller filattributt eller volumnavnet til en stasjon. Den <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref> gir deg bedre produktivitet og ytelse i i/u-operasjoner enn den <xref uid=&quot;langword_csharp_Dir&quot; name=&quot;Dir&quot; href=&quot;&quot;> </xref> funksjonen. Se <xref:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo*>for mer informasjon.</xref:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo*>"
  remarks: "Den `Dir` funksjonen støtter bruk av flere tegn (`*`) og ett tegn (`?`) jokertegn å angi flere filer.       `VbVolume`Returnerer volumnavnet for stasjonen i stedet for et bestemt filnavn.       Du må oppgi en `PathName` første gang du kaller den `Dir` funksjonen. Du kan gjøre etterfølgende kall til for å hente neste element i `Dir` funksjonen uten parametere.      > [!IMPORTANT] > Til å kjøre på riktig måte, den `Dir` funksjonen krever den <xref:System.Security.Permissions.FileIOPermissionAccess>og <xref:System.Security.Permissions.FileIOPermissionAccess>Flagg for <xref:System.Security.Permissions.FileIOPermission>skal gis til koden som kjører.</xref:System.Security.Permissions.FileIOPermission> </xref:System.Security.Permissions.FileIOPermissionAccess> </xref:System.Security.Permissions.FileIOPermissionAccess> Hvis du vil ha mer informasjon, se <xref:System.Security.Permissions.FileIOPermission>, <xref:System.Security.SecurityException>, og [kode tilgangstillatelser](http://msdn.microsoft.com/en-us/e5ae402f-6dda-4732-bbe8-77296630f675).</xref:System.Security.SecurityException> </xref:System.Security.Permissions.FileIOPermission>       Den `Attributes` argumentet nummereringsverdier er som følger: |||   |-|-|-|   | Verdien | Konstant | Beskrivelse |   | `Normal`|`vbnormal`| Standard. Angir filer som har ingen attributter. |   | `ReadOnly`|`vbReadOnly`| Angir skrivebeskyttede filer, i tillegg til filer som har ingen attributter. |   | `Hidden`|`vbHidden`| Angir skjulte filer i tillegg til filer som har ingen attributter. |   | `System`|`vbSystem`| Angir systemfiler, i tillegg til filer som har ingen attributter. |   | `Volume`|`vbVolume`| Angir volumnavnet. Hvis alle andre attributter er angitt, `vbVolume` ignoreres. |   | `Directory`|`vbDirectory`| Angir kataloger eller mapper, i tillegg til filer som ikke har noen attributter. |   | `Archive`|`vbArchive`| Filen er endret siden forrige sikkerhetskopiering. |   | `Alias`|`vbAlias`| Filen har et annet navn. |      > [!NOTE] > Disse opplistinger er angitt i Visual Basic-språket og kan brukes hvor som helst i koden i stedet for de faktiske verdiene."
  example:
  - "This example uses the `Dir` function to check if certain files and directories exist.  \n  \n [!code-vb[VbVbalrCatRef#3](~/add/codesnippet/visualbasic/0bb37160-d621-482a-af3b-_1.vb)]"
  syntax:
    content: public static string Dir (string PathName, Microsoft.VisualBasic.FileAttribute Attributes = Microsoft.VisualBasic.FileAttribute.Normal);
    parameters:
    - id: PathName
      type: System.String
      description: "Valgfritt. <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;></xref>uttrykket som angir et filnavn, katalog-eller mappenavn eller volumnavnet stasjon. En tom streng (<xref uid=&quot;langword_csharp_&quot;&quot;&quot; name=&quot;&quot;&quot;&quot; href=&quot;&quot;></xref>) returneres hvis `PathName` finnes ikke."
    - id: Attributes
      type: Microsoft.VisualBasic.FileAttribute
      description: "Valgfritt. Opplisting eller numerisk uttrykk som inneholder verdien angir filattributter. Hvis den utelates, <xref uid=&quot;langword_csharp_Dir&quot; name=&quot;Dir&quot; href=&quot;&quot;> </xref> returnerer filer som samsvarer med `PathName` , men har ingen attributter."
    return:
      type: System.String
      description: "En streng som representerer navnet på en fil, katalog eller mappe som samsvarer med et angitt mønster eller filattributt eller volumnavnet til en stasjon."
  overload: Microsoft.VisualBasic.FileSystem.Dir*
  exceptions: []
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.EOF(System.Int32)
  id: EOF(System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: EOF(Int32)
  nameWithType: FileSystem.EOF(Int32)
  fullName: Microsoft.VisualBasic.FileSystem.EOF(Int32)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Returnerer en boolsk verdi <xref uid=&quot;langword_csharp_True&quot; name=&quot;True&quot; href=&quot;&quot;> </xref> når slutten av en fil som er åpnet <xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> eller sekvensielle <xref uid=&quot;langword_csharp_Input&quot; name=&quot;Input&quot; href=&quot;&quot;> </xref> er nådd."
  remarks: "Bruk `EOF` å unngå feil som genereres ved forsøk på å hente inndata etter slutten av en fil.       Den `EOF` -funksjonen returnerer `False` til slutten av filen er nådd. Med filer som er åpnet `Random` eller `Binary` tilgang, `EOF` returnerer `False` til sist utførte `FileGet` funksjonen er kan ikke lese en hel post.       Med filer som er åpnet `Binary` tilgang til et forsøk på å lese gjennom filen med den `Input` funksjonen før `EOF` returnerer `True` genererer en feil. Bruk av `LOF` og `Loc` fungerer i stedet for `EOF` leser når binære filer med `Input`, eller Bruk `Get` ved bruk av den `EOF` funksjonen. Med filer som er åpnet `Output`, `EOF` returnerer alltid `True`."
  example:
  - "This example uses the `EOF` function to detect the end of a file. This example assumes that `Testfile` is a text file that contains several lines of text.  \n  \n [!code-vb[VbVbalrCatRef#62](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._184_1.vb)]"
  syntax:
    content: public static bool EOF (int FileNumber);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Kreves. En <xref uid=&quot;langword_csharp_Integer&quot; name=&quot;Integer&quot; href=&quot;&quot;> </xref> som inneholder et gyldig filnummer."
    return:
      type: System.Boolean
      description: "Returnerer en boolsk verdi <xref uid=&quot;langword_csharp_True&quot; name=&quot;True&quot; href=&quot;&quot;> </xref> når slutten av en fil som er åpnet <xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> eller sekvensielle <xref uid=&quot;langword_csharp_Input&quot; name=&quot;Input&quot; href=&quot;&quot;> </xref> er nådd."
  overload: Microsoft.VisualBasic.FileSystem.EOF*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Filen er ugyldig."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileAttr(System.Int32)
  id: FileAttr(System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileAttr(Int32)
  nameWithType: FileSystem.FileAttr(Int32)
  fullName: Microsoft.VisualBasic.FileSystem.FileAttr(Int32)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Returnerer en opplisting som representerer filen modus for filer som åpnes ved hjelp av den <xref uid=&quot;langword_csharp_FileOpen&quot; name=&quot;FileOpen&quot; href=&quot;&quot;> </xref> funksjonen. Den <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref> gir deg bedre produktivitet og ytelse i i/u-operasjoner enn den <xref uid=&quot;langword_csharp_FileAttr &quot; name=&quot;FileAttr &quot; href=&quot;&quot;> </xref>funksjonen. Se <xref:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo*>for mer informasjon.</xref:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo*>"
  remarks: "Denne funksjonen returnerer en opplisting som representerer filen modus for filer som åpnes ved hjelp av den `FileOpen` funksjonen."
  example:
  - "This example uses the `FileAttr` function to return the file mode of an open file.  \n  \n [!code-vb[VbVbalrCatRef#46](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._147_1.vb)]"
  syntax:
    content: public static Microsoft.VisualBasic.OpenMode FileAttr (int FileNumber);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Kreves. <xref uid=&quot;langword_csharp_Integer&quot; name=&quot;Integer&quot; href=&quot;&quot;></xref>. Et gyldig tall."
    return:
      type: Microsoft.VisualBasic.OpenMode
      description: "Følgende nummereringsverdier angi tilgangsmodus for filen:       <table><tbody><tr><td> Verdi       </td><td> Modus       </td></tr><tr><td> 1       </td><td><xref uid=&quot;langword_csharp_OpenMode.Input&quot; name=&quot;OpenMode.Input&quot; href=&quot;&quot;></xref></td></tr><tr><td> 2       </td><td><xref uid=&quot;langword_csharp_OpenMode.Output&quot; name=&quot;OpenMode.Output&quot; href=&quot;&quot;></xref></td></tr><tr><td> 4       </td><td><xref uid=&quot;langword_csharp_OpenMode.Random&quot; name=&quot;OpenMode.Random&quot; href=&quot;&quot;></xref></td></tr><tr><td> 8       </td><td><xref uid=&quot;langword_csharp_OpenMode.Append&quot; name=&quot;OpenMode.Append&quot; href=&quot;&quot;></xref></td></tr><tr><td> 32       </td><td><xref uid=&quot;langword_csharp_OpenMode.Binary&quot; name=&quot;OpenMode.Binary&quot; href=&quot;&quot;></xref></td></tr></tbody></table>"
  overload: Microsoft.VisualBasic.FileSystem.FileAttr*
  exceptions: []
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileClose(System.Int32[])
  id: FileClose(System.Int32[])
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileClose(Int32[])
  nameWithType: FileSystem.FileClose(Int32[])
  fullName: Microsoft.VisualBasic.FileSystem.FileClose(Int32[])
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Avsluttes inndata/u-til en fil som er åpnet ved hjelp av <xref uid=&quot;langword_csharp_FileOpen&quot; name=&quot;FileOpen&quot; href=&quot;&quot;> </xref> funksjonen. <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;></xref>gir deg bedre produktivitet og ytelse i i/u filoperasjoner. Se <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref> for mer informasjon."
  remarks: "Den `FileClose` -funksjonen er angitt for bakoverkompatibilitet og kan påvirke ytelsen. For ikke-eldre applikasjoner i `My.Computer.FileSystem` objektet gir bedre ytelse. Hvis du vil ha mer informasjon, se [slik: lese tekst fra filer med en StreamReader](~/add/includes/ajax-current-ext-md.md),[slik: Skriv tekst til filer med en StreamWriter](~/add/includes/ajax-current-ext-md.md), og [gjennomgang: manipulering av filer og mapper i Visual Basic](~/add/includes/ajax-current-ext-md.md).       Hvis du utelater `FileNumbers`, åpnes alle aktive filer av den `FileOpen` funksjonen er lukket.       Når du lukker filer ble åpnet for `Output` eller `Append`, endelig bufferen for utdata skrives til operativsystemet bufferen for denne filen. Alle buffer plassen som er knyttet til den lukkede fil frigis.       Når den `FileClose` funksjon er utført, tilordning av en fil med sin fil nummer avsluttes."
  example:
  - "This example uses the `FileClose`function to close a file opened for `Input`.  \n  \n [!code-vb[VbVbalrCatRef#69](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._41_1.vb)]"
  syntax:
    content: public static void FileClose (int[] FileNumbers);
    parameters:
    - id: FileNumbers
      type: System.Int32[]
      description: "Valgfritt. Parametermatrise for 0 eller flere kanaler med å lukkes."
  overload: Microsoft.VisualBasic.FileSystem.FileClose*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "<code>FileNumber</code>finnes ikke."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileCopy(System.String,System.String)
  id: FileCopy(System.String,System.String)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileCopy(String,String)
  nameWithType: FileSystem.FileCopy(String,String)
  fullName: Microsoft.VisualBasic.FileSystem.FileCopy(String,String)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Kopier en fil. Den <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref> gir deg bedre produktivitet og ytelse i i/u-operasjoner enn <xref uid=&quot;langword_csharp_FileCopy&quot; name=&quot;FileCopy&quot; href=&quot;&quot;> </xref>. Se <xref:Microsoft.VisualBasic.FileIO.FileSystem.CopyFile*>for mer informasjon.</xref:Microsoft.VisualBasic.FileIO.FileSystem.CopyFile*>"
  remarks: "Hvis du prøver å bruke den `FileCopy` fungere på en åpen fil, oppstår det en feil.       `FileCopy`krever fullstendig klarering skal fungere på lokal stasjon."
  example:
  - "This example uses the `FileCopy` function to copy one file to another. For purposes of this example, assume that `SrcFile` is a file that contains data.  \n  \n [!code-vb[VbVbalrCatRef#2](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._96_1.vb)]"
  syntax:
    content: public static void FileCopy (string Source, string Destination);
    parameters:
    - id: Source
      type: System.String
      description: "Kreves. <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;></xref>uttrykket som angir navnet på filen som skal kopieres. `Source`kan inneholde katalog eller mappe og stasjon på kildefilen."
    - id: Destination
      type: System.String
      description: "Kreves. <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;></xref>uttrykket som angir navnet på målet. `Destination`kan inneholde katalog eller mappe og stasjon på målfilen."
  overload: Microsoft.VisualBasic.FileSystem.FileCopy*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>Source</code>eller <code>Destination</code> er ugyldig eller ikke angitt."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Filen er allerede åpen."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "Filen finnes ikke."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileDateTime(System.String)
  id: FileDateTime(System.String)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileDateTime(String)
  nameWithType: FileSystem.FileDateTime(String)
  fullName: Microsoft.VisualBasic.FileSystem.FileDateTime(String)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Returnerer en <xref uid=&quot;langword_csharp_Date&quot; name=&quot;Date&quot; href=&quot;&quot;> </xref> verdi som angir datoen og klokkeslettet en fil ble skrevet til. Den <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funksjonen gir deg bedre produktivitet og ytelse i i/u-operasjoner enn <xref uid=&quot;langword_csharp_FileDateTime&quot; name=&quot;FileDateTime&quot; href=&quot;&quot;> </xref>. Hvis du vil ha mer informasjon, se<xref:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo*></xref:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo*>"
  remarks: ''
  example:
  - "This example uses the `FileDateTime` function to determine the date and time a file was created or last modified. The format of the date and time displayed is based on the locale settings of the system.  \n  \n [!code-vb[VbVbalrCatRef#34](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._22_1.vb)]"
  syntax:
    content: public static DateTime FileDateTime (string PathName);
    parameters:
    - id: PathName
      type: System.String
      description: "Kreves. <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;></xref>uttrykket som angir et filnavn. `PathName`kan inneholde mappen eller mappen og stasjonen."
    return:
      type: System.DateTime
      description: "<xref uid=&quot;langword_csharp_Date&quot; name=&quot;Date&quot; href=&quot;&quot;></xref>verdi som angir dato og klokkeslett en fil ble opprettet eller sist endret."
  overload: Microsoft.VisualBasic.FileSystem.FileDateTime*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>PathName</code>er ugyldig eller inneholder jokertegn."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "Målfilen finnes ikke."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Boolean@,System.Int64)
  id: FileGet(System.Int32,System.Boolean@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileGet(Int32,Boolean,Int64)
  nameWithType: FileSystem.FileGet(Int32,Boolean,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Boolean,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Viser data fra en åpen diskfil til en variabel. Den <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funksjonen gir deg bedre produktivitet og ytelse i i/u-operasjoner enn <xref uid=&quot;langword_csharp_FileGet&quot; name=&quot;FileGet&quot; href=&quot;&quot;> </xref>. Hvis du vil ha mer informasjon, se<xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;></xref>"
  remarks: "`FileGet` is valid only in `Random` and `Binary` mode.  \n  \n Data read with `FileGet` is usually written to a file with `FilePut`.  \n  \n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.  \n  \n> [!IMPORTANT]\n>  When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.  \n  \n## Random Mode  \n For files opened in `Random` mode, the following rules apply:  \n  \n-   If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.  \n  \n-   By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \n  \n-   If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array. To write the descriptor, set the `ArrayIsDynamic` parameter to `True`. When reading the array, you have to match the way the array was written. If it was written with the descriptor, you have to read the descriptor. If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.  \n  \n     The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \n  \n     [!code-vb[VbVbalrCatRef#21](~/add/codesnippet/visualbasic/ad6628f8-6ae5-47af-a394-_1.vb)]  \n  \n     The 218 bytes are distributed as follows:  \n  \n    -   18 bytes for the descriptor: (2 + 8 * 2)  \n  \n    -   200 bytes for the data: (5 * 10 \\* 4).  \n  \n-   If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.  \n  \n-   `FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen`function must be greater than or equal to the sum of all the bytes required to read the individual elements. This includes any arrays and their descriptors. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.  \n  \n## Binary Mode  \n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \n  \n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FileGet` reads all variables from disk contiguously; that is, without padding between records.  \n  \n-   For any array other than an array in a structure, `FileGet` reads only the data. No descriptor is read.  \n  \n-   `FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.  \n  \n    > [!IMPORTANT]\n    >  Reading from a file by using the`FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration."
  syntax:
    content: public static void FileGet (int FileNumber, ref bool Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Kreves. Et gyldig tall."
    - id: Value
      type: System.Boolean
      description: "Kreves. Ugyldig variabelnavn som lese data."
    - id: RecordNumber
      type: System.Int64
      description: "Valgfritt. Postnummer (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> modus filer) eller byte tall (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> modus filer) på som lesing starter."
  overload: Microsoft.VisualBasic.FileSystem.FileGet*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 og ikke er lik -1."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Filen er ugyldig."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Byte@,System.Int64)
  id: FileGet(System.Int32,System.Byte@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileGet(Int32,Byte,Int64)
  nameWithType: FileSystem.FileGet(Int32,Byte,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Byte,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Viser data fra en åpen diskfil til en variabel. Den <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funksjonen gir deg bedre produktivitet og ytelse i i/u-operasjoner enn <xref uid=&quot;langword_csharp_FileGet&quot; name=&quot;FileGet&quot; href=&quot;&quot;> </xref>. Hvis du vil ha mer informasjon, se <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FileGet` is valid only in `Random` and `Binary` mode.  \n  \n Data read with `FileGet` is usually written to a file with `FilePut`.  \n  \n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.  \n  \n> [!IMPORTANT]\n>  When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.  \n  \n## Random Mode  \n For files opened in `Random` mode, the following rules apply:  \n  \n-   If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.  \n  \n-   By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \n  \n-   If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array. To write the descriptor, set the `ArrayIsDynamic`parameter to `True`. When reading the array, you have to match the way the array was written. If it was written with the descriptor, you have to read the descriptor. If the descriptor is not used. Then the size and bounds of the array passed into `FileGet` determine what to read.  \n  \n     The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \n  \n     [!code-vb[VbVbalrCatRef#21](~/add/codesnippet/visualbasic/9daa1fad-0f67-40af-bac0-_1.vb)]  \n  \n     The 218 bytes are distributed as follows:  \n  \n    -   18 bytes for the descriptor: (2 + 8 * 2)  \n  \n    -   200 bytes for the data: (5 * 10 \\* 4).  \n  \n-   If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.  \n  \n-   `FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen`function must be greater than or equal to the sum of all the bytes required to read the individual elements. This includes any arrays and their descriptors. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.  \n  \n## Binary Mode  \n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \n  \n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FileGet` reads all variables from disk contiguously; that is, without padding between records.  \n  \n-   For any array other than an array in a structure, `FileGet` reads only the data. No descriptor is read.  \n  \n-   `FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.  \n  \n    > [!IMPORTANT]\n    >  Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration."
  syntax:
    content: public static void FileGet (int FileNumber, ref byte Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Kreves. Et gyldig tall."
    - id: Value
      type: System.Byte
      description: "Kreves. Ugyldig variabelnavn som lese data."
    - id: RecordNumber
      type: System.Int64
      description: "Valgfritt. Postnummer (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> modus filer) eller byte tall (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> modus filer) på som lesing starter."
  overload: Microsoft.VisualBasic.FileSystem.FileGet*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 og ikke er lik -1."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Filen er ugyldig."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Char@,System.Int64)
  id: FileGet(System.Int32,System.Char@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileGet(Int32,Char,Int64)
  nameWithType: FileSystem.FileGet(Int32,Char,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Char,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Viser data fra en åpen diskfil til en variabel. Den <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funksjonen gir deg bedre produktivitet og ytelse i i/u-operasjoner enn <xref uid=&quot;langword_csharp_FileGet&quot; name=&quot;FileGet&quot; href=&quot;&quot;> </xref>. Hvis du vil ha mer informasjon, se <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FileGet` is valid only in `Random` and `Binary` mode.  \n  \n Data read with `FileGet` is usually written to a file with `FilePut`.  \n  \n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.  \n  \n> [!IMPORTANT]\n>  When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.  \n  \n## Random Mode  \n For files opened in `Random` mode, the following rules apply:  \n  \n-   If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.  \n  \n-   By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \n  \n-   If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array. To write the descriptor, set the `ArrayIsDynamic`parameter to `True`. When reading the array, you have to match the way the array was written. If it was written with the descriptor, you have to read the descriptor. If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.  \n  \n     The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \n  \n     [!code-vb[VbVbalrCatRef#21](~/add/codesnippet/visualbasic/31a532e9-297f-48c8-a186-_1.vb)]  \n  \n     The 218 bytes are distributed as follows:  \n  \n    -   18 bytes for the descriptor: (2 + 8 * 2)  \n  \n    -   200 bytes for the data: (5 * 10 \\* 4).  \n  \n-   If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.  \n  \n-   `FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen`function must be greater than or equal to the sum of all the bytes required to read the individual elements. This includes any arrays and their descriptors. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.  \n  \n## Binary Mode  \n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \n  \n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FileGet` reads all variables from disk contiguously; that is, without padding between records.  \n  \n-   For any array other than an array in a structure, `FileGet` reads only the data. No descriptor is read.  \n  \n-   `FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.  \n  \n    > [!IMPORTANT]\n    >  Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration."
  syntax:
    content: public static void FileGet (int FileNumber, ref char Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Kreves. Et gyldig tall."
    - id: Value
      type: System.Char
      description: "Kreves. Ugyldig variabelnavn som lese data."
    - id: RecordNumber
      type: System.Int64
      description: "Valgfritt. Postnummer (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> modus filer) eller byte tall (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> modus filer) på som lesing starter."
  overload: Microsoft.VisualBasic.FileSystem.FileGet*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 og ikke er lik -1."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Filen er ugyldig."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.DateTime@,System.Int64)
  id: FileGet(System.Int32,System.DateTime@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileGet(Int32,DateTime,Int64)
  nameWithType: FileSystem.FileGet(Int32,DateTime,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,DateTime,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Viser data fra en åpen diskfil til en variabel. Den <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funksjonen gir deg bedre produktivitet og ytelse i i/u-operasjoner enn <xref uid=&quot;langword_csharp_FileGet&quot; name=&quot;FileGet&quot; href=&quot;&quot;> </xref>. Hvis du vil ha mer informasjon, se <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FileGet` is valid only in `Random` and `Binary` mode.  \n  \n Data read with `FileGet` is usually written to a file with `FilePut`.  \n  \n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.  \n  \n> [!IMPORTANT]\n>  When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.  \n  \n## Random Mode  \n For files opened in `Random` mode, the following rules apply:  \n  \n-   If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function,`FileGet` reads subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.  \n  \n-   By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \n  \n-   If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array. To write the descriptor, set the `ArrayIsDynamic` parameter to `True`. When reading the array, you have to match the way the array was written. If it was written with the descriptor, you have to read the descriptor. If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.  \n  \n     The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \n  \n     [!code-vb[VbVbalrCatRef#21](~/add/codesnippet/visualbasic/d9877ddb-692f-47fe-8c26-_1.vb)]  \n  \n     The 218 bytes are distributed as follows:  \n  \n    -   18 bytes for the descriptor: (2 + 8 * 2)  \n  \n    -   200 bytes for the data: (5 * 10 \\* 4).  \n  \n-   If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.  \n  \n-   `FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen`function must be greater than or equal to the sum of all the bytes required to read the individual elements. This includes any arrays and their descriptors. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.  \n  \n## Binary Mode  \n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \n  \n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FileGet` reads all variables from disk contiguously; that is, without padding between records.  \n  \n-   For any array other than an array in a structure, `FileGet` reads only the data. No descriptor is read.  \n  \n-   `FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.  \n  \n    > [!IMPORTANT]\n    >  Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration."
  syntax:
    content: public static void FileGet (int FileNumber, ref DateTime Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Kreves. Et gyldig tall."
    - id: Value
      type: System.DateTime
      description: "Kreves. Ugyldig variabelnavn som lese data."
    - id: RecordNumber
      type: System.Int64
      description: "Valgfritt. Postnummer (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> modus filer) eller byte tall (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> modus filer) på som lesing starter."
  overload: Microsoft.VisualBasic.FileSystem.FileGet*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 og ikke er lik -1."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Filen er ugyldig."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Decimal@,System.Int64)
  id: FileGet(System.Int32,System.Decimal@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileGet(Int32,Decimal,Int64)
  nameWithType: FileSystem.FileGet(Int32,Decimal,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Decimal,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Viser data fra en åpen diskfil til en variabel. Den <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funksjonen gir deg bedre produktivitet og ytelse i i/u-operasjoner enn <xref uid=&quot;langword_csharp_FileGet&quot; name=&quot;FileGet&quot; href=&quot;&quot;> </xref>. Hvis du vil ha mer informasjon, se <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FileGet` is valid only in `Random` and `Binary` mode.  \n  \n Data read with `FileGet` is usually written to a file by using `FilePut`.  \n  \n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.  \n  \n> [!IMPORTANT]\n>  When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.  \n  \n## Random Mode  \n For files opened in `Random` mode, the following rules apply:  \n  \n-   If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.  \n  \n-   By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \n  \n-   If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array. To write the descriptor, set the `ArrayIsDynamic` parameter to `True`. When reading the array, you have to match the way the array was written. If it was written with the descriptor, you have to read the descriptor. If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.  \n  \n     The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \n  \n     [!code-vb[VbVbalrCatRef#21](~/add/codesnippet/visualbasic/3d9f416d-1287-4566-b3fa-_1.vb)]  \n  \n     The 218 bytes are distributed as follows:  \n  \n    -   18 bytes for the descriptor: (2 + 8 * 2)  \n  \n    -   200 bytes for the data: (5 * 10 \\* 4).  \n  \n-   If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.  \n  \n-   `FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen`function must be greater than or equal to the sum of all the bytes required to read the individual elements. This includes any arrays and their descriptors. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.  \n  \n## Binary Mode  \n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \n  \n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FileGet` reads all variables from disk contiguously; that is, without padding between records.  \n  \n-   For any array other than an array in a structure, `FileGet` reads only the data. No descriptor is read.  \n  \n-   `FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.  \n  \n    > [!IMPORTANT]\n    >  Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration."
  syntax:
    content: public static void FileGet (int FileNumber, ref decimal Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Kreves. Et gyldig tall."
    - id: Value
      type: System.Decimal
      description: "Kreves. Ugyldig variabelnavn som lese data."
    - id: RecordNumber
      type: System.Int64
      description: "Valgfritt. Postnummer (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> modus filer) eller byte tall (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> modus filer) på som lesing starter."
  overload: Microsoft.VisualBasic.FileSystem.FileGet*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 og ikke er lik -1."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Filen er ugyldig."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Double@,System.Int64)
  id: FileGet(System.Int32,System.Double@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileGet(Int32,Double,Int64)
  nameWithType: FileSystem.FileGet(Int32,Double,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Double,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Viser data fra en åpen diskfil til en variabel. Den <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funksjonen gir deg bedre produktivitet og ytelse i i/u-operasjoner enn <xref uid=&quot;langword_csharp_FileGet&quot; name=&quot;FileGet&quot; href=&quot;&quot;> </xref>. Hvis du vil ha mer informasjon, se <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FileGet` is valid only in `Random` and `Binary` mode.  \n  \n Data read with `FileGet` is usually written to a file by using `FilePut`.  \n  \n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.  \n  \n> [!IMPORTANT]\n>  When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.  \n  \n## Random Mode  \n For files opened in `Random` mode, the following rules apply:  \n  \n-   If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.  \n  \n-   By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \n  \n-   If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array. To write the descriptor, set the `ArrayIsDynamic` parameter to `True`. When reading the array, you have to match the way the array was written. If it was written with the descriptor, you have to read the descriptor. If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.  \n  \n     The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \n  \n     [!code-vb[VbVbalrCatRef#21](~/add/codesnippet/visualbasic/184fee0e-b744-4669-8fdf-_1.vb)]  \n  \n     The 218 bytes are distributed as follows:  \n  \n    -   18 bytes for the descriptor: (2 + 8 * 2)  \n  \n    -   200 bytes for the data: (5 * 10 \\* 4).  \n  \n-   If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.  \n  \n-   `FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen`function must be greater than or equal to the sum of all the bytes required to read the individual elements. This includes any arrays and their descriptors. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.  \n  \n## Binary Mode  \n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \n  \n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FileGet` reads all variables from disk contiguously; that is, without padding between records.  \n  \n-   For any array other than an array in a structure, `FileGet` reads only the data. No descriptor is read.  \n  \n-   `FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.  \n  \n    > [!IMPORTANT]\n    >  Reading from a file by using the`FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration."
  syntax:
    content: public static void FileGet (int FileNumber, ref double Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Kreves. Et gyldig tall."
    - id: Value
      type: System.Double
      description: "Kreves. Ugyldig variabelnavn som lese data."
    - id: RecordNumber
      type: System.Int64
      description: "Valgfritt. Postnummer (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> modus filer) eller byte tall (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> modus filer) på som lesing starter."
  overload: Microsoft.VisualBasic.FileSystem.FileGet*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 og ikke er lik -1."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Filen er ugyldig."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int16@,System.Int64)
  id: FileGet(System.Int32,System.Int16@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileGet(Int32,Int16,Int64)
  nameWithType: FileSystem.FileGet(Int32,Int16,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Int16,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Viser data fra en åpen diskfil til en variabel. Den <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funksjonen gir deg bedre produktivitet og ytelse i i/u-operasjoner enn <xref uid=&quot;langword_csharp_FileGet&quot; name=&quot;FileGet&quot; href=&quot;&quot;> </xref>. Hvis du vil ha mer informasjon, se <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FileGet` is valid only in `Random` and `Binary` mode.  \n  \n Data read with `FileGet` is usually written to a file by using `FilePut`.  \n  \n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.  \n  \n> [!IMPORTANT]\n>  When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.  \n  \n## Random Mode  \n For files opened in `Random` mode, the following rules apply:  \n  \n-   If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.  \n  \n-   By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \n  \n-   If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array. To write the descriptor, set the `ArrayIsDynamic`parameter to `True`. When reading the array, you have to match the way the array was written. If it was written with the descriptor, you have to read the descriptor. If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.  \n  \n     The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \n  \n     [!code-vb[VbVbalrCatRef#21](~/add/codesnippet/visualbasic/45e0fdff-455b-4fd4-a7c2-_1.vb)]  \n  \n     The 218 bytes are distributed as follows:  \n  \n    -   18 bytes for the descriptor: (2 + 8 * 2)  \n  \n    -   200 bytes for the data: (5 * 10 \\* 4).  \n  \n-   If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.  \n  \n-   `FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen`function must be greater than or equal to the sum of all the bytes required to read the individual elements. This includes any arrays and their descriptors. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.  \n  \n## Binary Mode  \n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \n  \n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FileGet` reads all variables from disk contiguously; that is, without padding between records.  \n  \n-   For any array other than an array in a structure, `FileGet` reads only the data. No descriptor is read.  \n  \n-   `FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.  \n  \n    > [!IMPORTANT]\n    >  Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration."
  syntax:
    content: public static void FileGet (int FileNumber, ref short Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Kreves. Et gyldig tall."
    - id: Value
      type: System.Int16
      description: "Kreves. Ugyldig variabelnavn som lese data."
    - id: RecordNumber
      type: System.Int64
      description: "Valgfritt. Postnummer (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> modus filer) eller byte tall (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> modus filer) på som lesing starter."
  overload: Microsoft.VisualBasic.FileSystem.FileGet*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 og ikke er lik -1."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Filen er ugyldig."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int32@,System.Int64)
  id: FileGet(System.Int32,System.Int32@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileGet(Int32,Int32,Int64)
  nameWithType: FileSystem.FileGet(Int32,Int32,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Int32,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Viser data fra en åpen diskfil til en variabel. Den <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funksjonen gir deg bedre produktivitet og ytelse i i/u-operasjoner enn <xref uid=&quot;langword_csharp_FileGet&quot; name=&quot;FileGet&quot; href=&quot;&quot;> </xref>. Hvis du vil ha mer informasjon, se <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FileGet` is valid only in `Random` and `Binary` mode.  \n  \n Data read with `FileGet` is usually written to a file by using `FilePut`.  \n  \n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.  \n  \n> [!IMPORTANT]\n>  When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.  \n  \n## Random Mode  \n For files opened in `Random` mode, the following rules apply:  \n  \n-   If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.  \n  \n-   By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \n  \n-   If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array. To write the descriptor, set the `ArrayIsDynamic` parameter to `True`. When reading the array, you have to match the way the array was written. If it was written with the descriptor, you have to read the descriptor. If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.  \n  \n     The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \n  \n     [!code-vb[VbVbalrCatRef#21](~/add/codesnippet/visualbasic/7db3ee1c-ee17-457b-bd2d-_1.vb)]  \n  \n     The 218 bytes are distributed as follows:  \n  \n    -   18 bytes for the descriptor: (2 + 8 * 2)  \n  \n    -   200 bytes for the data: (5 * 10 \\* 4).  \n  \n-   If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.  \n  \n-   `FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen`function must be greater than or equal to the sum of all the bytes required to read the individual elements. This includes any arrays and their descriptors. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.  \n  \n## Binary Mode  \n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \n  \n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FileGet` reads all variables from disk contiguously; that is, without padding between records.  \n  \n-   For any array other than an array in a structure, `FileGet` reads only the data. No descriptor is read.  \n  \n-   `FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.  \n  \n    > [!IMPORTANT]\n    >  Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration."
  syntax:
    content: public static void FileGet (int FileNumber, ref int Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Kreves. Et gyldig tall."
    - id: Value
      type: System.Int32
      description: "Kreves. Ugyldig variabelnavn som lese data."
    - id: RecordNumber
      type: System.Int64
      description: "Valgfritt. Postnummer (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> modus filer) eller byte tall (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> modus filer) på som lesing starter."
  overload: Microsoft.VisualBasic.FileSystem.FileGet*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 og ikke er lik -1."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Filen er ugyldig."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int64@,System.Int64)
  id: FileGet(System.Int32,System.Int64@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileGet(Int32,Int64,Int64)
  nameWithType: FileSystem.FileGet(Int32,Int64,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Int64,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Viser data fra en åpen diskfil til en variabel. Den <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funksjonen gir deg bedre produktivitet og ytelse i i/u-operasjoner enn <xref uid=&quot;langword_csharp_FileGet&quot; name=&quot;FileGet&quot; href=&quot;&quot;> </xref>. Hvis du vil ha mer informasjon, se <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FileGet` is valid only in `Random` and `Binary` mode.  \n  \n Data read with `FileGet` is usually written to a file by using `FilePut`.  \n  \n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.  \n  \n> [!IMPORTANT]\n>  When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.  \n  \n## Random Mode  \n For files opened in `Random` mode, the following rules apply:  \n  \n-   If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.  \n  \n-   By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \n  \n-   If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array. To write the descriptor, set the `ArrayIsDynamic` parameter to `True`. When reading the array, you have to match the way the array was written. If it was written with the descriptor, you have to read the descriptor. If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.  \n  \n     The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \n  \n     [!code-vb[VbVbalrCatRef#21](~/add/codesnippet/visualbasic/bd48d1ef-82ea-4239-8c9b-_1.vb)]  \n  \n     The 218 bytes are distributed as follows:  \n  \n    -   18 bytes for the descriptor: (2 + 8 * 2)  \n  \n    -   200 bytes for the data: (5 * 10 \\* 4).  \n  \n-   If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.  \n  \n-   `FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen`function must be greater than or equal to the sum of all the bytes required to read the individual elements. This includes any arrays and their descriptors. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.  \n  \n## Binary Mode  \n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \n  \n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FileGet` reads all variables from disk contiguously; that is, without padding between records.  \n  \n-   For any array other than an array in a structure, `FileGet` reads only the data. No descriptor is read.  \n  \n-   `FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.  \n  \n    > [!IMPORTANT]\n    >  Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration."
  syntax:
    content: public static void FileGet (int FileNumber, ref long Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Kreves. Et gyldig tall."
    - id: Value
      type: System.Int64
      description: "Kreves. Ugyldig variabelnavn som lese data."
    - id: RecordNumber
      type: System.Int64
      description: "Valgfritt. Postnummer (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> modus filer) eller byte tall (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> modus filer) på som lesing starter."
  overload: Microsoft.VisualBasic.FileSystem.FileGet*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 og ikke er lik -1."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Filen er ugyldig."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Single@,System.Int64)
  id: FileGet(System.Int32,System.Single@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileGet(Int32,Single,Int64)
  nameWithType: FileSystem.FileGet(Int32,Single,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Single,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Viser data fra en åpen diskfil til en variabel. Den <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funksjonen gir deg bedre produktivitet og ytelse i i/u-operasjoner enn <xref uid=&quot;langword_csharp_FileGet&quot; name=&quot;FileGet&quot; href=&quot;&quot;> </xref>. Hvis du vil ha mer informasjon, se <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FileGet` is valid only in `Random` and `Binary` mode.  \n  \n Data read with `FileGet` is usually written to a file by using `FilePut`.  \n  \n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.  \n  \n> [!IMPORTANT]\n>  When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.  \n  \n## Random Mode  \n For files opened in `Random` mode, the following rules apply:  \n  \n-   If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.  \n  \n-   By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \n  \n-   If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array. To write the descriptor, set the `ArrayIsDynamic` parameter to `True`. When reading the array, you have to match the way the array was written. If it was written with the descriptor, you have to read the descriptor. If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.  \n  \n     The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \n  \n     [!code-vb[VbVbalrCatRef#21](~/add/codesnippet/visualbasic/79f9948f-e0d0-41fe-a7b5-_1.vb)]  \n  \n     The 218 bytes are distributed as follows:  \n  \n    -   18 bytes for the descriptor: (2 + 8 * 2)  \n  \n    -   200 bytes for the data: (5 * 10 \\* 4).  \n  \n-   If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.  \n  \n-   `FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen`function must be greater than or equal to the sum of all the bytes required to read the individual elements. This includes any arrays and their descriptors. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.  \n  \n## Binary Mode  \n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \n  \n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FileGet` reads all variables from disk contiguously; that is, without padding between records.  \n  \n-   For any array other than an array in a structure, `FileGet` reads only the data. No descriptor is read.  \n  \n-   `FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.  \n  \n    > [!IMPORTANT]\n    >  Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration."
  syntax:
    content: public static void FileGet (int FileNumber, ref float Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Kreves. Et gyldig tall."
    - id: Value
      type: System.Single
      description: "Kreves. Ugyldig variabelnavn som lese data."
    - id: RecordNumber
      type: System.Int64
      description: "Valgfritt. Postnummer (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> modus filer) eller byte tall (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> modus filer) på som lesing starter."
  overload: Microsoft.VisualBasic.FileSystem.FileGet*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 og ikke er lik -1."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Filen er ugyldig."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.ValueType@,System.Int64)
  id: FileGet(System.Int32,System.ValueType@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileGet(Int32,ValueType,Int64)
  nameWithType: FileSystem.FileGet(Int32,ValueType,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,ValueType,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Viser data fra en åpen diskfil til en variabel. Den <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funksjonen gir deg bedre produktivitet og ytelse i i/u-operasjoner enn <xref uid=&quot;langword_csharp_FileGet&quot; name=&quot;FileGet&quot; href=&quot;&quot;> </xref>. Hvis du vil ha mer informasjon, se <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FileGet` is valid only in `Random` and `Binary` mode.  \n  \n Data read with `FileGet` is usually written to a file by using `FilePut`.  \n  \n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.  \n  \n> [!IMPORTANT]\n>  When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.  \n  \n## Random Mode  \n For files opened in `Random` mode, the following rules apply:  \n  \n-   If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.  \n  \n-   By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \n  \n-   If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array. To write the descriptor, set the `ArrayIsDynamic` parameter to `True`. When reading the array, you have to match the way the array was written. If it was written with the descriptor, you have to read the descriptor. If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.  \n  \n     The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \n  \n     [!code-vb[VbVbalrCatRef#21](~/add/codesnippet/visualbasic/f351f02c-d919-4d73-938f-_1.vb)]  \n  \n     The 218 bytes are distributed as follows:  \n  \n    -   18 bytes for the descriptor: (2 + 8 * 2)  \n  \n    -   200 bytes for the data: (5 * 10 \\* 4).  \n  \n-   If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.  \n  \n-   `FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen`function must be greater than or equal to the sum of all the bytes required to read the individual elements. This includes any arrays and their descriptors. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.  \n  \n## Binary Mode  \n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \n  \n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FileGet` reads all variables from disk contiguously; that is, without padding between records.  \n  \n-   For any array other than an array in a structure, `FileGet` reads only the data. No descriptor is read.  \n  \n-   `FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.  \n  \n    > [!IMPORTANT]\n    >  Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration."
  syntax:
    content: public static void FileGet (int FileNumber, ref ValueType Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Kreves. Et gyldig tall."
    - id: Value
      type: System.ValueType
      description: "Kreves. Ugyldig variabelnavn som lese data."
    - id: RecordNumber
      type: System.Int64
      description: "Valgfritt. Postnummer (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> modus filer) eller byte tall (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> modus filer) på som lesing starter."
  overload: Microsoft.VisualBasic.FileSystem.FileGet*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 og ikke er lik -1."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Filen er ugyldig."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.String@,System.Int64,System.Boolean)
  id: FileGet(System.Int32,System.String@,System.Int64,System.Boolean)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileGet(Int32,String,Int64,Boolean)
  nameWithType: FileSystem.FileGet(Int32,String,Int64,Boolean)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,String,Int64,Boolean)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Viser data fra en åpen diskfil til en variabel. Den <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funksjonen gir deg bedre produktivitet og ytelse i i/u-operasjoner enn <xref uid=&quot;langword_csharp_FileGet&quot; name=&quot;FileGet&quot; href=&quot;&quot;> </xref>. Hvis du vil ha mer informasjon, se <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FileGet` is valid only in `Random` and `Binary` mode.  \n  \n Data read with `FileGet` is usually written to a file by using `FilePut`.  \n  \n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.  \n  \n> [!IMPORTANT]\n>  When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.  \n  \n## Random Mode  \n For files opened in `Random` mode, the following rules apply:  \n  \n-   If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.  \n  \n-   By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \n  \n-   If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array. To write the descriptor, set the `ArrayIsDynamic` parameter to `True`. When reading the array, you have to match the way the array was written. If it was written with the descriptor, you have to read the descriptor. If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.  \n  \n     The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \n  \n     [!code-vb[VbVbalrCatRef#21](~/add/codesnippet/visualbasic/cefffea4-17eb-455d-be3e-_1.vb)]  \n  \n     The 218 bytes are distributed as follows:  \n  \n    -   18 bytes for the descriptor: (2 + 8 * 2)  \n  \n    -   200 bytes for the data: (5 * 10 \\* 4).  \n  \n-   If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.  \n  \n-   `FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements. This includes any arrays and their descriptors. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.  \n  \n## Binary Mode  \n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \n  \n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FileGet` reads all variables from disk contiguously; that is, without padding between records.  \n  \n-   For any array other than an array in a structure, `FileGet` reads only the data. No descriptor is read.  \n  \n-   `FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.  \n  \n    > [!IMPORTANT]\n    >  Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration."
  syntax:
    content: public static void FileGet (int FileNumber, ref string Value, long RecordNumber = -1, bool StringIsFixedLength = false);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Kreves. Et gyldig tall."
    - id: Value
      type: System.String
      description: "Kreves. Ugyldig variabelnavn som lese data."
    - id: RecordNumber
      type: System.Int64
      description: "Valgfritt. Postnummer (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> modus filer) eller byte tall (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> modus filer) på som lesing starter."
    - id: StringIsFixedLength
      type: System.Boolean
      description: "Valgfritt. Gjelder bare når skriving av en streng. Angir om å skrive en to byte beskrivelse for strengen som beskriver lengden. Standard <xref uid=&quot;langword_csharp_False&quot; name=&quot;False&quot; href=&quot;&quot;> </xref>."
  overload: Microsoft.VisualBasic.FileSystem.FileGet*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 og ikke er lik -1."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Filen er ugyldig."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Array@,System.Int64,System.Boolean,System.Boolean)
  id: FileGet(System.Int32,System.Array@,System.Int64,System.Boolean,System.Boolean)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileGet(Int32,Array,Int64,Boolean,Boolean)
  nameWithType: FileSystem.FileGet(Int32,Array,Int64,Boolean,Boolean)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Array,Int64,Boolean,Boolean)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Viser data fra en åpen diskfil til en variabel. Den <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funksjonen gir deg bedre produktivitet og ytelse i i/u-operasjoner enn <xref uid=&quot;langword_csharp_FileGet&quot; name=&quot;FileGet&quot; href=&quot;&quot;> </xref>. Hvis du vil ha mer informasjon, se <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FileGet` is valid only in `Random` and `Binary` mode.  \n  \n Data read with `FileGet` is usually written to a file by using `FilePut`.  \n  \n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.  \n  \n> [!IMPORTANT]\n>  When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.  \n  \n## Random Mode  \n For files opened in `Random` mode, the following rules apply:  \n  \n-   If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries. The space between the end of one record and the starting of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.  \n  \n-   By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \n  \n-   If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array. To write the descriptor, set the `ArrayIsDynamic` parameter to `True`. When reading the array, you have to match the way the array was written. If it was written with the descriptor, you have to read the descriptor. If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.  \n  \n     The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \n  \n     [!code-vb[VbVbalrCatRef#21](~/add/codesnippet/visualbasic/c053ec00-d593-49bf-a3cb-_1.vb)]  \n  \n     The 218 bytes are distributed as follows:  \n  \n    -   18 bytes for the descriptor: (2 + 8 * 2)  \n  \n    -   200 bytes for the data: (5 * 10 \\* 4).  \n  \n-   If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.  \n  \n-   `FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements. This includes any arrays and their descriptors. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.  \n  \n## Binary Mode  \n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \n  \n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FileGet` reads all variables from disk contiguously; that is, without padding between records.  \n  \n-   For any array other than an array in a structure, `FileGet` reads only the data. No descriptor is read.  \n  \n-   `FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.  \n  \n    > [!IMPORTANT]\n    >  Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration."
  syntax:
    content: public static void FileGet (int FileNumber, ref Array Value, long RecordNumber = -1, bool ArrayIsDynamic = false, bool StringIsFixedLength = false);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Kreves. Et gyldig tall."
    - id: Value
      type: System.Array
      description: "Kreves. Ugyldig variabelnavn som lese data."
    - id: RecordNumber
      type: System.Int64
      description: "Valgfritt. Postnummer (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> modus filer) eller byte tall (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> modus filer) på som lesing starter."
    - id: ArrayIsDynamic
      type: System.Boolean
      description: "Valgfritt. Gjelder bare når skriving av en matrise. Angir om matrisen er skal behandles som dynamiske og om en matrise sikkerhetsbeskrivelse som beskriver størrelsen og grensene for matrisen er nødvendig."
    - id: StringIsFixedLength
      type: System.Boolean
      description: "Valgfritt. Gjelder bare når skriving av en streng. Angir om å skrive en to byte beskrivelse for strengen som beskriver lengden. Standard <xref uid=&quot;langword_csharp_False&quot; name=&quot;False&quot; href=&quot;&quot;> </xref>."
  overload: Microsoft.VisualBasic.FileSystem.FileGet*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 og ikke er lik -1."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Filen er ugyldig."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)
  id: FileGetObject(System.Int32,System.Object@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileGetObject(Int32,Object,Int64)
  nameWithType: FileSystem.FileGetObject(Int32,Object,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGetObject(Int32,Object,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Viser data fra en åpen diskfil til en variabel.  Den <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funksjonen gir deg bedre produktivitet og ytelse i i/u-operasjoner enn <xref uid=&quot;langword_csharp_FileGetObject&quot; name=&quot;FileGetObject&quot; href=&quot;&quot;> </xref>. Hvis du vil ha mer informasjon, se <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "The `FileGetObject` function is used instead of `FileGet` to avoid ambiguities at compile time if type `Object` is returned instead of another type, such as `Integer`, `Long`, `Short`, and so forth.  \n  \n If you intend to write out the `Variant` type, `FileGetObject` is required. When in doubt, if you are using an object for the second parameter, it is always suggested that you use `FilePutObject` and `FileGetObject`.  \n  \n `FileGetObject` is valid only in `Random` and `Binary` mode.  \n  \n Data read with `FileGetObject` is usually written with `FilePutObject`.  \n  \n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, `FileGetObject` reads the record or byte after the last `FileGetObject` or `FilePutObject` function (or pointed to by the last `Seek` function).  \n  \n## Random Mode  \n For files opened in `Random` mode, the following rules apply:  \n  \n-   If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGetObject` reads subsequent records on record-length boundaries. The space between the end of one record and the beginning of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be precisely determined, it is a good idea to have the record length match the length of the data being read.  \n  \n-   If the variable being read into is a string, by default `FileGetObject` reads a two-byte descriptor containing the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings and when read to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \n  \n-   If the variable being read into is an array, then the record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: 2 + 8 * NumberOfDimensions.  \n  \n     For example, the following array declaration requires 218 bytes when the array is written to disk:  \n  \n     [!code-vb[VbVbalrCatRef#27](~/add/codesnippet/visualbasic/16450c3e-87c4-4606-9e31-_1.vb)]  \n  \n     The 218 bytes are distributed as follows: 18 bytes for the descriptor (2 + 8 * 2), and 100 bytes for the data (5 \\* 10 \\* 4).  \n  \n-   `FileGetObject` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePutObject`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: 2 + 8 * NumberOfDimensions. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements, including any arrays and their descriptors. The <xref:Microsoft.VisualBasic.VBFixedStringAttribute> class can be applied to string fields in the structures to indicate the size of string when written to disk.  \n  \n## Binary Mode  \n For files opened in `Binary` mode, all of the `Random` rules apply, with these exceptions:  \n  \n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FileGetObject`reads all variables from disk contiguously, that is, with no padding between records.  \n  \n-   For any array other than an array in a structure, `FileGetObject` reads only the data. No descriptor is read.  \n  \n `FileGetObject` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.  \n  \n> [!IMPORTANT]\n>  When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file named Form1.vb may not be a Visual Basic source file."
  example:
  - "The following example reads a record into a test file and then retrieves it.  \n  \n [!code-vb[VbVbalrCatRef#26](~/add/codesnippet/visualbasic/16450c3e-87c4-4606-9e31-_2.vb)]"
  syntax:
    content: public static void FileGetObject (int FileNumber, ref object Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Kreves. Et gyldig tall."
    - id: Value
      type: System.Object
      description: "Kreves. Ugyldig variabelnavn som lese data."
    - id: RecordNumber
      type: System.Int64
      description: "Valgfritt. Postnummer (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> modus filer) eller byte tall (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> modus filer) på som lesing starter."
  overload: Microsoft.VisualBasic.FileSystem.FileGetObject*
  exceptions: []
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileLen(System.String)
  id: FileLen(System.String)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileLen(String)
  nameWithType: FileSystem.FileLen(String)
  fullName: Microsoft.VisualBasic.FileSystem.FileLen(String)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Returnerer en <xref uid=&quot;langword_csharp_Long&quot; name=&quot;Long&quot; href=&quot;&quot;> </xref> verdi som angir hvor lenge en fil i byte. Den <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funksjonen gir deg bedre produktivitet og ytelse i i/u-operasjoner enn <xref uid=&quot;langword_csharp_FileLen&quot; name=&quot;FileLen&quot; href=&quot;&quot;> </xref>. Hvis du vil ha mer informasjon, kan du se <xref:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo*>.</xref:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo*>"
  remarks: "Hvis den angitte filen er åpen når den `FileLen` funksjonen kalles, representerer den returnerte verdien størrelsen på filen da den ble åpnet.      > [!NOTE] > For å hente gjeldende lengden for en åpen fil, kan du bruke den `LOF` funksjonen."
  example:
  - "This example uses the `FileLen` function to return the length of a file in bytes. For purposes of this example, assume that `TestFile` is a file that contains some data.  \n  \n [!code-vb[VbVbalrCatRef#1](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._122_1.vb)]"
  syntax:
    content: public static long FileLen (string PathName);
    parameters:
    - id: PathName
      type: System.String
      description: "Kreves. <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;></xref>uttrykket som angir en fil. `PathName`kan inneholde mappen eller mappen og stasjonen."
    return:
      type: System.Int64
      description: "<xref uid=&quot;langword_csharp_Long&quot; name=&quot;Long&quot; href=&quot;&quot;></xref>verdi som angir hvor lenge en fil i byte."
  overload: Microsoft.VisualBasic.FileSystem.FileLen*
  exceptions:
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "Filen finnes ikke."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)
  id: FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileOpen(Int32,String,OpenMode,OpenAccess,OpenShare,Int32)
  nameWithType: FileSystem.FileOpen(Int32,String,OpenMode,OpenAccess,OpenShare,Int32)
  fullName: Microsoft.VisualBasic.FileSystem.FileOpen(Int32,String,OpenMode,OpenAccess,OpenShare,Int32)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Åpner en fil for inndata eller utdata. Den <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funksjonen gir deg bedre produktivitet og ytelse i i/u-operasjoner enn <xref uid=&quot;langword_csharp_FileOpen&quot; name=&quot;FileOpen&quot; href=&quot;&quot;> </xref>. Hvis du vil ha mer informasjon, se <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "Den `FileOpen` -funksjonen er angitt for bakoverkompatibilitet og kan påvirke ytelsen. For ikke-eldre applikasjoner i `My.Computer.FileSystem` objektet gir bedre ytelse. Hvis du vil ha mer informasjon, se [tilgang til filen med Visual Basic](~/add/includes/ajax-current-ext-md.md).       Før en i/u-operasjon kan utføres i den, må du åpne en fil. `FileOpen`tilordner en buffer for i/u til filen, og angir modusen for tilgang til bruk med bufferen.      > [!IMPORTANT] > Under skriving til en fil, et program har til å opprette en fil, hvis filen som forsøker å skrive ikke finnes. Hvis du vil gjøre dette, må det tillatelse for katalogen der filen er opprettes. Men hvis filen er angitt av `FileName` finnes programmet må `Write` tilgang bare til selve filen. Hvor mulig å forbedre sikkerheten, opprette filen under distribusjon og gi `Write` tilgang til filen bare, i stedet for til hele katalogen. For å forbedre sikkerheten, skrive data til brukeren mapper i stedet for rotmappen eller Programfiler.       Finner kanalen for å åpne ved hjelp av den `FreeFile()` funksjonen.      > [!IMPORTANT] > Den `FileOpen` funksjonen krever `Read` tilgang fra den `FileIOPermissionAccess` opplisting som kan påvirke kjøringen i delvis klarering situasjoner. Hvis du vil ha mer informasjon, se <xref:System.Security.Permissions.FileIOPermissionAccess>opplisting.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example illustrates various uses of the `FileOpen` function to enable input and output to a file.  \n  \n The following code opens the file `TestFile` in `Input` mode.  \n  \n [!code-vb[VbVbalrCatRef#5](~/add/codesnippet/visualbasic/ebe0f421-4483-4c55-8150-_1.vb)]  \n  \n This example opens the file in `Binary` mode for writing operations only.  \n  \n [!code-vb[VbVbalrCatRef#6](~/add/codesnippet/visualbasic/ebe0f421-4483-4c55-8150-_2.vb)]  \n  \n The following example opens the file in `Random` mode. The file contains records of the structure `Person`.  \n  \n [!code-vb[VbVbalrCatRef#7](~/add/codesnippet/visualbasic/ebe0f421-4483-4c55-8150-_3.vb)]  \n  \n This code example opens the file in `Output` mode; any process can read or write to file.  \n  \n [!code-vb[VbVbalrCatRef#8](~/add/codesnippet/visualbasic/ebe0f421-4483-4c55-8150-_4.vb)]  \n  \n This code example opens the file in `Binary` mode for reading; other processes cannot read file.  \n  \n [!code-vb[VbVbalrCatRef#9](~/add/codesnippet/visualbasic/ebe0f421-4483-4c55-8150-_5.vb)]"
  syntax:
    content: public static void FileOpen (int FileNumber, string FileName, Microsoft.VisualBasic.OpenMode Mode, Microsoft.VisualBasic.OpenAccess Access = Microsoft.VisualBasic.OpenAccess.Default, Microsoft.VisualBasic.OpenShare Share = Microsoft.VisualBasic.OpenShare.Default, int RecordLength = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Kreves. Et gyldig tall. Bruk av <xref uid=&quot;langword_csharp_FreeFile&quot; name=&quot;FreeFile&quot; href=&quot;&quot;> </xref> funksjonen til å hente neste tilgjengelige filnummer."
    - id: FileName
      type: System.String
      description: "Kreves. <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;></xref>uttrykket som angir et filnavn, kan inneholde katalog eller mappe, og stasjon."
    - id: Mode
      type: Microsoft.VisualBasic.OpenMode
      description: 'Kreves. Enumeration specifying the file mode: <xref uid=&quot;langword_csharp_Append&quot; name=&quot;Append&quot; href=&quot;&quot;></xref>, <xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;></xref>, <xref uid=&quot;langword_csharp_Input&quot; name=&quot;Input&quot; href=&quot;&quot;></xref>, <xref uid=&quot;langword_csharp_Output&quot; name=&quot;Output&quot; href=&quot;&quot;></xref>, or <xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;></xref>. Hvis du vil ha mer informasjon, se <xref href=&quot;Microsoft.VisualBasic.OpenMode&quot;> </xref> .'
    - id: Access
      type: Microsoft.VisualBasic.OpenAccess
      description: 'Valgfritt. Opplisting angir operasjonene tillatt for den åpne filen: <xref uid=&quot;langword_csharp_Read&quot; name=&quot;Read&quot; href=&quot;&quot;> </xref>, <xref uid=&quot;langword_csharp_Write&quot; name=&quot;Write&quot; href=&quot;&quot;> </xref>, eller <xref uid=&quot;langword_csharp_ReadWrite&quot; name=&quot;ReadWrite&quot; href=&quot;&quot;> </xref>. Som standard <xref uid=&quot;langword_csharp_ReadWrite&quot; name=&quot;ReadWrite&quot; href=&quot;&quot;> </xref>. Hvis du vil ha mer informasjon, se <xref href=&quot;Microsoft.VisualBasic.OpenAccess&quot;> </xref> .'
    - id: Share
      type: Microsoft.VisualBasic.OpenShare
      description: 'Valgfritt. Opplisting angir operasjoner som ikke er tillatt for den åpne filen av andre prosesser: <xref uid=&quot;langword_csharp_Shared&quot; name=&quot;Shared&quot; href=&quot;&quot;> </xref>, <xref uid=&quot;langword_csharp_Lock Read&quot; name=&quot;Lock Read&quot; href=&quot;&quot;> </xref>, <xref uid=&quot;langword_csharp_Lock Write&quot; name=&quot;Lock Write&quot; href=&quot;&quot;> </xref>, og <xref uid=&quot;langword_csharp_Lock Read Write&quot; name=&quot;Lock Read Write&quot; href=&quot;&quot;> </xref>. Som standard <xref uid=&quot;langword_csharp_Lock Read Write&quot; name=&quot;Lock Read Write&quot; href=&quot;&quot;> </xref>. Hvis du vil ha mer informasjon, se <xref href=&quot;Microsoft.VisualBasic.OpenShare&quot;> </xref> .'
    - id: RecordLength
      type: System.Int32
      description: "Valgfritt. Tall mindre enn eller lik 32 767 (byte). Denne verdien er postlengde for filer som er åpnet for RAM. Denne verdien er antallet tegn som er bufret for sekvensielle filer."
  overload: Microsoft.VisualBasic.FileSystem.FileOpen*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Postlengde er negativ (og ikke er lik -1)."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "<code>FileName</code>er allerede åpen, eller <code>FileName</code> er ugyldig."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Boolean,System.Int64)
  id: FilePut(System.Int32,System.Boolean,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FilePut(Int32,Boolean,Int64)
  nameWithType: FileSystem.FilePut(Int32,Boolean,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Boolean,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Skriver dataene fra en variabel til en fil. Den <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funksjonen gir deg bedre produktivitet og ytelse i i/u-operasjoner enn <xref uid=&quot;langword_csharp_FilePut&quot; name=&quot;FilePut&quot; href=&quot;&quot;> </xref>. Hvis du vil ha mer informasjon, se <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FilePut`er bare gyldig i `Random` og `Binary` modus.       Data som skrives med `FilePut` vanligvis lese fra en fil ved hjelp av `FileGet`.       Andre posten eller byte er i posisjon 2 og så videre første posten eller byte i en fil er i posisjon 1. Hvis du utelater `RecordNumber`, neste post eller byte når sist `FileGet` eller `FilePut` funksjonen eller henvises til i siste `Seek` funksjonen skrives.       Den `StringIsFixedLength` argumentet kontrollerer om funksjonen tolker strenger som variabel eller fast lengde. `FilePut`ikke Skriv lengden sikkerhetsbeskrivelse når argumentet er `True`. Hvis du bruker `StringIsFixedLength`  =  `True` med `FilePut`, må du gjøre det samme med `FileGet`, og at du har og kontroller at strengen initialiseres til lengden som forventet.      ## Tilfeldig modus For filer som er åpnet i `Random` modus, gjelder for følgende regler: - Hvis lengden på dataene som skrives er lavere enn lengden som er angitt i den `RecordLength` -setningsdelen i den `FileOpen` -funksjonen, `FilePut` skriver etterfølgende poster på postlengde grensene. Avstanden mellom slutten på én post og starten av den neste posten ut med det eksisterende innholdet i filen-bufferen. Det er vanligvis lurt å ha postlengde samsvarer med lengden på dataene som skrives fordi mengden utfylling data ikke kan fastslås med noen sikkerhet. Hvis lengden på dataene som skrives er større enn lengden som er angitt i den `RecordLength` -setningsdelen i `FileOpen`-funksjonen, vil bli utløst et unntak.      -Hvis variabelen skrives er en streng, `FilePut` skriver en beskrivelse for to byte som inneholder strenglengden, og deretter skriver data som skal settes inn variabelen. Derfor postlengde angitt av den `RecordLength` -setningsdel i den `FileOpen` funksjonen må være minst to byte større enn den faktiske lengden på strengen.      -Hvis variabelen skrives er et objekt som inneholder en numerisk type `FilePut` skriver to byte som identifiserer den `VarType` for objektet og skriver variabelen. For eksempel under skriving av et objekt som inneholder et heltall `FilePut` skrives seks: to byte som identifiserer objektet som `VarType(`3`)` (`Integer`) og fire byte som inneholder dataene. Postlengde som er angitt av den `RecordLength` parameter i den `FileOpen` funksjonen må være minst to byte større enn faktisk antall byte som kreves for å lagre variabelen.      -Hvis variabelen skrives er et objekt som inneholder en streng, `FilePut` skriver en to byte sikkerhetsbeskrivelse å identifisere den `VarType(`8`)` av objektet, og en beskrivelse for to byte som angir lengden på strengen, og skriver strengdata. Postlengde som er angitt av den `RecordLength` parameter i den `FileOpen` funksjonen må være minst fire byte større enn den faktiske lengden på strengen. Hvis du vil legge en streng uten beskrivelsen, må du sende `True` til den `StringIsFixedLength` parameteren og strengen du lese i må være riktig lengde.      -Hvis variabelen skrives er en matrise, har du et valg om å skrive en beskrivelse for størrelse og dimensjoner i matrisen eller ikke. Visual Basic 6.0 og tidligere versjoner skrive Filbeskrivelse for en dynamisk matrise, men ikke for en matrise med fast størrelse. Som standard ikke skriving av beskrivelsen Visual Basic 2005. For å skrive til beskrivelsen, kan du angi den `ArrayIsDynamic` parameter `True`. Når du skriver matrisen, må samsvare med måten matrisen blir lest; Hvis det skal leses med beskrivelsen, må du skrive beskrivelsen. Beskrivelsen angir rangeringen for matrisen, størrelse og nedre grense for hver rangeringen. De lengde lik 2 plus 8 ganger antallet dimensjoner: (2 + 8 * NumberOfDimensions). Postlengde som er angitt av den `RecordLength` -setningsdel i den `FileOpen` funksjonen må være større enn eller lik summen av alle byte som kreves for å skrive matrise dataene og beskrivelsen for matrise. Følgende matrise deklarasjon krever for eksempel 218 byte når matrisen er skrevet til disken.           [!code-vb[VbVbalrCatRef&#43;](~/add/codesnippet/visualbasic/b684b977-357d-4475-a2d0-_1.vb) ] - Hvis variabelen skrives er andre typer variabelen (ikke en variabel streng eller et objekt) `FilePut` skriver bare variabelen dataene. Postlengde som er angitt av den `RecordLength` -setningsdel i den `FileOpen` funksjonen må være større enn eller lik lengden på dataene som skrives.      - `FilePut` skriver elementer av strukturer som om hver ble skrevet enkeltvis, men det er ingen utfylling mellom elementene. Den `VBFixedString` attributtet kan brukes til streng feltene i strukturer som viser størrelsen på strengen ved å skrive til disken.          > [!NOTE] > Streng felt som har flere byte enn angitt i i `VBFixedString` attributtet er avkuttet under skriving til disk, ## binær modus For filer som er åpnet i `Binary` modus, de fleste av de `Random` modus regler gjelder, med noen unntak. Følgende regler for filer som åpnes i `Binary` modus er forskjellig fra regler for `Random` modus: - `RecordLength` -setningsdel i den `FileOpen` funksjonen har ingen virkning. `FilePut`skriver alle variabler på disken sammenhengende, det vil si uten utfylling mellom poster.      -For en matrise enn en matrise i en struktur `FilePut` skriver bare dataene. Ingen sikkerhetsbeskrivelse skrives.      - `FilePut` skriver variabelen strenger som ikke er elementer av strukturer uten to bytelengde sikkerhetsbeskrivelse. Antall byte skrevet er lik antallet tegn i strengen. For eksempel følgende setninger skrive 11 byte til filnummer 1: [!code-vb [VbVbalrCatRef #44](~/add/codesnippet/visualbasic/b684b977-357d-4475-a2d0-_2.vb) ] – skriving til filen ved hjelp av den `FilePut` funksjonen krever `Write` tilgang fra den <xref:System.Security.Permissions.FileIOPermissionAccess>opplisting.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `FilePut` function to write data to a file. Five records of the structure `Person` are written to the file.  \n  \n [!code-vb[VbVbalrCatRef#42](~/add/codesnippet/visualbasic/b684b977-357d-4475-a2d0-_3.vb)]"
  syntax:
    content: public static void FilePut (int FileNumber, bool Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Kreves. Et gyldig tall."
    - id: Value
      type: System.Boolean
      description: "Kreves. Ugyldig variabelnavn som inneholder data som skrives til disken."
    - id: RecordNumber
      type: System.Int64
      description: "Valgfritt. Postnummer (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> modus filer) eller byte tall (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> modus filer) på som skriving starter."
  overload: Microsoft.VisualBasic.FileSystem.FilePut*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 og ikke er lik -1."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Filen er ugyldig."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Byte,System.Int64)
  id: FilePut(System.Int32,System.Byte,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FilePut(Int32,Byte,Int64)
  nameWithType: FileSystem.FilePut(Int32,Byte,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Byte,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Skriver dataene fra en variabel til en fil. Den <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funksjonen gir deg bedre produktivitet og ytelse i i/u-operasjoner enn <xref uid=&quot;langword_csharp_FilePut&quot; name=&quot;FilePut&quot; href=&quot;&quot;> </xref>. Hvis du vil ha mer informasjon, se <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FilePut`er bare gyldig i `Random` og `Binary` modus.       Data som skrives med `FilePut` vanligvis lese fra en fil ved hjelp av `FileGet`.       Andre posten eller byte er i posisjon 2 og så videre første posten eller byte i en fil er i posisjon 1. Hvis du utelater `RecordNumber`, neste post eller byte når sist `FileGet` eller `FilePut` funksjonen eller henvises til i siste `Seek` funksjonen skrives.       Den `StringIsFixedLength` argumentet kontrollerer om funksjonen tolker strenger som variabel eller fast lengde. `FilePut`ikke Skriv lengden sikkerhetsbeskrivelse når argumentet er `True`. Hvis du bruker `StringIsFixedLength`  =  `True` med `FilePut`, må du gjøre det samme med `FileGet`, og at du har og kontroller at strengen initialiseres til lengden som forventet.      ## Tilfeldig modus For filer som er åpnet i `Random` modus, gjelder for følgende regler: - Hvis lengden på dataene som skrives er lavere enn lengden som er angitt i den `RecordLength` -setningsdelen i den `FileOpen` -funksjonen, `FilePut` skriver etterfølgende poster på postlengde grensene. Avstanden mellom slutten på én post og starten av den neste posten ut med det eksisterende innholdet i filen-bufferen. Det er vanligvis lurt å ha postlengde samsvarer med lengden på dataene som skrives fordi mengden utfylling data ikke kan fastslås med noen sikkerhet. Hvis lengden på dataene som skrives er større enn lengden som er angitt i den `RecordLength` -setningsdelen i `FileOpen` -funksjonen, vil bli utløst et unntak.      -Hvis variabelen skrives er en streng, `FilePut` skriver en beskrivelse for to byte som inneholder strenglengden, og deretter skriver data som skal settes inn variabelen. Derfor postlengde angitt av den `RecordLength` -setningsdel i den `FileOpen` funksjonen må være minst to byte større enn den faktiske lengden på strengen.      -Hvis variabelen skrives er et objekt som inneholder en numerisk type `FilePut` skriver to byte som identifiserer den `VarType` for objektet og skriver variabelen. For eksempel under skriving av et objekt som inneholder et heltall `FilePut` skrives seks: to byte som identifiserer objektet som `VarType(`3`)` (`Integer`) og fire byte som inneholder dataene. Postlengde som er angitt av den `RecordLength` parameter i den `FileOpen` funksjonen må være minst to byte større enn faktisk antall byte som kreves for å lagre variabelen.      -Hvis variabelen skrives er et objekt som inneholder en streng, `FilePut` skriver en to byte sikkerhetsbeskrivelse å identifisere den `VarType(`8`)` av objektet, og en beskrivelse for to byte som angir lengden på strengen, og skriver strengdata. Postlengde som er angitt av den `RecordLength` parameter i den `FileOpen` funksjonen må være minst fire byte større enn den faktiske lengden på strengen. Hvis du vil legge en streng uten beskrivelsen, må du sende `True` til den `StringIsFixedLength` parameteren og strengen du lese i må være riktig lengde.      -Hvis variabelen skrives er en matrise, har du et valg om å skrive en beskrivelse for størrelse og dimensjoner i matrisen eller ikke. Visual Basic 6.0 og tidligere versjoner skrive Filbeskrivelse for en dynamisk matrise, men ikke for en matrise med fast størrelse. Som standard ikke skriving av beskrivelsen Visual Basic 2005. For å skrive til beskrivelsen, kan du angi den `ArrayIsDynamic` parameter `True`. Når du skriver matrisen, må samsvare med måten matrisen blir lest; Hvis det skal leses med beskrivelsen, må du skrive beskrivelsen. Beskrivelsen angir rangeringen for matrisen, størrelse og nedre grense for hver rangeringen. De lengde lik 2 plus 8 ganger antallet dimensjoner: (2 + 8 * NumberOfDimensions). Postlengde som er angitt av den `RecordLength` -setningsdel i den `FileOpen` funksjonen må være større enn eller lik summen av alle byte som kreves for å skrive matrise dataene og beskrivelsen for matrise. Følgende matrise deklarasjon krever for eksempel 218 byte når matrisen er skrevet til disken.           [!code-vb[VbVbalrCatRef&#43;](~/add/codesnippet/visualbasic/2a393bee-4ca7-4317-bbe9-_1.vb) ] - Hvis variabelen skrives er andre typer variabelen (ikke en variabel streng eller et objekt) `FilePut` skriver bare variabelen dataene. Postlengde som er angitt av den `RecordLength` -setningsdel i den `FileOpen` funksjonen må være større enn eller lik lengden på dataene som skrives.      - `FilePut` skriver elementer av strukturer som om hver ble skrevet enkeltvis, men det er ingen utfylling mellom elementene. Den `VBFixedString` attributtet kan brukes til streng feltene i strukturer som viser størrelsen på strengen ved å skrive til disken.          > [!NOTE] > Streng felt som har flere byte enn angitt i i `VBFixedString` attributtet er avkuttet under skriving til disk, ## binær modus For filer som er åpnet i `Binary` modus, de fleste av de `Random` modus regler gjelder, med noen unntak. Følgende regler for filer som åpnes i `Binary` modus er forskjellig fra regler for `Random` modus: - `RecordLength` -setningsdel i den `FileOpen` funksjonen har ingen virkning. `FilePut`skriver alle variabler på disken sammenhengende, det vil si uten utfylling mellom poster.      -For en matrise enn en matrise i en struktur `FilePut` skriver bare dataene. Ingen sikkerhetsbeskrivelse skrives.      - `FilePut` skriver variabelen strenger som ikke er elementer av strukturer uten to bytelengde sikkerhetsbeskrivelse. Antall byte skrevet er lik antallet tegn i strengen. For eksempel følgende setninger skrive 11 byte til filnummer 1: [!code-vb [VbVbalrCatRef #44](~/add/codesnippet/visualbasic/2a393bee-4ca7-4317-bbe9-_2.vb) ] – skriving til filen ved hjelp av den `FilePut` funksjonen krever `Write` tilgang fra den <xref:System.Security.Permissions.FileIOPermissionAccess>opplisting.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `FilePut` function to write data to a file. Five records of the structure `Person` are written to the file.  \n  \n [!code-vb[VbVbalrCatRef#42](~/add/codesnippet/visualbasic/2a393bee-4ca7-4317-bbe9-_3.vb)]"
  syntax:
    content: public static void FilePut (int FileNumber, byte Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Kreves. Et gyldig tall."
    - id: Value
      type: System.Byte
      description: "Kreves. Ugyldig variabelnavn som inneholder data som skrives til disken."
    - id: RecordNumber
      type: System.Int64
      description: "Valgfritt. Postnummer (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> modus filer) eller byte tall (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> modus filer) på som skriving starter."
  overload: Microsoft.VisualBasic.FileSystem.FilePut*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 og ikke er lik -1."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Filen er ugyldig."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Char,System.Int64)
  id: FilePut(System.Int32,System.Char,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FilePut(Int32,Char,Int64)
  nameWithType: FileSystem.FilePut(Int32,Char,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Char,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Skriver dataene fra en variabel til en fil. Den <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funksjonen gir deg bedre produktivitet og ytelse i i/u-operasjoner enn <xref uid=&quot;langword_csharp_FilePut&quot; name=&quot;FilePut&quot; href=&quot;&quot;> </xref>. Hvis du vil ha mer informasjon, se <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FilePut`er bare gyldig i `Random` og `Binary` modus.       Data som skrives med `FilePut` vanligvis lese fra en fil ved hjelp av `FileGet`.       Andre posten eller byte er i posisjon 2 og så videre første posten eller byte i en fil er i posisjon 1. Hvis du utelater `RecordNumber`, neste post eller byte når sist `FileGet` eller `FilePut` funksjonen eller henvises til i siste `Seek` funksjonen skrives.       Den `StringIsFixedLength` argumentet kontrollerer om funksjonen tolker strenger som variabel eller fast lengde. `FilePut`ikke Skriv lengden sikkerhetsbeskrivelse når argumentet er `True`. Hvis du bruker `StringIsFixedLength`  =  `True` med `FilePut`, må du gjøre det samme med `FileGet`, og at du har og kontroller at strengen initialiseres til lengden som forventet.      ## Tilfeldig modus For filer som er åpnet i `Random` modus, gjelder for følgende regler: - Hvis lengden på dataene som skrives er lavere enn lengden som er angitt i den `RecordLength` -setningsdelen i den `FileOpen` -funksjonen, `FilePut` skriver etterfølgende poster på postlengde grensene. Avstanden mellom slutten på én post og starten av den neste posten ut med det eksisterende innholdet i filen-bufferen. Det er vanligvis lurt å ha postlengde samsvarer med lengden på dataene som skrives fordi mengden utfylling data ikke kan fastslås med noen sikkerhet. Hvis lengden på dataene som skrives er større enn lengden som er angitt i den `RecordLength` -setningsdelen i `FileOpen` -funksjonen, vil bli utløst et unntak.      -Hvis variabelen skrives er en streng, `FilePut` skriver en beskrivelse for to byte som inneholder strenglengden, og deretter skriver data som skal settes inn variabelen. Derfor postlengde angitt av den `RecordLength` -setningsdel i den `FileOpen` funksjonen må være minst to byte større enn den faktiske lengden på strengen.      -Hvis variabelen skrives er et objekt som inneholder en numerisk type `FilePut` skriver to byte som identifiserer den `VarType` for objektet og skriver variabelen. For eksempel under skriving av et objekt som inneholder et heltall `FilePut` skrives seks: to byte som identifiserer objektet som `VarType(`3`)` (`Integer`) og fire byte som inneholder dataene. Postlengde som er angitt av den `RecordLength` parameter i den `FileOpen` funksjonen må være minst to byte større enn faktisk antall byte som kreves for å lagre variabelen.      -Hvis variabelen skrives er et objekt som inneholder en streng, `FilePut` skriver en to byte sikkerhetsbeskrivelse å identifisere den `VarType(`8`)` av objektet, og en beskrivelse for to byte som angir lengden på strengen, og skriver strengdata. Postlengde som er angitt av den `RecordLength` parameter i den `FileOpen` funksjonen må være minst fire byte større enn den faktiske lengden på strengen. Hvis du vil legge en streng uten beskrivelsen, må du sende `True` til den `StringIsFixedLength` parameteren og strengen du lese i må være riktig lengde.      -Hvis variabelen skrives er en matrise, har du et valg om å skrive en beskrivelse for størrelse og dimensjoner i matrisen eller ikke. Visual Basic 6.0 og tidligere versjoner skrive Filbeskrivelse for en dynamisk matrise, men ikke for en matrise med fast størrelse. Som standard ikke skriving av beskrivelsen Visual Basic 2005. For å skrive til beskrivelsen, kan du angi den `ArrayIsDynamic` parameter `True`. Når du skriver matrisen, må samsvare med måten matrisen blir lest; Hvis det skal leses med beskrivelsen, må du skrive beskrivelsen. Beskrivelsen angir rangeringen for matrisen, størrelse og nedre grense for hver rangeringen. De lengde lik 2 plus 8 ganger antallet dimensjoner: (2 + 8 * NumberOfDimensions). Postlengde som er angitt av den `RecordLength` -setningsdel i den `FileOpen` funksjonen må være større enn eller lik summen av alle byte som kreves for å skrive matrise dataene og beskrivelsen for matrise. Følgende matrise deklarasjon krever for eksempel 218 byte når matrisen er skrevet til disken.           [!code-vb[VbVbalrCatRef&#43;](~/add/codesnippet/visualbasic/f7dbd668-3841-4860-9fe2-_1.vb) ] - Hvis variabelen skrives er andre typer variabelen (ikke en variabel streng eller et objekt) `FilePut` skriver bare variabelen dataene. Postlengde som er angitt av den `RecordLength` -setningsdel i den `FileOpen` funksjonen må være større enn eller lik lengden på dataene som skrives.      - `FilePut` skriver elementer av strukturer som om hver ble skrevet enkeltvis, men det er ingen utfylling mellom elementene. Den `VBFixedString` attributtet kan brukes til streng feltene i strukturer som viser størrelsen på strengen ved å skrive til disken.          > [!NOTE] > Streng felt som har flere byte enn angitt i i `VBFixedString` attributtet er avkuttet under skriving til disk, ## binær modus For filer som er åpnet i `Binary` modus, de fleste av de `Random` modus regler gjelder, med noen unntak. Følgende regler for filer som åpnes i `Binary` modus er forskjellig fra regler for `Random` modus: - `RecordLength` -setningsdel i den `FileOpen` funksjonen har ingen virkning. `FilePut`skriver alle variabler på disken sammenhengende, det vil si uten utfylling mellom poster.      -For en matrise enn en matrise i en struktur `FilePut` skriver bare dataene. Ingen sikkerhetsbeskrivelse skrives.      - `FilePut` skriver variabelen strenger som ikke er elementer av strukturer uten to bytelengde sikkerhetsbeskrivelse. Antall byte skrevet er lik antallet tegn i strengen. For eksempel følgende setninger skrive 11 byte til filnummer 1: [!code-vb [VbVbalrCatRef #44](~/add/codesnippet/visualbasic/f7dbd668-3841-4860-9fe2-_2.vb) ] – skriving til filen ved hjelp av den `FilePut` funksjonen krever `Write` tilgang fra den <xref:System.Security.Permissions.FileIOPermissionAccess>opplisting.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `FilePut` function to write data to a file. Five records of the structure `Person` are written to the file.  \n  \n [!code-vb[VbVbalrCatRef#42](~/add/codesnippet/visualbasic/f7dbd668-3841-4860-9fe2-_3.vb)]"
  syntax:
    content: public static void FilePut (int FileNumber, char Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Kreves. Et gyldig tall."
    - id: Value
      type: System.Char
      description: "Kreves. Ugyldig variabelnavn som inneholder data som skrives til disken."
    - id: RecordNumber
      type: System.Int64
      description: "Valgfritt. Postnummer (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> modus filer) eller byte tall (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> modus filer) på som skriving starter."
  overload: Microsoft.VisualBasic.FileSystem.FilePut*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 og ikke er lik -1."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Filen er ugyldig."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.DateTime,System.Int64)
  id: FilePut(System.Int32,System.DateTime,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FilePut(Int32,DateTime,Int64)
  nameWithType: FileSystem.FilePut(Int32,DateTime,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,DateTime,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Skriver dataene fra en variabel til en fil. Den <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funksjonen gir deg bedre produktivitet og ytelse i i/u-operasjoner enn <xref uid=&quot;langword_csharp_FilePut&quot; name=&quot;FilePut&quot; href=&quot;&quot;> </xref>. Hvis du vil ha mer informasjon, se <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FilePut`er bare gyldig i `Random` og `Binary` modus.       Data som skrives med `FilePut` vanligvis lese fra en fil ved hjelp av `FileGet`.       Andre posten eller byte er i posisjon 2 og så videre første posten eller byte i en fil er i posisjon 1. Hvis du utelater `RecordNumber`, neste post eller byte når sist `FileGet` eller `FilePut` funksjonen eller henvises til i siste `Seek` funksjonen skrives.       Den `StringIsFixedLength` argumentet kontrollerer om funksjonen tolker strenger som variabel eller fast lengde. `FilePut`ikke Skriv lengden sikkerhetsbeskrivelse når argumentet er `True`. Hvis du bruker `StringIsFixedLength`  =  `True` med `FilePut`, må du gjøre det samme med `FileGet`, og at du har og kontroller at strengen initialiseres til lengden som forventet.      ## Tilfeldig modus For filer som er åpnet i `Random` modus, gjelder for følgende regler: - Hvis lengden på dataene som skrives er lavere enn lengden som er angitt i den `RecordLength` -setningsdelen i den `FileOpen` -funksjonen, `FilePut` skriver etterfølgende poster på postlengde grensene. Avstanden mellom slutten på én post og starten av den neste posten ut med det eksisterende innholdet i filen-bufferen. Det er vanligvis lurt å ha postlengde samsvarer med lengden på dataene som skrives fordi mengden utfylling data ikke kan fastslås med noen sikkerhet. Hvis lengden på dataene som skrives er større enn lengden som er angitt i den `RecordLength` -setningsdelen i `FileOpen` -funksjonen, vil bli utløst et unntak.      -Hvis variabelen skrives er en streng, `FilePut` skriver en beskrivelse for to byte som inneholder strenglengden, og deretter skriver data som skal settes inn variabelen. Derfor postlengde angitt av den `RecordLength` -setningsdel i den `FileOpen` funksjonen må være minst to byte større enn den faktiske lengden på strengen.      -Hvis variabelen skrives er et objekt som inneholder en numerisk type `FilePut` skriver to byte som identifiserer den `VarType` for objektet og skriver variabelen. For eksempel under skriving av et objekt som inneholder et heltall `FilePut` skrives seks: to byte som identifiserer objektet som `VarType(`3`)` (`Integer`) og fire byte som inneholder dataene. Postlengde som er angitt av den `RecordLength` parameter i den `FileOpen` funksjonen må være minst to byte større enn faktisk antall byte som kreves for å lagre variabelen.      -Hvis variabelen skrives er et objekt som inneholder en streng, `FilePut` skriver en to byte sikkerhetsbeskrivelse å identifisere den `VarType(`8`)` av objektet, og en beskrivelse for to byte som angir lengden på strengen, og skriver strengdata. Postlengde som er angitt av den `RecordLength` parameter i den `FileOpen` funksjonen må være minst fire byte større enn den faktiske lengden på strengen. Hvis du vil legge en streng uten beskrivelsen, må du sende `True` til den `StringIsFixedLength` parameteren og strengen du lese i må være riktig lengde.      -Hvis variabelen skrives er en matrise, har du et valg om å skrive en beskrivelse for størrelse og dimensjoner i matrisen eller ikke. Visual Basic 6.0 og tidligere versjoner skrive Filbeskrivelse for en dynamisk matrise, men ikke for en matrise med fast størrelse. Som standard ikke skriving av beskrivelsen Visual Basic 2005. For å skrive til beskrivelsen, kan du angi den `ArrayIsDynamic` parameter `True`. Når du skriver matrisen, må samsvare med måten matrisen blir lest; Hvis det skal leses med beskrivelsen, må du skrive beskrivelsen. Beskrivelsen angir rangeringen for matrisen, størrelse og nedre grense for hver rangeringen. De lengde lik 2 plus 8 ganger antallet dimensjoner: (2 + 8 * NumberOfDimensions). Postlengde som er angitt av den `RecordLength` -setningsdel i den `FileOpen` funksjonen må være større enn eller lik summen av alle byte som kreves for å skrive matrise dataene og beskrivelsen for matrise. Følgende matrise deklarasjon krever for eksempel 218 byte når matrisen er skrevet til disken.           [!code-vb[VbVbalrCatRef&#43;](~/add/codesnippet/visualbasic/30fdf8e5-a84c-499e-8f20-_1.vb) ] - Hvis variabelen skrives er andre typer variabelen (ikke en variabel streng eller et objekt) `FilePut` skriver bare variabelen dataene. Postlengde som er angitt av den `RecordLength` -setningsdel i den `FileOpen` funksjonen må være større enn eller lik lengden på dataene som skrives.      - `FilePut` skriver elementer av strukturer som om hver ble skrevet enkeltvis, men det er ingen utfylling mellom elementene. Den `VBFixedString` attributtet kan brukes til streng feltene i strukturer som viser størrelsen på strengen ved å skrive til disken.          > [!NOTE] > Streng felt som har flere byte enn angitt i i `VBFixedString` attributtet er avkuttet under skriving til disk, ## binær modus For filer som er åpnet i `Binary` modus, de fleste av de `Random` modus regler gjelder, med noen unntak. Følgende regler for filer som åpnes i `Binary` modus er forskjellig fra regler for `Random` modus: - `RecordLength` -setningsdel i den `FileOpen` funksjonen har ingen virkning. `FilePut`skriver alle variabler på disken sammenhengende, det vil si uten utfylling mellom poster.      -For en matrise enn en matrise i en struktur `FilePut` skriver bare dataene. Ingen sikkerhetsbeskrivelse skrives.      - `FilePut` skriver variabelen strenger som ikke er elementer av strukturer uten to bytelengde sikkerhetsbeskrivelse. Antall byte skrevet er lik antallet tegn i strengen. For eksempel følgende setninger skrive 11 byte til filnummer 1: [!code-vb [VbVbalrCatRef #44](~/add/codesnippet/visualbasic/30fdf8e5-a84c-499e-8f20-_2.vb) ] – skriving til filen ved hjelp av den `FilePut` funksjonen krever `Write` tilgang fra den <xref:System.Security.Permissions.FileIOPermissionAccess>opplisting.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `FilePut` function to write data to a file. Five records of the structure `Person` are written to the file.  \n  \n [!code-vb[VbVbalrCatRef#42](~/add/codesnippet/visualbasic/30fdf8e5-a84c-499e-8f20-_3.vb)]"
  syntax:
    content: public static void FilePut (int FileNumber, DateTime Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Kreves. Et gyldig tall."
    - id: Value
      type: System.DateTime
      description: "Kreves. Ugyldig variabelnavn som inneholder data som skrives til disken."
    - id: RecordNumber
      type: System.Int64
      description: "Valgfritt. Postnummer (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> modus filer) eller byte tall (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> modus filer) på som skriving starter."
  overload: Microsoft.VisualBasic.FileSystem.FilePut*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 og ikke er lik -1."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Filen er ugyldig."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Decimal,System.Int64)
  id: FilePut(System.Int32,System.Decimal,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FilePut(Int32,Decimal,Int64)
  nameWithType: FileSystem.FilePut(Int32,Decimal,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Decimal,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Skriver dataene fra en variabel til en fil. Den <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funksjonen gir deg bedre produktivitet og ytelse i i/u-operasjoner enn <xref uid=&quot;langword_csharp_FilePut&quot; name=&quot;FilePut&quot; href=&quot;&quot;> </xref>. Hvis du vil ha mer informasjon, se <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FilePut`er bare gyldig i `Random` og `Binary` modus.       Data som skrives med `FilePut` vanligvis lese fra en fil ved hjelp av `FileGet`.       Andre posten eller byte er i posisjon 2 og så videre første posten eller byte i en fil er i posisjon 1. Hvis du utelater `RecordNumber`, neste post eller byte når sist `FileGet` eller `FilePut` funksjonen eller henvises til i siste `Seek` funksjonen skrives.       Den `StringIsFixedLength` argumentet kontrollerer om funksjonen tolker strenger som variabel eller fast lengde. `FilePut`ikke Skriv lengden sikkerhetsbeskrivelse når argumentet er `True`. Hvis du bruker `StringIsFixedLength`  =  `True` med `FilePut`, må du gjøre det samme med `FileGet`, og at du har og kontroller at strengen initialiseres til lengden som forventet.      ## Tilfeldig modus For filer som er åpnet i `Random` modus, gjelder for følgende regler: - Hvis lengden på dataene som skrives er lavere enn lengden som er angitt i den `RecordLength` -setningsdelen i den `FileOpen` -funksjonen, `FilePut` skriver etterfølgende poster på postlengde grensene. Avstanden mellom slutten på én post og starten av den neste posten ut med det eksisterende innholdet i filen-bufferen. Det er vanligvis lurt å ha postlengde samsvarer med lengden på dataene som skrives fordi mengden utfylling data ikke kan fastslås med noen sikkerhet. Hvis lengden på dataene som skrives er større enn lengden som er angitt i den `RecordLength` -setningsdelen i `FileOpen` -funksjonen, vil bli utløst et unntak.      -Hvis variabelen skrives er en streng, `FilePut` skriver en beskrivelse for to byte som inneholder strenglengden, og deretter skriver data som skal settes inn variabelen. Derfor postlengde angitt av den `RecordLength` -setningsdel i den `FileOpen` funksjonen må være minst to byte større enn den faktiske lengden på strengen.      -Hvis variabelen skrives er et objekt som inneholder en numerisk type `FilePut` skriver to byte som identifiserer den `VarType` for objektet og skriver variabelen. For eksempel under skriving av et objekt som inneholder et heltall `FilePut` skrives seks: to byte som identifiserer objektet som `VarType(`3`)` (`Integer`) og fire byte som inneholder dataene. Postlengde som er angitt av den `RecordLength` parameter i den `FileOpen` funksjonen må være minst to byte større enn faktisk antall byte som kreves for å lagre variabelen.      -Hvis variabelen skrives er et objekt som inneholder en streng, `FilePut` skriver en to byte sikkerhetsbeskrivelse å identifisere den `VarType(`8`)` av objektet, og en beskrivelse for to byte som angir lengden på strengen, og skriver strengdata. Postlengde som er angitt av den `RecordLength` parameter i den `FileOpen` funksjonen må være minst fire byte større enn den faktiske lengden på strengen. Hvis du vil legge en streng uten beskrivelsen, må du sende `True` til den `StringIsFixedLength` parameteren og strengen du lese i må være riktig lengde.      -Hvis variabelen skrives er en matrise, har du et valg om å skrive en beskrivelse for størrelse og dimensjoner i matrisen eller ikke. Visual Basic 6.0 og tidligere versjoner skrive Filbeskrivelse for en dynamisk matrise, men ikke for en matrise med fast størrelse. Som standard ikke skriving av beskrivelsen Visual Basic 2005. For å skrive til beskrivelsen, kan du angi den `ArrayIsDynamic` parameter `True`. Når du skriver matrisen, må samsvare med måten matrisen blir lest; Hvis det skal leses med beskrivelsen, må du skrive beskrivelsen. Beskrivelsen angir rangeringen for matrisen, størrelse og nedre grense for hver rangeringen. De lengde lik 2 plus 8 ganger antallet dimensjoner: (2 + 8 * NumberOfDimensions). Postlengde som er angitt av den `RecordLength` -setningsdel i den `FileOpen` funksjonen må være større enn eller lik summen av alle byte som kreves for å skrive matrise dataene og beskrivelsen for matrise. Følgende matrise deklarasjon krever for eksempel 218 byte når matrisen er skrevet til disken.           [!code-vb[VbVbalrCatRef&#43;](~/add/codesnippet/visualbasic/9cb41843-0b02-4bad-b757-_1.vb) ] - Hvis variabelen skrives er andre typer variabelen (ikke en variabel streng eller et objekt) `FilePut` skriver bare variabelen dataene. Postlengde som er angitt av den `RecordLength` -setningsdel i den `FileOpen` funksjonen må være større enn eller lik lengden på dataene som skrives.      - `FilePut` skriver elementer av strukturer som om hver ble skrevet enkeltvis, men det er ingen utfylling mellom elementene. Den `VBFixedString` attributtet kan brukes til streng feltene i strukturer som viser størrelsen på strengen ved å skrive til disken.          > [!NOTE] > Streng felt som har flere byte enn angitt i i `VBFixedString` attributtet er avkuttet under skriving til disk, ## binær modus For filer som er åpnet i `Binary` modus, de fleste av de `Random` modus regler gjelder, med noen unntak. Følgende regler for filer som åpnes i `Binary` modus er forskjellig fra regler for `Random` modus: - `RecordLength` -setningsdel i den `FileOpen` funksjonen har ingen virkning. `FilePut`skriver alle variabler på disken sammenhengende, det vil si uten utfylling mellom poster.      -For en matrise enn en matrise i en struktur `FilePut` skriver bare dataene. Ingen sikkerhetsbeskrivelse skrives.      - `FilePut` skriver variabelen strenger som ikke er elementer av strukturer uten to bytelengde sikkerhetsbeskrivelse. Antall byte skrevet er lik antallet tegn i strengen. For eksempel følgende setninger skrive 11 byte til filnummer 1: [!code-vb [VbVbalrCatRef #44](~/add/codesnippet/visualbasic/9cb41843-0b02-4bad-b757-_2.vb) ] – skriving til filen ved hjelp av den `FilePut` funksjonen krever `Write` tilgang fra den <xref:System.Security.Permissions.FileIOPermissionAccess>opplisting.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `FilePut` function to write data to a file. Five records of the structure `Person` are written to the file.  \n  \n [!code-vb[VbVbalrCatRef#42](~/add/codesnippet/visualbasic/9cb41843-0b02-4bad-b757-_3.vb)]"
  syntax:
    content: public static void FilePut (int FileNumber, decimal Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Kreves. Et gyldig tall."
    - id: Value
      type: System.Decimal
      description: "Kreves. Ugyldig variabelnavn som inneholder data som skrives til disken."
    - id: RecordNumber
      type: System.Int64
      description: "Valgfritt. Postnummer (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> modus filer) eller byte tall (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> modus filer) på som skriving starter."
  overload: Microsoft.VisualBasic.FileSystem.FilePut*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 og ikke er lik -1."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Filen er ugyldig."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Double,System.Int64)
  id: FilePut(System.Int32,System.Double,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FilePut(Int32,Double,Int64)
  nameWithType: FileSystem.FilePut(Int32,Double,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Double,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Skriver dataene fra en variabel til en fil. Den <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funksjonen gir deg bedre produktivitet og ytelse i i/u-operasjoner enn <xref uid=&quot;langword_csharp_FilePut&quot; name=&quot;FilePut&quot; href=&quot;&quot;> </xref>. Hvis du vil ha mer informasjon, se <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FilePut`er bare gyldig i `Random` og `Binary` modus.       Data som skrives med `FilePut` vanligvis lese fra en fil ved hjelp av `FileGet`.       Andre posten eller byte er i posisjon 2 og så videre første posten eller byte i en fil er i posisjon 1. Hvis du utelater `RecordNumber`, neste post eller byte når sist `FileGet` eller `FilePut` funksjonen eller henvises til i siste `Seek` funksjonen skrives.       Den `StringIsFixedLength` argumentet kontrollerer om funksjonen tolker strenger som variabel eller fast lengde. `FilePut`ikke Skriv lengden sikkerhetsbeskrivelse når argumentet er `True`. Hvis du bruker `StringIsFixedLength`  =  `True` med `FilePut`, må du gjøre det samme med `FileGet`, og at du har og kontroller at strengen initialiseres til lengden som forventet.      ## Tilfeldig modus For filer som er åpnet i `Random` modus, gjelder for følgende regler: - Hvis lengden på dataene som skrives er lavere enn lengden som er angitt i den `RecordLength` -setningsdelen i den `FileOpen` -funksjonen, `FilePut` skriver etterfølgende poster på postlengde grensene. Avstanden mellom slutten på én post og starten av den neste posten ut med det eksisterende innholdet i filen-bufferen. Det er vanligvis lurt å ha postlengde samsvarer med lengden på dataene som skrives fordi mengden utfylling data ikke kan fastslås med noen sikkerhet. Hvis lengden på dataene som skrives er større enn lengden som er angitt i den `RecordLength` -setningsdelen i `FileOpen` -funksjonen, vil bli utløst et unntak.      -Hvis variabelen skrives er en streng, `FilePut` skriver en beskrivelse for to byte som inneholder strenglengden, og deretter skriver data som skal settes inn variabelen. Derfor postlengde angitt av den `RecordLength` -setningsdel i den `FileOpen` funksjonen må være minst to byte større enn den faktiske lengden på strengen.      -Hvis variabelen skrives er et objekt som inneholder en numerisk type `FilePut` skriver to byte som identifiserer den `VarType` for objektet og skriver variabelen. For eksempel under skriving av et objekt som inneholder et heltall `FilePut` skrives seks: to byte som identifiserer objektet som `VarType(`3`)` (`Integer`) og fire byte som inneholder dataene. Postlengde som er angitt av den `RecordLength` parameter i den `FileOpen` funksjonen må være minst to byte større enn faktisk antall byte som kreves for å lagre variabelen.      -Hvis variabelen skrives er et objekt som inneholder en streng, `FilePut` skriver en to byte sikkerhetsbeskrivelse å identifisere den `VarType(`8`)` av objektet, og en beskrivelse for to byte som angir lengden på strengen, og skriver strengdata. Postlengde som er angitt av den `RecordLength` parameter i den `FileOpen` funksjonen må være minst fire byte større enn den faktiske lengden på strengen. Hvis du vil legge en streng uten beskrivelsen, må du sende `True` til den `StringIsFixedLength` parameteren og strengen du lese i må være riktig lengde.      -Hvis variabelen skrives er en matrise, har du et valg om å skrive en beskrivelse for størrelse og dimensjoner i matrisen eller ikke. Visual Basic 6.0 og tidligere versjoner skrive Filbeskrivelse for en dynamisk matrise, men ikke for en matrise med fast størrelse. Som standard ikke skriving av beskrivelsen Visual Basic 2005. For å skrive til beskrivelsen, kan du angi den `ArrayIsDynamic` parameter `True`. Når du skriver matrisen, må samsvare med måten matrisen blir lest; Hvis det skal leses med beskrivelsen, må du skrive beskrivelsen. Beskrivelsen angir rangeringen for matrisen, størrelse og nedre grense for hver rangeringen. De lengde lik 2 plus 8 ganger antallet dimensjoner: (2 + 8 * NumberOfDimensions). Postlengde som er angitt av den `RecordLength` -setningsdel i den `FileOpen` funksjonen må være større enn eller lik summen av alle byte som kreves for å skrive matrise dataene og beskrivelsen for matrise. Følgende matrise deklarasjon krever for eksempel 218 byte når matrisen er skrevet til disken.           [!code-vb[VbVbalrCatRef&#43;](~/add/codesnippet/visualbasic/59c5b768-6732-40e5-a205-_1.vb) ] - Hvis variabelen skrives er andre typer variabelen (ikke en variabel streng eller et objekt) `FilePut` skriver bare variabelen dataene. Postlengde som er angitt av den `RecordLength` -setningsdel i den `FileOpen` funksjonen må være større enn eller lik lengden på dataene som skrives.      - `FilePut` skriver elementer av strukturer som om hver ble skrevet enkeltvis, men det er ingen utfylling mellom elementene. Den `VBFixedString` attributtet kan brukes til streng feltene i strukturer som viser størrelsen på strengen ved å skrive til disken.          > [!NOTE] > Streng felt som har flere byte enn angitt i i `VBFixedString` attributtet er avkuttet under skriving til disk, ## binær modus For filer som er åpnet i `Binary` modus, de fleste av de `Random` modus regler gjelder, med noen unntak. Følgende regler for filer som åpnes i `Binary` modus er forskjellig fra regler for `Random` modus: - `RecordLength` -setningsdel i den `FileOpen` funksjonen har ingen virkning. `FilePut`skriver alle variabler på disken sammenhengende, det vil si uten utfylling mellom poster.      -For en matrise enn en matrise i en struktur `FilePut` skriver bare dataene. Ingen sikkerhetsbeskrivelse skrives.      - `FilePut` skriver variabelen strenger som ikke er elementer av strukturer uten to bytelengde sikkerhetsbeskrivelse. Antall byte skrevet er lik antallet tegn i strengen. For eksempel følgende setninger skrive 11 byte til filnummer 1: [!code-vb [VbVbalrCatRef #44](~/add/codesnippet/visualbasic/59c5b768-6732-40e5-a205-_2.vb) ] – skriving til filen ved hjelp av den `FilePut` funksjonen krever `Write` tilgang fra den <xref:System.Security.Permissions.FileIOPermissionAccess>opplisting.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `FilePut` function to write data to a file. Five records of the structure `Person` are written to the file.  \n  \n [!code-vb[VbVbalrCatRef#42](~/add/codesnippet/visualbasic/59c5b768-6732-40e5-a205-_3.vb)]"
  syntax:
    content: public static void FilePut (int FileNumber, double Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Kreves. Et gyldig tall."
    - id: Value
      type: System.Double
      description: "Kreves. Ugyldig variabelnavn som inneholder data som skrives til disken."
    - id: RecordNumber
      type: System.Int64
      description: "Valgfritt. Postnummer (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> modus filer) eller byte tall (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> modus filer) på som skriving starter."
  overload: Microsoft.VisualBasic.FileSystem.FilePut*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 og ikke er lik -1."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Filen er ugyldig."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int16,System.Int64)
  id: FilePut(System.Int32,System.Int16,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FilePut(Int32,Int16,Int64)
  nameWithType: FileSystem.FilePut(Int32,Int16,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Int16,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Skriver dataene fra en variabel til en fil. Den <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funksjonen gir deg bedre produktivitet og ytelse i i/u-operasjoner enn <xref uid=&quot;langword_csharp_FilePut&quot; name=&quot;FilePut&quot; href=&quot;&quot;> </xref>. Hvis du vil ha mer informasjon, se <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FilePut`er bare gyldig i `Random` og `Binary` modus.       Data som skrives med `FilePut` vanligvis lese fra en fil ved hjelp av `FileGet`.       Andre posten eller byte er i posisjon 2 og så videre første posten eller byte i en fil er i posisjon 1. Hvis du utelater `RecordNumber`, neste post eller byte når sist `FileGet` eller `FilePut` funksjonen eller henvises til i siste `Seek` funksjonen skrives.       Den `StringIsFixedLength` argumentet kontrollerer om funksjonen tolker strenger som variabel eller fast lengde. `FilePut`ikke Skriv lengden sikkerhetsbeskrivelse når argumentet er `True`. Hvis du bruker `StringIsFixedLength`  =  `True` med `FilePut`, må du gjøre det samme med `FileGet`, og at du har og kontroller at strengen initialiseres til lengden som forventet.      ## Tilfeldig modus For filer som er åpnet i `Random` modus, gjelder for følgende regler: - Hvis lengden på dataene som skrives er lavere enn lengden som er angitt i den `RecordLength` -setningsdelen i den `FileOpen` -funksjonen, `FilePut` skriver etterfølgende poster på postlengde grensene. Avstanden mellom slutten på én post og starten av den neste posten ut med det eksisterende innholdet i filen-bufferen. Det er vanligvis lurt å ha postlengde samsvarer med lengden på dataene som skrives fordi mengden utfylling data ikke kan fastslås med noen sikkerhet. Hvis lengden på dataene som skrives er større enn lengden som er angitt i den `RecordLength` -setningsdelen i `FileOpen` -funksjonen, vil bli utløst et unntak.      -Hvis variabelen skrives er en streng, `FilePut` skriver en beskrivelse for to byte som inneholder strenglengden, og deretter skriver data som skal settes inn variabelen. Derfor postlengde angitt av den `RecordLength` -setningsdel i den `FileOpen` funksjonen må være minst to byte større enn den faktiske lengden på strengen.      -Hvis variabelen skrives er et objekt som inneholder en numerisk type `FilePut` skriver to byte som identifiserer den `VarType` for objektet og skriver variabelen. For eksempel under skriving av et objekt som inneholder et heltall `FilePut` skrives seks: to byte som identifiserer objektet som `VarType(`3`)` (`Integer`) og fire byte som inneholder dataene. Postlengde som er angitt av den `RecordLength` parameter i den `FileOpen` funksjonen må være minst to byte større enn faktisk antall byte som kreves for å lagre variabelen.      -Hvis variabelen skrives er et objekt som inneholder en streng, `FilePut` skriver en to byte sikkerhetsbeskrivelse å identifisere den`VarType(`8`)` av objektet, og en beskrivelse for to byte som angir lengden på strengen, og skriver strengdata. Postlengde som er angitt av den `RecordLength` parameter i den `FileOpen` funksjonen må være minst fire byte større enn den faktiske lengden på strengen. Hvis du vil legge en streng uten beskrivelsen, må du sende `True` til den `StringIsFixedLength` parameteren og strengen du lese i må være riktig lengde.      -Hvis variabelen skrives er en matrise, har du et valg om å skrive en beskrivelse for størrelse og dimensjoner i matrisen eller ikke. Visual Basic 6.0 og tidligere versjoner skrive Filbeskrivelse for en dynamisk matrise, men ikke for en matrise med fast størrelse. Som standard ikke skriving av beskrivelsen Visual Basic 2005. For å skrive til beskrivelsen, kan du angi den `ArrayIsDynamic` parameter `True`. Når du skriver matrisen, må samsvare med måten matrisen blir lest; Hvis det skal leses med beskrivelsen, må du skrive beskrivelsen. Beskrivelsen angir rangeringen for matrisen, størrelse og nedre grense for hver rangeringen. De lengde lik 2 plus 8 ganger antallet dimensjoner: (2 + 8 * NumberOfDimensions). Postlengde som er angitt av den `RecordLength` -setningsdel i den `FileOpen` funksjonen må være større enn eller lik summen av alle byte som kreves for å skrive matrise dataene og beskrivelsen for matrise. Følgende matrise deklarasjon krever for eksempel 218 byte når matrisen er skrevet til disken.           [!code-vb[VbVbalrCatRef&#43;](~/add/codesnippet/visualbasic/835229db-b7e7-4e50-86a7-_1.vb) ] - Hvis variabelen skrives er andre typer variabelen (ikke en variabel streng eller et objekt) `FilePut` skriver bare variabelen dataene. Postlengde som er angitt av den `RecordLength` -setningsdel i den `FileOpen` funksjonen må være større enn eller lik lengden på dataene som skrives.      - `FilePut` skriver elementer av strukturer som om hver ble skrevet enkeltvis, men det er ingen utfylling mellom elementene. Den `VBFixedString` attributtet kan brukes til streng feltene i strukturer som viser størrelsen på strengen ved å skrive til disken.          > [!NOTE] > Streng felt som har flere byte enn angitt i i `VBFixedString` attributtet er avkuttet under skriving til disk, ## binær modus For filer som er åpnet i `Binary` modus, de fleste av de `Random` modus regler gjelder, med noen unntak. Følgende regler for filer som åpnes i `Binary` modus er forskjellig fra regler for `Random` modus: - `RecordLength` -setningsdel i den `FileOpen` funksjonen har ingen virkning. `FilePut`skriver alle variabler på disken sammenhengende, det vil si uten utfylling mellom poster.      -For en matrise enn en matrise i en struktur `FilePut` skriver bare dataene. Ingen sikkerhetsbeskrivelse skrives.      - `FilePut` skriver variabelen strenger som ikke er elementer av strukturer uten to bytelengde sikkerhetsbeskrivelse. Antall byte skrevet er lik antallet tegn i strengen. For eksempel følgende setninger skrive 11 byte til filnummer 1: [!code-vb [VbVbalrCatRef #44](~/add/codesnippet/visualbasic/835229db-b7e7-4e50-86a7-_2.vb) ] – skriving til filen ved hjelp av den `FilePut` funksjonen krever `Write` tilgang fra den <xref:System.Security.Permissions.FileIOPermissionAccess>opplisting.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `FilePut` function to write data to a file. Five records of the structure `Person` are written to the file.  \n  \n [!code-vb[VbVbalrCatRef#42](~/add/codesnippet/visualbasic/835229db-b7e7-4e50-86a7-_3.vb)]"
  syntax:
    content: public static void FilePut (int FileNumber, short Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Kreves. Et gyldig tall."
    - id: Value
      type: System.Int16
      description: "Kreves. Ugyldig variabelnavn som inneholder data som skrives til disken."
    - id: RecordNumber
      type: System.Int64
      description: "Valgfritt. Postnummer (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> modus filer) eller byte tall (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> modus filer) på som skriving starter."
  overload: Microsoft.VisualBasic.FileSystem.FilePut*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 og ikke er lik -1."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Filen er ugyldig."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int32,System.Int64)
  id: FilePut(System.Int32,System.Int32,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FilePut(Int32,Int32,Int64)
  nameWithType: FileSystem.FilePut(Int32,Int32,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Int32,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Skriver dataene fra en variabel til en fil. Den <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funksjonen gir deg bedre produktivitet og ytelse i i/u-operasjoner enn <xref uid=&quot;langword_csharp_FilePut&quot; name=&quot;FilePut&quot; href=&quot;&quot;> </xref>. Hvis du vil ha mer informasjon, se <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FilePut`er bare gyldig i `Random` og `Binary` modus.       Data som skrives med `FilePut` vanligvis lese fra en fil ved hjelp av `FileGet`.       Andre posten eller byte er i posisjon 2 og så videre første posten eller byte i en fil er i posisjon 1. Hvis du utelater `RecordNumber`, neste post eller byte når sist `FileGet` eller `FilePut` funksjonen eller henvises til i siste `Seek` funksjonen skrives.       Den `StringIsFixedLength` argumentet kontrollerer om funksjonen tolker strenger som variabel eller fast lengde. `FilePut`ikke Skriv lengden sikkerhetsbeskrivelse når argumentet er `True`. Hvis du bruker `StringIsFixedLength`  =  `True` med `FilePut`, må du gjøre det samme med `FileGet`, og at du har og kontroller at strengen initialiseres til lengden som forventet.      ## Tilfeldig modus For filer som er åpnet i `Random` modus, gjelder for følgende regler: - Hvis lengden på dataene som skrives er lavere enn lengden som er angitt i den `RecordLength` -setningsdelen i den `FileOpen` -funksjonen, `FilePut` skriver etterfølgende poster på postlengde grensene. Avstanden mellom slutten på én post og starten av den neste posten ut med det eksisterende innholdet i filen-bufferen. Det er vanligvis lurt å ha postlengde samsvarer med lengden på dataene som skrives fordi mengden utfylling data ikke kan fastslås med noen sikkerhet. Hvis lengden på dataene som skrives er større enn lengden som er angitt i den `RecordLength` -setningsdelen i `FileOpen` -funksjonen, vil bli utløst et unntak.      -Hvis variabelen skrives er en streng, `FilePut` skriver en beskrivelse for to byte som inneholder strenglengden, og deretter skriver data som skal settes inn variabelen. Derfor postlengde angitt av den `RecordLength` -setningsdel i den `FileOpen` funksjonen må være minst to byte større enn den faktiske lengden på strengen.      -Hvis variabelen skrives er et objekt som inneholder en numerisk type `FilePut` skriver to byte som identifiserer den `VarType` for objektet og skriver variabelen. For eksempel under skriving av et objekt som inneholder et heltall `FilePut` skrives seks: to byte som identifiserer objektet som `VarType(`3`)` (`Integer`) og fire byte som inneholder dataene. Postlengde som er angitt av den `RecordLength` parameter i den `FileOpen` funksjonen må være minst to byte større enn faktisk antall byte som kreves for å lagre variabelen.      -Hvis variabelen skrives er et objekt som inneholder en streng, `FilePut` skriver en to byte sikkerhetsbeskrivelse å identifisere den `VarType(`8`)` av objektet, og en beskrivelse for to byte som angir lengden på strengen, og skriver strengdata. Postlengde som er angitt av den `RecordLength` parameter i den `FileOpen` funksjonen må være minst fire byte større enn den faktiske lengden på strengen. Hvis du vil legge en streng uten beskrivelsen, må du sende `True` til den `StringIsFixedLength` parameteren og strengen du lese i må være riktig lengde.      -Hvis variabelen skrives er en matrise, har du et valg om å skrive en beskrivelse for størrelse og dimensjoner i matrisen eller ikke. Visual Basic 6.0 og tidligere versjoner skrive Filbeskrivelse for en dynamisk matrise, men ikke for en matrise med fast størrelse. Som standard ikke skriving av beskrivelsen Visual Basic 2005. For å skrive til beskrivelsen, kan du angi den `ArrayIsDynamic` parameter `True`. Når du skriver matrisen, må samsvare med måten matrisen blir lest; Hvis det skal leses med beskrivelsen, må du skrive beskrivelsen. Beskrivelsen angir rangeringen for matrisen, størrelse og nedre grense for hver rangeringen. De lengde lik 2 plus 8 ganger antallet dimensjoner: (2 + 8 * NumberOfDimensions). Postlengde som er angitt av den `RecordLength` -setningsdel i den `FileOpen` funksjonen må være større enn eller lik summen av alle byte som kreves for å skrive matrise dataene og beskrivelsen for matrise. Følgende matrise deklarasjon krever for eksempel 218 byte når matrisen er skrevet til disken.           [!code-vb[VbVbalrCatRef&#43;](~/add/codesnippet/visualbasic/6a50d289-6d85-4fc1-99f7-_1.vb) ] - Hvis variabelen skrives er andre typer variabelen (ikke en variabel streng eller et objekt) `FilePut` skriver bare variabelen dataene. Postlengde som er angitt av den `RecordLength` -setningsdel i den `FileOpen` funksjonen må være større enn eller lik lengden på dataene som skrives.      - `FilePut` skriver elementer av strukturer som om hver ble skrevet enkeltvis, men det er ingen utfylling mellom elementene. Den `VBFixedString` attributtet kan brukes til streng feltene i strukturer som viser størrelsen på strengen ved å skrive til disken.          > [!NOTE] > Streng felt som har flere byte enn angitt i i `VBFixedString` attributtet er avkuttet under skriving til disk, ## binær modus For filer som er åpnet i `Binary` modus, de fleste av de `Random` modus regler gjelder, med noen unntak. Følgende regler for filer som åpnes i `Binary` modus er forskjellig fra regler for `Random` modus: - `RecordLength` -setningsdel i den `FileOpen` funksjonen har ingen virkning. `FilePut`skriver alle variabler på disken sammenhengende, det vil si uten utfylling mellom poster.      -For en matrise enn en matrise i en struktur `FilePut` skriver bare dataene. Ingen sikkerhetsbeskrivelse skrives.      - `FilePut` skriver variabelen strenger som ikke er elementer av strukturer uten to bytelengde sikkerhetsbeskrivelse. Antall byte skrevet er lik antallet tegn i strengen. For eksempel følgende setninger skrive 11 byte til filnummer 1: [!code-vb [VbVbalrCatRef #44](~/add/codesnippet/visualbasic/6a50d289-6d85-4fc1-99f7-_2.vb) ] – skriving til filen ved hjelp av den `FilePut` funksjonen krever `Write` tilgang fra den <xref:System.Security.Permissions.FileIOPermissionAccess>opplisting.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `FilePut` function to write data to a file. Five records of the structure `Person` are written to the file.  \n  \n [!code-vb[VbVbalrCatRef#42](~/add/codesnippet/visualbasic/6a50d289-6d85-4fc1-99f7-_3.vb)]"
  syntax:
    content: public static void FilePut (int FileNumber, int Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Kreves. Et gyldig tall."
    - id: Value
      type: System.Int32
      description: "Kreves. Ugyldig variabelnavn som inneholder data som skrives til disken."
    - id: RecordNumber
      type: System.Int64
      description: "Valgfritt. Postnummer (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> modus filer) eller byte tall (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> modus filer) på som skriving starter."
  overload: Microsoft.VisualBasic.FileSystem.FilePut*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 og ikke er lik -1."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Filen er ugyldig."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int64,System.Int64)
  id: FilePut(System.Int32,System.Int64,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FilePut(Int32,Int64,Int64)
  nameWithType: FileSystem.FilePut(Int32,Int64,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Int64,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Skriver dataene fra en variabel til en fil. Den <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funksjonen gir deg bedre produktivitet og ytelse i i/u-operasjoner enn <xref uid=&quot;langword_csharp_FilePut&quot; name=&quot;FilePut&quot; href=&quot;&quot;> </xref>. Hvis du vil ha mer informasjon, se <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FilePut`er bare gyldig i `Random` og `Binary` modus.       Data som skrives med `FilePut` vanligvis lese fra en fil ved hjelp av `FileGet`.       Andre posten eller byte er i posisjon 2 og så videre første posten eller byte i en fil er i posisjon 1. Hvis du utelater `RecordNumber`, neste post eller byte når sist `FileGet` eller `FilePut` funksjonen eller henvises til i siste `Seek` funksjonen skrives.       Den `StringIsFixedLength` argumentet kontrollerer om funksjonen tolker strenger som variabel eller fast lengde. `FilePut`ikke Skriv lengden sikkerhetsbeskrivelse når argumentet er `True`. Hvis du bruker `StringIsFixedLength`  =  `True` med `FilePut`, må du gjøre det samme med `FileGet`, og at du har og kontroller at strengen initialiseres til lengden som forventet.      ## Tilfeldig modus For filer som er åpnet i `Random` modus, gjelder for følgende regler: - Hvis lengden på dataene som skrives er lavere enn lengden som er angitt i den `RecordLength` -setningsdelen i den `FileOpen` -funksjonen, `FilePut` skriver etterfølgende poster på postlengde grensene. Avstanden mellom slutten på én post og starten av den neste posten ut med det eksisterende innholdet i filen-bufferen. Det er vanligvis lurt å ha postlengde samsvarer med lengden på dataene som skrives fordi mengden utfylling data ikke kan fastslås med noen sikkerhet. Hvis lengden på dataene som skrives er større enn lengden som er angitt i den `RecordLength` -setningsdelen i `FileOpen` -funksjonen, vil bli utløst et unntak.      -Hvis variabelen skrives er en streng, `FilePut` skriver en beskrivelse for to byte som inneholder strenglengden, og deretter skriver data som skal settes inn variabelen. Derfor postlengde angitt av den `RecordLength` -setningsdel i den `FileOpen` funksjonen må være minst to byte større enn den faktiske lengden på strengen.      -Hvis variabelen skrives er et objekt som inneholder en numerisk type `FilePut` skriver to byte som identifiserer den `VarType` for objektet og skriver variabelen. For eksempel under skriving av et objekt som inneholder et heltall `FilePut` skrives seks: to byte som identifiserer objektet som `VarType(`3`)` (`Integer`) og fire byte som inneholder dataene. Postlengde som er angitt av den `RecordLength` parameter i den `FileOpen` funksjonen må være minst to byte større enn faktisk antall byte som kreves for å lagre variabelen.      -Hvis variabelen skrives er et objekt som inneholder en streng, `FilePut` skriver en to byte sikkerhetsbeskrivelse å identifisere den `VarType(`8`)` av objektet, og en beskrivelse for to byte som angir lengden på strengen, og skriver strengdata. Postlengde som er angitt av den `RecordLength` parameter i den `FileOpen` funksjonen må være minst fire byte større enn den faktiske lengden på strengen. Hvis du vil legge en streng uten beskrivelsen, må du sende `True` til den `StringIsFixedLength` parameteren og strengen du lese i må være riktig lengde.      -Hvis variabelen skrives er en matrise, har du et valg om å skrive en beskrivelse for størrelse og dimensjoner i matrisen eller ikke. Visual Basic 6.0 og tidligere versjoner skrive Filbeskrivelse for en dynamisk matrise, men ikke for en matrise med fast størrelse. Som standard ikke skriving av beskrivelsen Visual Basic 2005. For å skrive til beskrivelsen, kan du angi den `ArrayIsDynamic` parameter `True`. Når du skriver matrisen, må samsvare med måten matrisen blir lest; Hvis det skal leses med beskrivelsen, må du skrive beskrivelsen. Beskrivelsen angir rangeringen for matrisen, størrelse og nedre grense for hver rangeringen. De lengde lik 2 plus 8 ganger antallet dimensjoner: (2 + 8 * NumberOfDimensions). Postlengde som er angitt av den `RecordLength` -setningsdel i den `FileOpen` funksjonen må være større enn eller lik summen av alle byte som kreves for å skrive matrise dataene og beskrivelsen for matrise. Følgende matrise deklarasjon krever for eksempel 218 byte når matrisen er skrevet til disken.           [!code-vb[VbVbalrCatRef&#43;](~/add/codesnippet/visualbasic/90087c6f-a92b-4ccb-88f5-_1.vb) ] - Hvis variabelen skrives er andre typer variabelen (ikke en variabel streng eller et objekt) `FilePut` skriver bare variabelen dataene. Postlengde som er angitt av den `RecordLength` -setningsdel i den `FileOpen` funksjonen må være større enn eller lik lengden på dataene som skrives.      - `FilePut` skriver elementer av strukturer som om hver ble skrevet enkeltvis, men det er ingen utfylling mellom elementene. Den `VBFixedString` attributtet kan brukes til streng feltene i strukturer som viser størrelsen på strengen ved å skrive til disken.          > [!NOTE] > Streng felt som har flere byte enn angitt i i `VBFixedString` attributtet er avkuttet under skriving til disk, ## binær modus For filer som er åpnet i `Binary` modus, de fleste av de `Random` modus regler gjelder, med noen unntak. Følgende regler for filer som åpnes i `Binary` modus er forskjellig fra regler for `Random` modus: - `RecordLength` -setningsdel i den `FileOpen` funksjonen har ingen virkning. `FilePut`skriver alle variabler på disken sammenhengende, det vil si uten utfylling mellom poster.      -For en matrise enn en matrise i en struktur `FilePut` skriver bare dataene. Ingen sikkerhetsbeskrivelse skrives.      - `FilePut` skriver variabelen strenger som ikke er elementer av strukturer uten to bytelengde sikkerhetsbeskrivelse. Antall byte skrevet er lik antallet tegn i strengen. For eksempel følgende setninger skrive 11 byte til filnummer 1: [!code-vb [VbVbalrCatRef #44](~/add/codesnippet/visualbasic/90087c6f-a92b-4ccb-88f5-_2.vb) ] – skriving til filen ved hjelp av den `FilePut` funksjonen krever `Write` tilgang fra den <xref:System.Security.Permissions.FileIOPermissionAccess>opplisting.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `FilePut` function to write data to a file. Five records of the structure `Person` are written to the file.  \n  \n [!code-vb[VbVbalrCatRef#42](~/add/codesnippet/visualbasic/90087c6f-a92b-4ccb-88f5-_3.vb)]"
  syntax:
    content: public static void FilePut (int FileNumber, long Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Kreves. Et gyldig tall."
    - id: Value
      type: System.Int64
      description: "Kreves. Ugyldig variabelnavn som inneholder data som skrives til disken."
    - id: RecordNumber
      type: System.Int64
      description: "Valgfritt. Postnummer (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> modus filer) eller byte tall (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> modus filer) på som skriving starter."
  overload: Microsoft.VisualBasic.FileSystem.FilePut*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 og ikke er lik -1."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Filen er ugyldig."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Single,System.Int64)
  id: FilePut(System.Int32,System.Single,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FilePut(Int32,Single,Int64)
  nameWithType: FileSystem.FilePut(Int32,Single,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Single,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Skriver dataene fra en variabel til en fil. Den <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funksjonen gir deg bedre produktivitet og ytelse i i/u-operasjoner enn <xref uid=&quot;langword_csharp_FilePut&quot; name=&quot;FilePut&quot; href=&quot;&quot;> </xref>. Hvis du vil ha mer informasjon, se <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FilePut`er bare gyldig i `Random` og `Binary` modus.       Data som skrives med `FilePut` vanligvis lese fra en fil ved hjelp av `FileGet`.       Andre posten eller byte er i posisjon 2 og så videre første posten eller byte i en fil er i posisjon 1. Hvis du utelater `RecordNumber`, neste post eller byte når sist `FileGet` eller `FilePut` funksjonen eller henvises til i siste `Seek` funksjonen skrives.       Den `StringIsFixedLength` argumentet kontrollerer om funksjonen tolker strenger som variabel eller fast lengde. `FilePut`ikke Skriv lengden sikkerhetsbeskrivelse når argumentet er `True`. Hvis du bruker `StringIsFixedLength`  =  `True` med `FilePut`, må du gjøre det samme med `FileGet`, og at du har og kontroller at strengen initialiseres til lengden som forventet.      ## Tilfeldig modus For filer som er åpnet i `Random` modus, gjelder for følgende regler: - Hvis lengden på dataene som skrives er lavere enn lengden som er angitt i den `RecordLength` -setningsdelen i den `FileOpen` -funksjonen, `FilePut` skriver etterfølgende poster på postlengde grensene. Avstanden mellom slutten på én post og starten av den neste posten ut med det eksisterende innholdet i filen-bufferen. Det er vanligvis lurt å ha postlengde samsvarer med lengden på dataene som skrives fordi mengden utfylling data ikke kan fastslås med noen sikkerhet. Hvis lengden på dataene som skrives er større enn lengden som er angitt i den `RecordLength` -setningsdelen i `FileOpen`-funksjonen, vil bli utløst et unntak.      -Hvis variabelen skrives er en streng, `FilePut` skriver en beskrivelse for to byte som inneholder strenglengden, og deretter skriver data som skal settes inn variabelen. Derfor postlengde angitt av den `RecordLength` -setningsdel i den `FileOpen` funksjonen må være minst to byte større enn den faktiske lengden på strengen.      -Hvis variabelen skrives er et objekt som inneholder en numerisk type `FilePut` skriver to byte som identifiserer den `VarType` for objektet og skriver variabelen. For eksempel under skriving av et objekt som inneholder et heltall `FilePut` skrives seks: to byte som identifiserer objektet som `VarType(`3`)` (`Integer`) og fire byte som inneholder dataene. Postlengde som er angitt av den `RecordLength` parameter i den `FileOpen` funksjonen må være minst to byte større enn faktisk antall byte som kreves for å lagre variabelen.      -Hvis variabelen skrives er et objekt som inneholder en streng, `FilePut` skriver en to byte sikkerhetsbeskrivelse å identifisere den `VarType(`8`)` av objektet, og en beskrivelse for to byte som angir lengden på strengen, og skriver strengdata. Postlengde som er angitt av den `RecordLength` parameter i den `FileOpen` funksjonen må være minst fire byte større enn den faktiske lengden på strengen. Hvis du vil legge en streng uten beskrivelsen, må du sende `True` til den `StringIsFixedLength` parameteren og strengen du lese i må være riktig lengde.      -Hvis variabelen skrives er en matrise, har du et valg om å skrive en beskrivelse for størrelse og dimensjoner i matrisen eller ikke. Visual Basic 6.0 og tidligere versjoner skrive Filbeskrivelse for en dynamisk matrise, men ikke for en matrise med fast størrelse. Som standard ikke skriving av beskrivelsen Visual Basic 2005. For å skrive til beskrivelsen, kan du angi den `ArrayIsDynamic` parameter `True`. Når du skriver matrisen, må samsvare med måten matrisen blir lest; Hvis det skal leses med beskrivelsen, må du skrive beskrivelsen. Beskrivelsen angir rangeringen for matrisen, størrelse og nedre grense for hver rangeringen. De lengde lik 2 plus 8 ganger antallet dimensjoner: (2 + 8 * NumberOfDimensions). Postlengde som er angitt av den `RecordLength` -setningsdel i den `FileOpen` funksjonen må være større enn eller lik summen av alle byte som kreves for å skrive matrise dataene og beskrivelsen for matrise. Følgende matrise deklarasjon krever for eksempel 218 byte når matrisen er skrevet til disken.           [!code-vb[VbVbalrCatRef&#43;](~/add/codesnippet/visualbasic/67fd8601-6772-45be-87ee-_1.vb) ] - Hvis variabelen skrives er andre typer variabelen (ikke en variabel streng eller et objekt) `FilePut` skriver bare variabelen dataene. Postlengde som er angitt av den `RecordLength` -setningsdel i den `FileOpen` funksjonen må være større enn eller lik lengden på dataene som skrives.      - `FilePut` skriver elementer av strukturer som om hver ble skrevet enkeltvis, men det er ingen utfylling mellom elementene. Den `VBFixedString` attributtet kan brukes til streng feltene i strukturer som viser størrelsen på strengen ved å skrive til disken.          > [!NOTE] > Streng felt som har flere byte enn angitt i i `VBFixedString` attributtet er avkuttet under skriving til disk, ## binær modus For filer som er åpnet i `Binary` modus, de fleste av de `Random` modus regler gjelder, med noen unntak. Følgende regler for filer som åpnes i `Binary` modus er forskjellig fra regler for `Random` modus: - `RecordLength` -setningsdel i den `FileOpen` funksjonen har ingen virkning. `FilePut`skriver alle variabler på disken sammenhengende, det vil si uten utfylling mellom poster.      -For en matrise enn en matrise i en struktur `FilePut` skriver bare dataene. Ingen sikkerhetsbeskrivelse skrives.      - `FilePut` skriver variabelen strenger som ikke er elementer av strukturer uten to bytelengde sikkerhetsbeskrivelse. Antall byte skrevet er lik antallet tegn i strengen. For eksempel følgende setninger skrive 11 byte til filnummer 1: [!code-vb [VbVbalrCatRef #44](~/add/codesnippet/visualbasic/67fd8601-6772-45be-87ee-_2.vb) ] – skriving til filen ved hjelp av den `FilePut` funksjonen krever `Write` tilgang fra den <xref:System.Security.Permissions.FileIOPermissionAccess>opplisting.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `FilePut` function to write data to a file. Five records of the structure `Person` are written to the file.  \n  \n [!code-vb[VbVbalrCatRef#42](~/add/codesnippet/visualbasic/67fd8601-6772-45be-87ee-_3.vb)]"
  syntax:
    content: public static void FilePut (int FileNumber, float Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Kreves. Et gyldig tall."
    - id: Value
      type: System.Single
      description: "Kreves. Ugyldig variabelnavn som inneholder data som skrives til disken."
    - id: RecordNumber
      type: System.Int64
      description: "Valgfritt. Postnummer (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> modus filer) eller byte tall (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> modus filer) på som skriving starter."
  overload: Microsoft.VisualBasic.FileSystem.FilePut*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 og ikke er lik -1."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Filen er ugyldig."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.ValueType,System.Int64)
  id: FilePut(System.Int32,System.ValueType,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FilePut(Int32,ValueType,Int64)
  nameWithType: FileSystem.FilePut(Int32,ValueType,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,ValueType,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Skriver dataene fra en variabel til en fil. Den <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funksjonen gir deg bedre produktivitet og ytelse i i/u-operasjoner enn <xref uid=&quot;langword_csharp_FilePut&quot; name=&quot;FilePut&quot; href=&quot;&quot;> </xref>. Hvis du vil ha mer informasjon, se <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FilePut`er bare gyldig i `Random` og `Binary` modus.       Data som skrives med `FilePut` vanligvis lese fra en fil ved hjelp av `FileGet`.       Andre posten eller byte er i posisjon 2 og så videre første posten eller byte i en fil er i posisjon 1. Hvis du utelater `RecordNumber`, neste post eller byte når sist `FileGet` eller `FilePut` funksjonen eller henvises til i siste `Seek` funksjonen skrives.       Den `StringIsFixedLength` argumentet kontrollerer om funksjonen tolker strenger som variabel eller fast lengde. `FilePut`ikke Skriv lengden sikkerhetsbeskrivelse når argumentet er `True`. Hvis du bruker `StringIsFixedLength`  =  `True` med `FilePut`, må du gjøre det samme med `FileGet`, og at du har og kontroller at strengen initialiseres til lengden som forventet.      ## Tilfeldig modus For filer som er åpnet i `Random` modus, gjelder for følgende regler: - Hvis lengden på dataene som skrives er lavere enn lengden som er angitt i den`RecordLength` -setningsdelen i den `FileOpen` -funksjonen, `FilePut` skriver etterfølgende poster på postlengde grensene. Avstanden mellom slutten på én post og starten av den neste posten ut med det eksisterende innholdet i filen-bufferen. Det er vanligvis lurt å ha postlengde samsvarer med lengden på dataene som skrives fordi mengden utfylling data ikke kan fastslås med noen sikkerhet. Hvis lengden på dataene som skrives er større enn lengden som er angitt i den `RecordLength` -setningsdelen i `FileOpen` -funksjonen, vil bli utløst et unntak.      -Hvis variabelen skrives er en streng, `FilePut` skriver en beskrivelse for to byte som inneholder strenglengden, og deretter skriver data som skal settes inn variabelen. Derfor postlengde angitt av den `RecordLength` -setningsdel i den `FileOpen` funksjonen må være minst to byte større enn den faktiske lengden på strengen.      -Hvis variabelen skrives er et objekt som inneholder en numerisk type `FilePut` skriver to byte som identifiserer den `VarType` for objektet og skriver variabelen. For eksempel under skriving av et objekt som inneholder et heltall `FilePut` skrives seks: to byte som identifiserer objektet som `VarType(`3`)` (`Integer`) og fire byte som inneholder dataene. Postlengde som er angitt av den `RecordLength` parameter i den `FileOpen` funksjonen må være minst to byte større enn faktisk antall byte som kreves for å lagre variabelen.      -Hvis variabelen skrives er et objekt som inneholder en streng, `FilePut` skriver en to byte sikkerhetsbeskrivelse å identifisere den `VarType(`8`)` av objektet, og en beskrivelse for to byte som angir lengden på strengen, og skriver strengdata. Postlengde som er angitt av den `RecordLength` parameter i den `FileOpen` funksjonen må være minst fire byte større enn den faktiske lengden på strengen. Hvis du vil legge en streng uten beskrivelsen, må du sende `True` til den `StringIsFixedLength` parameteren og strengen du lese i må være riktig lengde.      -Hvis variabelen skrives er en matrise, har du et valg om å skrive en beskrivelse for størrelse og dimensjoner i matrisen eller ikke. Visual Basic 6.0 og tidligere versjoner skrive Filbeskrivelse for en dynamisk matrise, men ikke for en matrise med fast størrelse. Som standard ikke skriving av beskrivelsen Visual Basic 2005. For å skrive til beskrivelsen, kan du angi den `ArrayIsDynamic` parameter `True`. Når du skriver matrisen, må samsvare med måten matrisen blir lest; Hvis det skal leses med beskrivelsen, må du skrive beskrivelsen. Beskrivelsen angir rangeringen for matrisen, størrelse og nedre grense for hver rangeringen. De lengde lik 2 plus 8 ganger antallet dimensjoner: (2 + 8 * NumberOfDimensions). Postlengde som er angitt av den `RecordLength` -setningsdel i den `FileOpen` funksjonen må være større enn eller lik summen av alle byte som kreves for å skrive matrise dataene og beskrivelsen for matrise. Følgende matrise deklarasjon krever for eksempel 218 byte når matrisen er skrevet til disken.           [!code-vb[VbVbalrCatRef&#43;](~/add/codesnippet/visualbasic/814bf35d-de00-4bf6-9dca-_1.vb) ] - Hvis variabelen skrives er andre typer variabelen (ikke en variabel streng eller et objekt) `FilePut` skriver bare variabelen dataene. Postlengde som er angitt av den `RecordLength` -setningsdel i den `FileOpen` funksjonen må være større enn eller lik lengden på dataene som skrives.      - `FilePut` skriver elementer av strukturer som om hver ble skrevet enkeltvis, men det er ingen utfylling mellom elementene. Den `VBFixedString` attributtet kan brukes til streng feltene i strukturer som viser størrelsen på strengen ved å skrive til disken.          > [!NOTE] > Streng felt som har flere byte enn angitt i i `VBFixedString` attributtet er avkuttet under skriving til disk, ## binær modus For filer som er åpnet i `Binary` modus, de fleste av de `Random` modus regler gjelder, med noen unntak. Følgende regler for filer som åpnes i `Binary` modus er forskjellig fra regler for `Random` modus: - `RecordLength` -setningsdel i den `FileOpen` funksjonen har ingen virkning. `FilePut`skriver alle variabler på disken sammenhengende, det vil si uten utfylling mellom poster.      -For en matrise enn en matrise i en struktur `FilePut` skriver bare dataene. Ingen sikkerhetsbeskrivelse skrives.      - `FilePut` skriver variabelen strenger som ikke er elementer av strukturer uten to bytelengde sikkerhetsbeskrivelse. Antall byte skrevet er lik antallet tegn i strengen. For eksempel følgende setninger skrive 11 byte til filnummer 1: [!code-vb [VbVbalrCatRef #44](~/add/codesnippet/visualbasic/814bf35d-de00-4bf6-9dca-_2.vb) ] – skriving til filen ved hjelp av den `FilePut` funksjonen krever `Write` tilgang fra den <xref:System.Security.Permissions.FileIOPermissionAccess>opplisting.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `FilePut` function to write data to a file. Five records of the structure `Person` are written to the file.  \n  \n [!code-vb[VbVbalrCatRef#42](~/add/codesnippet/visualbasic/814bf35d-de00-4bf6-9dca-_3.vb)]"
  syntax:
    content: public static void FilePut (int FileNumber, ValueType Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Kreves. Et gyldig tall."
    - id: Value
      type: System.ValueType
      description: "Kreves. Ugyldig variabelnavn som inneholder data som skrives til disken."
    - id: RecordNumber
      type: System.Int64
      description: "Valgfritt. Postnummer (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> modus filer) eller byte tall (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> modus filer) på som skriving starter."
  overload: Microsoft.VisualBasic.FileSystem.FilePut*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 og ikke er lik -1."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Filen er ugyldig."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Object,System.Object,System.Object)
  id: FilePut(System.Object,System.Object,System.Object)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FilePut(Object,Object,Object)
  nameWithType: FileSystem.FilePut(Object,Object,Object)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Object,Object,Object)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Skriver dataene fra en variabel til en fil. Den <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funksjonen gir deg bedre produktivitet og ytelse i i/u-operasjoner enn <xref uid=&quot;langword_csharp_FilePut&quot; name=&quot;FilePut&quot; href=&quot;&quot;> </xref>. Hvis du vil ha mer informasjon, se <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FilePut`er bare gyldig i `Random` og `Binary` modus.       Data som skrives med `FilePut` vanligvis lese fra en fil ved hjelp av `FileGet`.       Andre posten eller byte er i posisjon 2 og så videre første posten eller byte i en fil er i posisjon 1. Hvis du utelater `RecordNumber`, neste post eller byte når sist `FileGet` eller `FilePut` funksjonen eller henvises til i siste `Seek` funksjonen skrives.       Den `StringIsFixedLength` argumentet kontrollerer om funksjonen tolker strenger som variabel eller fast lengde. `FilePut`ikke Skriv lengden sikkerhetsbeskrivelse når argumentet er `True`. Hvis du bruker `StringIsFixedLength`  =  `True` med `FilePut`, må du gjøre det samme med `FileGet`, og at du har og kontroller at strengen initialiseres til lengden som forventet.      ## Tilfeldig modus For filer som er åpnet i `Random` modus, gjelder for følgende regler: - Hvis lengden på dataene som skrives er lavere enn lengden som er angitt i den `RecordLength` -setningsdelen i den `FileOpen` -funksjonen, `FilePut` skriver etterfølgende poster på postlengde grensene. Avstanden mellom slutten på én post og starten av den neste posten ut med det eksisterende innholdet i filen-bufferen. Det er vanligvis lurt å ha postlengde samsvarer med lengden på dataene som skrives fordi mengden utfylling data ikke kan fastslås med noen sikkerhet. Hvis lengden på dataene som skrives er større enn lengden som er angitt i den `RecordLength` -setningsdelen i `FileOpen` -funksjonen, vil bli utløst et unntak.      -Hvis variabelen skrives er en streng, `FilePut` skriver en beskrivelse for to byte som inneholder strenglengden, og deretter skriver data som skal settes inn variabelen. Derfor postlengde angitt av den `RecordLength` -setningsdel i den `FileOpen` funksjonen må være minst to byte større enn den faktiske lengden på strengen.      -Hvis variabelen skrives er et objekt som inneholder en numerisk type `FilePut` skriver to byte som identifiserer den `VarType` for objektet og skriver variabelen. For eksempel under skriving av et objekt som inneholder et heltall `FilePut` skrives seks: to byte som identifiserer objektet som `VarType(`3`)` (`Integer`) og fire byte som inneholder dataene. Postlengde som er angitt av den `RecordLength` parameter i den `FileOpen` funksjonen må være minst to byte større enn faktisk antall byte som kreves for å lagre variabelen.      -Hvis variabelen skrives er et objekt som inneholder en streng, `FilePut` skriver en to byte sikkerhetsbeskrivelse å identifisere den `VarType(`8`)` av objektet, og en beskrivelse for to byte som angir lengden på strengen, og skriver strengdata. Postlengde som er angitt av den `RecordLength` parameter i den `FileOpen` funksjonen må være minst fire byte større enn den faktiske lengden på strengen. Hvis du vil legge en streng uten beskrivelsen, må du sende `True` til den `StringIsFixedLength` parameteren og strengen du lese i må være riktig lengde.      -Hvis variabelen skrives er en matrise, har du et valg om å skrive en beskrivelse for størrelse og dimensjoner i matrisen eller ikke. Visual Basic 6.0 og tidligere versjoner skrive Filbeskrivelse for en dynamisk matrise, men ikke for en matrise med fast størrelse. Som standard ikke skriving av beskrivelsen Visual Basic 2005. For å skrive til beskrivelsen, kan du angi den `ArrayIsDynamic` parameter `True`. Når du skriver matrisen, må samsvare med måten matrisen blir lest; Hvis det skal leses med beskrivelsen, må du skrive beskrivelsen. Beskrivelsen angir rangeringen for matrisen, størrelse og nedre grense for hver rangeringen. De lengde lik 2 plus 8 ganger antallet dimensjoner: (2 + 8 * NumberOfDimensions). Postlengde som er angitt av den `RecordLength` -setningsdel i den `FileOpen` funksjonen må være større enn eller lik summen av alle byte som kreves for å skrive matrise dataene og beskrivelsen for matrise. Følgende matrise deklarasjon krever for eksempel 218 byte når matrisen er skrevet til disken.           [!code-vb[VbVbalrCatRef&#43;](~/add/codesnippet/visualbasic/b8a1d844-c860-47f2-9311-_1.vb) ] - Hvis variabelen skrives er andre typer variabelen (ikke en variabel streng eller et objekt) `FilePut` skriver bare variabelen dataene. Postlengde som er angitt av den `RecordLength` -setningsdel i den `FileOpen` funksjonen må være større enn eller lik lengden på dataene som skrives.      - `FilePut` skriver elementer av strukturer som om hver ble skrevet enkeltvis, men det er ingen utfylling mellom elementene. Den `VBFixedString` attributtet kan brukes til streng feltene i strukturer som viser størrelsen på strengen ved å skrive til disken.          > [!NOTE] > Streng felt som har flere byte enn angitt i i `VBFixedString` attributtet er avkuttet under skriving til disk, ## binær modus For filer som er åpnet i `Binary` modus, de fleste av de `Random` modus regler gjelder, med noen unntak. Følgende regler for filer som åpnes i `Binary` modus er forskjellig fra regler for `Random` modus: - `RecordLength` -setningsdel i den `FileOpen` funksjonen har ingen virkning. `FilePut`skriver alle variabler på disken sammenhengende, det vil si uten utfylling mellom poster.      -For en matrise enn en matrise i en struktur `FilePut` skriver bare dataene. Ingen sikkerhetsbeskrivelse skrives.      - `FilePut` skriver variabelen strenger som ikke er elementer av strukturer uten to bytelengde sikkerhetsbeskrivelse. Antall byte skrevet er lik antallet tegn i strengen. For eksempel følgende setninger skrive 11 byte til filnummer 1: [!code-vb [VbVbalrCatRef #44](~/add/codesnippet/visualbasic/b8a1d844-c860-47f2-9311-_2.vb) ] – skriving til filen ved hjelp av den `FilePut` funksjonen krever `Write` tilgang fra den <xref:System.Security.Permissions.FileIOPermissionAccess>opplisting.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `FilePut` function to write data to a file. Five records of the structure `Person` are written to the file.  \n  \n [!code-vb[VbVbalrCatRef#42](~/add/codesnippet/visualbasic/b8a1d844-c860-47f2-9311-_3.vb)]"
  syntax:
    content: public static void FilePut (object FileNumber, object Value, object RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Object
      description: "Kreves. Et gyldig tall."
    - id: Value
      type: System.Object
      description: "Kreves. Ugyldig variabelnavn som inneholder data som skrives til disken."
    - id: RecordNumber
      type: System.Object
      description: "Valgfritt. Postnummer (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> modus filer) eller byte tall (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> modus filer) på som skriving starter."
  overload: Microsoft.VisualBasic.FileSystem.FilePut*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 og ikke er lik -1."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Filen er ugyldig."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.String,System.Int64,System.Boolean)
  id: FilePut(System.Int32,System.String,System.Int64,System.Boolean)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FilePut(Int32,String,Int64,Boolean)
  nameWithType: FileSystem.FilePut(Int32,String,Int64,Boolean)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,String,Int64,Boolean)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Skriver dataene fra en variabel til en fil. Den <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funksjonen gir deg bedre produktivitet og ytelse i i/u-operasjoner enn <xref uid=&quot;langword_csharp_FilePut&quot; name=&quot;FilePut&quot; href=&quot;&quot;> </xref>. Hvis du vil ha mer informasjon, se <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>.."
  remarks: "`FilePut`er bare gyldig i `Random` og `Binary` modus.       Data som skrives med `FilePut` vanligvis lese fra en fil ved hjelp av `FileGet`.       Andre posten eller byte er i posisjon 2 og så videre første posten eller byte i en fil er i posisjon 1. Hvis du utelater `RecordNumber`, neste post eller byte når sist `FileGet` eller `FilePut` funksjonen eller henvises til i siste `Seek` funksjonen skrives.       Den `StringIsFixedLength` argumentet kontrollerer om funksjonen tolker strenger som variabel eller fast lengde. `FilePut`ikke Skriv lengden sikkerhetsbeskrivelse når argumentet er `True`. Hvis du bruker `StringIsFixedLength`  =  `True` med `FilePut`, må du gjøre det samme med `FileGet`, og at du har og kontroller at strengen initialiseres til lengden som forventet.      ## Tilfeldig modus For filer som er åpnet i `Random` modus, gjelder for følgende regler: - Hvis lengden på dataene som skrives er lavere enn lengden som er angitt i den `RecordLength` -setningsdelen i den `FileOpen` -funksjonen, `FilePut` skriver etterfølgende poster på postlengde grensene. Avstanden mellom slutten på én post og starten av den neste posten ut med det eksisterende innholdet i filen-bufferen. Det er vanligvis lurt å ha postlengde samsvarer med lengden på dataene som skrives fordi mengden utfylling data ikke kan fastslås med noen sikkerhet. Hvis lengden på dataene som skrives er større enn lengden som er angitt i den `RecordLength` -setningsdelen i `FileOpen` -funksjonen, vil bli utløst et unntak.      -Hvis variabelen skrives er en streng, `FilePut` skriver en beskrivelse for to byte som inneholder strenglengden, og deretter skriver data som skal settes inn variabelen. Derfor postlengde angitt av den `RecordLength` -setningsdel i den `FileOpen` funksjonen må være minst to byte større enn den faktiske lengden på strengen.      -Hvis variabelen skrives er et objekt som inneholder en numerisk type `FilePut` skriver to byte som identifiserer den `VarType` for objektet og skriver variabelen. For eksempel under skriving av et objekt som inneholder et heltall `FilePut` skrives seks: to byte som identifiserer objektet som `VarType(`3`)` (`Integer`) og fire byte som inneholder dataene. Postlengde som er angitt av den `RecordLength` parameter i den `FileOpen` funksjonen må være minst to byte større enn faktisk antall byte som kreves for å lagre variabelen.      -Hvis variabelen skrives er et objekt som inneholder en streng, `FilePut` skriver en to byte sikkerhetsbeskrivelse å identifisere den `VarType(`8`)` av objektet, og en beskrivelse for to byte som angir lengden på strengen, og skriver strengdata. Postlengde som er angitt av den `RecordLength` parameter i den `FileOpen` funksjonen må være minst fire byte større enn den faktiske lengden på strengen. Hvis du vil legge en streng uten beskrivelsen, må du sende `True` til den `StringIsFixedLength` parameteren og strengen du lese i må være riktig lengde.      -Hvis variabelen skrives er en matrise, har du et valg om å skrive en beskrivelse for størrelse og dimensjoner i matrisen eller ikke. Visual Basic 6.0 og tidligere versjoner skrive Filbeskrivelse for en dynamisk matrise, men ikke for en matrise med fast størrelse. Som standard ikke skriving av beskrivelsen Visual Basic 2005. For å skrive til beskrivelsen, kan du angi den `ArrayIsDynamic` parameter `True`. Når du skriver matrisen, må samsvare med måten matrisen blir lest; Hvis det skal leses med beskrivelsen, må du skrive beskrivelsen. Beskrivelsen angir rangeringen for matrisen, størrelse og nedre grense for hver rangeringen. De lengde lik 2 plus 8 ganger antallet dimensjoner: (2 + 8 * NumberOfDimensions). Postlengde som er angitt av den `RecordLength` -setningsdel i den `FileOpen` funksjonen må være større enn eller lik summen av alle byte som kreves for å skrive matrise dataene og beskrivelsen for matrise. Følgende matrise deklarasjon krever for eksempel 218 byte når matrisen er skrevet til disken.           [!code-vb[VbVbalrCatRef&#43;](~/add/codesnippet/visualbasic/6bdd614c-e459-4fef-9c10-_1.vb) ] - Hvis variabelen skrives er andre typer variabelen (ikke en variabel streng eller et objekt) `FilePut` skriver bare variabelen dataene. Postlengde som er angitt av den `RecordLength` -setningsdel i den `FileOpen` funksjonen må være større enn eller lik lengden på dataene som skrives.      - `FilePut` skriver elementer av strukturer som om hver ble skrevet enkeltvis, men det er ingen utfylling mellom elementene. Den `VBFixedString` attributtet kan brukes til streng feltene i strukturer som viser størrelsen på strengen ved å skrive til disken.          > [!NOTE] > Streng felt som har flere byte enn angitt i i `VBFixedString` attributtet er avkuttet under skriving til disk, ## binær modus For filer som er åpnet i `Binary` modus, de fleste av de `Random` modus regler gjelder, med noen unntak. Følgende regler for filer som åpnes i `Binary` modus er forskjellig fra regler for `Random` modus: - `RecordLength` -setningsdel i den `FileOpen` funksjonen har ingen virkning. `FilePut`skriver alle variabler på disken sammenhengende, det vil si uten utfylling mellom poster.      -For en matrise enn en matrise i en struktur `FilePut` skriver bare dataene. Ingen sikkerhetsbeskrivelse skrives.      - `FilePut` skriver variabelen strenger som ikke er elementer av strukturer uten to bytelengde sikkerhetsbeskrivelse. Antall byte skrevet er lik antallet tegn i strengen. For eksempel følgende setninger skrive 11 byte til filnummer 1: [!code-vb [VbVbalrCatRef #44](~/add/codesnippet/visualbasic/6bdd614c-e459-4fef-9c10-_2.vb) ] – skriving til filen ved hjelp av den `FilePut` funksjonen krever `Write` tilgang fra den <xref:System.Security.Permissions.FileIOPermissionAccess>opplisting.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `FilePut` function to write data to a file. Five records of the structure `Person` are written to the file.  \n  \n [!code-vb[VbVbalrCatRef#42](~/add/codesnippet/visualbasic/6bdd614c-e459-4fef-9c10-_3.vb)]"
  syntax:
    content: public static void FilePut (int FileNumber, string Value, long RecordNumber = -1, bool StringIsFixedLength = false);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Kreves. Et gyldig tall."
    - id: Value
      type: System.String
      description: "Kreves. Ugyldig variabelnavn som inneholder data som skrives til disken."
    - id: RecordNumber
      type: System.Int64
      description: "Valgfritt. Postnummer (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> modus filer) eller byte tall (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> modus filer) på som skriving starter."
    - id: StringIsFixedLength
      type: System.Boolean
      description: "Valgfritt. Gjelder bare når skriving av en streng. Angir om å skrive en streng på to byte lengden beskrivelse for strengen til filen. Standard <xref uid=&quot;langword_csharp_False&quot; name=&quot;False&quot; href=&quot;&quot;> </xref>."
  overload: Microsoft.VisualBasic.FileSystem.FilePut*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 og ikke er lik -1."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Filen er ugyldig."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Array,System.Int64,System.Boolean,System.Boolean)
  id: FilePut(System.Int32,System.Array,System.Int64,System.Boolean,System.Boolean)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FilePut(Int32,Array,Int64,Boolean,Boolean)
  nameWithType: FileSystem.FilePut(Int32,Array,Int64,Boolean,Boolean)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Array,Int64,Boolean,Boolean)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Skriver dataene fra en variabel til en fil. Den <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funksjonen gir deg bedre produktivitet og ytelse i i/u-operasjoner enn <xref uid=&quot;langword_csharp_FilePut&quot; name=&quot;FilePut&quot; href=&quot;&quot;> </xref>. Hvis du vil ha mer informasjon, se <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FilePut`er bare gyldig i `Random` og `Binary` modus.       Data som skrives med `FilePut` vanligvis lese fra en fil ved hjelp av `FileGet`.       Andre posten eller byte er i posisjon 2 og så videre første posten eller byte i en fil er i posisjon 1. Hvis du utelater `RecordNumber`, neste post eller byte når sist `FileGet` eller `FilePut` funksjonen eller henvises til i siste `Seek` funksjonen skrives.       Den `StringIsFixedLength` argumentet kontrollerer om funksjonen tolker strenger som variabel eller fast lengde. `FilePut`ikke Skriv lengden sikkerhetsbeskrivelse når argumentet er `True`. Hvis du bruker `StringIsFixedLength`  =  `True` med `FilePut`, må du gjøre det samme med `FileGet`, og at du har og kontroller at strengen initialiseres til lengden som forventet.      ## Tilfeldig modus For filer som er åpnet i `Random` modus, gjelder for følgende regler: - Hvis lengden på dataene som skrives er lavere enn lengden som er angitt i den `RecordLength` -setningsdelen i den `FileOpen` -funksjonen, `FilePut` skriver etterfølgende poster på postlengde grensene. Avstanden mellom slutten på én post og starten av den neste posten ut med det eksisterende innholdet i filen-bufferen. Det er vanligvis lurt å ha postlengde samsvarer med lengden på dataene som skrives fordi mengden utfylling data ikke kan fastslås med noen sikkerhet. Hvis lengden på dataene som skrives er større enn lengden som er angitt i den `RecordLength` -setningsdelen i `FileOpen` -funksjonen, vil bli utløst et unntak.      -Hvis variabelen skrives er en streng, `FilePut` skriver en beskrivelse for to byte som inneholder strenglengden, og deretter skriver data som skal settes inn variabelen. Derfor postlengde angitt av den `RecordLength` -setningsdel i den `FileOpen` funksjonen må være minst to byte større enn den faktiske lengden på strengen.      -Hvis variabelen skrives er et objekt som inneholder en numerisk type `FilePut` skriver to byte som identifiserer den `VarType` for objektet og skriver variabelen. For eksempel under skriving av et objekt som inneholder et heltall `FilePut` skrives seks: to byte som identifiserer objektet som `VarType(`3`)` (`Integer`) og fire byte som inneholder dataene. Postlengde som er angitt av den `RecordLength` parameter i den `FileOpen` funksjonen må være minst to byte større enn faktisk antall byte som kreves for å lagre variabelen.      -Hvis variabelen skrives er et objekt som inneholder en streng, `FilePut` skriver en to byte sikkerhetsbeskrivelse å identifisere den `VarType(`8`)` av objektet, og en beskrivelse for to byte som angir lengden på strengen, og skriver strengdata. Postlengde som er angitt av den `RecordLength` parameter i den `FileOpen` funksjonen må være minst fire byte større enn den faktiske lengden på strengen. Hvis du vil legge en streng uten beskrivelsen, må du sende `True` til den `StringIsFixedLength` parameteren og strengen du lese i må være riktig lengde.      -Hvis variabelen skrives er en matrise, har du et valg om å skrive en beskrivelse for størrelse og dimensjoner i matrisen eller ikke. Visual Basic 6.0 og tidligere versjoner skrive Filbeskrivelse for en dynamisk matrise, men ikke for en matrise med fast størrelse. Som standard ikke skriving av beskrivelsen Visual Basic 2005. For å skrive til beskrivelsen, kan du angi den `ArrayIsDynamic` parameter `True`. Når du skriver matrisen, må samsvare med måten matrisen blir lest; Hvis det skal leses med beskrivelsen, må du skrive beskrivelsen. Beskrivelsen angir rangeringen for matrisen, størrelse og nedre grense for hver rangeringen. De lengde lik 2 plus 8 ganger antallet dimensjoner: (2 + 8 * NumberOfDimensions). Postlengde som er angitt av den `RecordLength` -setningsdel i den `FileOpen` funksjonen må være større enn eller lik summen av alle byte som kreves for å skrive matrise dataene og beskrivelsen for matrise. Følgende matrise deklarasjon krever for eksempel 218 byte når matrisen er skrevet til disken.           [!code-vb[VbVbalrCatRef&#43;](~/add/codesnippet/visualbasic/34008b69-543f-4e9e-add6-_1.vb) ] - Hvis variabelen skrives er andre typer variabelen (ikke en variabel streng eller et objekt) `FilePut` skriver bare variabelen dataene. Postlengde som er angitt av den `RecordLength` -setningsdel i den `FileOpen` funksjonen må være større enn eller lik lengden på dataene som skrives.      - `FilePut` skriver elementer av strukturer som om hver ble skrevet enkeltvis, men det er ingen utfylling mellom elementene. Den `VBFixedString` attributtet kan brukes til streng feltene i strukturer som viser størrelsen på strengen ved å skrive til disken.          > [!NOTE] > Streng felt som har flere byte enn angitt i i `VBFixedString` attributtet er avkuttet under skriving til disk, ## binær modus For filer som er åpnet i `Binary` modus, de fleste av de `Random` modus regler gjelder, med noen unntak. Følgende regler for filer som åpnes i `Binary` modus er forskjellig fra regler for `Random` modus: - `RecordLength` -setningsdel i den `FileOpen` funksjonen har ingen virkning. `FilePut`skriver alle variabler på disken sammenhengende, det vil si uten utfylling mellom poster.      -For en matrise enn en matrise i en struktur `FilePut` skriver bare dataene. Ingen sikkerhetsbeskrivelse skrives.      - `FilePut` skriver variabelen strenger som ikke er elementer av strukturer uten to bytelengde sikkerhetsbeskrivelse. Antall byte skrevet er lik antallet tegn i strengen. For eksempel følgende setninger skrive 11 byte til filnummer 1: [!code-vb [VbVbalrCatRef #44](~/add/codesnippet/visualbasic/34008b69-543f-4e9e-add6-_2.vb) ] – skriving til filen ved hjelp av den `FilePut` funksjonen krever `Write` tilgang fra den <xref:System.Security.Permissions.FileIOPermissionAccess>opplisting.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `FilePut` function to write data to a file. Five records of the structure `Person` are written to the file.  \n  \n [!code-vb[VbVbalrCatRef#42](~/add/codesnippet/visualbasic/34008b69-543f-4e9e-add6-_3.vb)]"
  syntax:
    content: public static void FilePut (int FileNumber, Array Value, long RecordNumber = -1, bool ArrayIsDynamic = false, bool StringIsFixedLength = false);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Kreves. Et gyldig tall."
    - id: Value
      type: System.Array
      description: "Kreves. Ugyldig variabelnavn som inneholder data som skrives til disken."
    - id: RecordNumber
      type: System.Int64
      description: "Valgfritt. Postnummer (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> modus filer) eller byte tall (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> modus filer) på som skriving starter."
    - id: ArrayIsDynamic
      type: System.Boolean
      description: "Valgfritt. Gjelder bare når skriving av en matrise. Angir om tabellen er skal behandles som dynamiske og om å skrive en matrise beskrivelsen for streng som beskriver lengden."
    - id: StringIsFixedLength
      type: System.Boolean
      description: "Valgfritt. Gjelder bare når skriving av en streng. Angir om å skrive en streng på to byte lengden beskrivelse for strengen til filen. Standard <xref uid=&quot;langword_csharp_False&quot; name=&quot;False&quot; href=&quot;&quot;> </xref>."
  overload: Microsoft.VisualBasic.FileSystem.FilePut*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 og ikke er lik -1."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Filen er ugyldig."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FilePutObject(System.Int32,System.Object,System.Int64)
  id: FilePutObject(System.Int32,System.Object,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FilePutObject(Int32,Object,Int64)
  nameWithType: FileSystem.FilePutObject(Int32,Object,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePutObject(Int32,Object,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Skriver dataene fra en variabel til en fil.  Den <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funksjonen gir deg bedre produktivitet og ytelse i i/u-operasjoner enn <xref uid=&quot;langword_csharp_FilePutObject&quot; name=&quot;FilePutObject&quot; href=&quot;&quot;> </xref>. Hvis du vil ha mer informasjon, se <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "Den `FilePutObject` -funksjonen brukes i stedet for `FilePut` å unngå syntaks på kompileringstidspunktet Hvis typen `Object` sendes i stedet for en annen type, for eksempel `Integer`, `Long`, `Short`og så videre.       `FilePutObject`skriver og leser beskrivelser som beskriver objektet. Hvis du har tenkt å skrive den `Variant` typen `FilePutObject` kreves. Når du er i tvil, hvis du bruker et objekt for den andre parameteren, anbefaler vi at du alltid bruker `FilePutObject` og `FileGetObject`.       `FilePutObject`er bare gyldig i `Random` og `Binary` modus.       Data som skrives med `FilePutObject` vanligvis lese fra en fil ved hjelp av `FileGetObject`.       Andre posten eller byte er i posisjon 2 og så videre første posten eller byte i en fil er i posisjon 1. Hvis du utelater `RecordNumber`, `FilePutObject` skriver neste post eller byte når sist `FileGetObject` eller `FilePutObject` funksjonen (eller posten eller byte som peker til sist `Seek` funksjonen).       Den `StringIsFixedLength` argumentet kontrollerer om funksjonen tolker strenger som variabel eller fast lengde. `FilePutObject`ikke Skriv lengden sikkerhetsbeskrivelse når argumentet er `True`. Hvis du bruker `StringIsFixedLength`  =  `True` med `FilePutObject`, må du gjøre det samme med `FileGetObject`, og du må også kontrollere at strengen initialiseres til lengden som forventet.      ## Tilfeldig modus For filer som er åpnet i `Random` modus, gjelder for følgende regler: - Hvis lengden på dataene som skrives er lavere enn lengden som er angitt i den `RecordLength` -setningsdelen i den `FileOpen` -funksjonen, `FilePutObject` skriver etterfølgende poster på postlengde grensene. Avstanden mellom slutten på én post og starten av den neste posten ut med det eksisterende innholdet i filen-bufferen. Det er vanligvis lurt å ha postlengde samsvarer med lengden på dataene som skrives fordi utfylling datamengden ikke kan fastslås nøyaktig. Hvis lengden på dataene som skrives er større enn lengden som er angitt i den `RecordLength` -setningsdelen i `FileOpen` -funksjonen, et unntak.      -Hvis variabelen skrives er et objekt som inneholder en numerisk type `FilePutObject` skriver to byte som identifiserer den `VarType` for objektet og skriver variabelen. For eksempel under skriving av et objekt som inneholder et heltall `FilePutObject` skrives seks: to byte som identifiserer objektet som `VarType(`3`)` (`Integer`) og fire byte som inneholder dataene. Postlengde som er angitt av den `RecordLength` parameter i den `FileOpen` funksjonen må være minst to byte større enn faktisk antall byte som kreves for å lagre variabelen.      -Hvis variabelen skrives er et objekt som inneholder en streng, `FilePutObject` skriver en to byte sikkerhetsbeskrivelse å identifisere den `VarType(`8`)` av objektet, og en beskrivelse for to byte som angir lengden på strengen, og skriver strengdata. Postlengde som er angitt av den `RecordLength` parameter i den `FileOpen` funksjonen må være minst fire byte større enn den faktiske lengden på strengen. Hvis du vil legge en streng uten beskrivelsen, må du sende `True` til den `StringIsFixedLength` parameteren og strengen du lese i må være riktig lengde.      -Hvis variabelen skrives er en matrise, postlengde som er angitt av den `RecordLength` -setningsdel i den `FileOpen` funksjonen må være større enn eller lik summen av alle byte som kreves for å skrive matrise dataene og beskrivelsen for matrise. Beskrivelsen angir rangeringen for matrisen, størrelse og nedre grense for hver rangeringen. De lengde lik 2 plus 8 ganger antallet dimensjoner: (2 + 8 * NumberOfDimensions).      ## Modus For binærfiler åpnes i `Binary` modus alle de `Random` modus regler gjelder, bortsett fra: - `RecordLength` -setningsdel i den `FileOpen` funksjonen har ingen virkning. `FilePutObject`skriver alle variabler på disken sammenhengende, det vil si uten utfylling mellom poster."
  example:
  - "This example uses the `FilePutObject` function to write a string to a file.  \n  \n [!code-vb[VbVbalrCatRef#54](~/add/codesnippet/visualbasic/69f8d8bb-169c-4dec-b805-_1.vb)]"
  syntax:
    content: public static void FilePutObject (int FileNumber, object Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Kreves. Et gyldig tall."
    - id: Value
      type: System.Object
      description: "Kreves. Ugyldig variabelnavn som inneholder data som skrives til disken."
    - id: RecordNumber
      type: System.Int64
      description: "Valgfritt. Postnummer (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> modus filer) eller byte tall (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> modus filer) på som skriving starter."
  overload: Microsoft.VisualBasic.FileSystem.FilePutObject*
  exceptions: []
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileWidth(System.Int32,System.Int32)
  id: FileWidth(System.Int32,System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileWidth(Int32,Int32)
  nameWithType: FileSystem.FileWidth(Int32,Int32)
  fullName: Microsoft.VisualBasic.FileSystem.FileWidth(Int32,Int32)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Tilordner en output-linjebredden til en fil som er åpnet ved hjelp av den <xref uid=&quot;langword_csharp_FileOpen&quot; name=&quot;FileOpen&quot; href=&quot;&quot;> </xref> funksjonen."
  remarks: ''
  example:
  - "This example uses the `FileWidth` function to set the output line width for a file.  \n  \n [!code-vb[VbVbalrCatRef#10](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._187_1.vb)]"
  syntax:
    content: public static void FileWidth (int FileNumber, int RecordWidth);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Kreves. Et gyldig tall."
    - id: RecordWidth
      type: System.Int32
      description: "Kreves. Numeriske uttrykk i området 0-255, som angir hvor mange tegn som vises på en linje før en ny linje er startet. Hvis `RecordWidth` er lik 0, og det er ingen grense for lang en linje. Standardverdien for `RecordWidth` er 0."
  overload: Microsoft.VisualBasic.FileSystem.FileWidth*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Filen er ugyldig."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FreeFile
  id: FreeFile
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FreeFile()
  nameWithType: FileSystem.FreeFile()
  fullName: Microsoft.VisualBasic.FileSystem.FreeFile()
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Returnerer en <xref uid=&quot;langword_csharp_Integer&quot; name=&quot;Integer&quot; href=&quot;&quot;> </xref> verdi som representerer det neste filnummeret som er tilgjengelig for bruk av den <xref uid=&quot;langword_csharp_FileOpen&quot; name=&quot;FileOpen&quot; href=&quot;&quot;> </xref> funksjonen."
  remarks: "Bruk `FreeFile` til å angi en filnummer som ikke brukes allerede."
  example:
  - "This example uses the `FreeFile` function to return the next available file number. Five files are opened for output within the loop, and some sample data is written to each.  \n  \n [!code-vb[VbVbalrCatRef#55](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._104_1.vb)]"
  syntax:
    content: public static int FreeFile ();
    parameters: []
    return:
      type: System.Int32
      description: "Returnerer en <xref uid=&quot;langword_csharp_Integer&quot; name=&quot;Integer&quot; href=&quot;&quot;> </xref> verdi som representerer det neste filnummeret som er tilgjengelig for bruk av den <xref uid=&quot;langword_csharp_FileOpen&quot; name=&quot;FileOpen&quot; href=&quot;&quot;> </xref> funksjonen."
  overload: Microsoft.VisualBasic.FileSystem.FreeFile*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Mer enn 255 filer er i bruk."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.GetAttr(System.String)
  id: GetAttr(System.String)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: GetAttr(String)
  nameWithType: FileSystem.GetAttr(String)
  fullName: Microsoft.VisualBasic.FileSystem.GetAttr(String)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Returnerer en <xref uid=&quot;langword_csharp_FileAttribute&quot; name=&quot;FileAttribute&quot; href=&quot;&quot;> </xref> verdi som representerer attributter for en fil, katalog eller mappe. Den <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funksjonen gir deg bedre produktivitet og ytelse i i/u-operasjoner enn <xref uid=&quot;langword_csharp_FileAttribute&quot; name=&quot;FileAttribute&quot; href=&quot;&quot;> </xref>. Hvis du vil ha mer informasjon, se <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "Bruk til å fastslå hvilke attributter som er angitt i `And` til å utføre en bitvis sammenligning av verdien som returneres av den `GetAttr` funksjonen og verdien av attributtet enkeltfil du ønsker. Hvis resultatet ikke er null, er attributtet angitt for den navngitte filen. For eksempel verdien som returneres av følgende `And` uttrykk er null hvis den `Archive` attributtet er ikke angitt: ```vb#   Result = GetAttr(FName) And vbArchive   ``` en nullverdi returneres hvis den `Archive` attributtet er angitt."
  example:
  - "This example uses the `GetAttr` function to determine the attributes of a file and directory or folder.  \n  \n [!code-vb[VbVbalrCatRef#25](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._13_1.vb)]"
  syntax:
    content: public static Microsoft.VisualBasic.FileAttribute GetAttr (string PathName);
    parameters:
    - id: PathName
      type: System.String
      description: "Kreves. <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;></xref>uttrykket som angir en fil, katalog eller mappe. `PathName`kan inkludere mappen eller mappen og stasjonen."
    return:
      type: Microsoft.VisualBasic.FileAttribute
      description: "Verdien som returneres av <xref uid=&quot;langword_csharp_GetAttr&quot; name=&quot;GetAttr&quot; href=&quot;&quot;> </xref> er summen av følgende nummereringsverdier:       <table><tbody><tr><td> Verdi       </td><td> Konstant beskrivelse       </td></tr><tr><td><xref uid=&quot;langword_csharp_Normal&quot; name=&quot;Normal&quot; href=&quot;&quot;></xref></td><td><xref uid=&quot;langword_csharp_vbNormal&quot; name=&quot;vbNormal&quot; href=&quot;&quot;></xref>Vanlig.       </td></tr><tr><td><xref uid=&quot;langword_csharp_ReadOnly&quot; name=&quot;ReadOnly&quot; href=&quot;&quot;></xref></td><td><xref uid=&quot;langword_csharp_vbReadOnly&quot; name=&quot;vbReadOnly&quot; href=&quot;&quot;></xref>Skrivebeskyttet.       </td></tr><tr><td><xref uid=&quot;langword_csharp_Hidden&quot; name=&quot;Hidden&quot; href=&quot;&quot;></xref></td><td><xref uid=&quot;langword_csharp_vbHidden&quot; name=&quot;vbHidden&quot; href=&quot;&quot;></xref>Skjult.       </td></tr><tr><td><xref uid=&quot;langword_csharp_System&quot; name=&quot;System&quot; href=&quot;&quot;></xref></td><td><xref uid=&quot;langword_csharp_vbSystem&quot; name=&quot;vbSystem&quot; href=&quot;&quot;></xref>Systemfil.       </td></tr><tr><td><xref uid=&quot;langword_csharp_Directory&quot; name=&quot;Directory&quot; href=&quot;&quot;></xref></td><td><xref uid=&quot;langword_csharp_vbDirectory&quot; name=&quot;vbDirectory&quot; href=&quot;&quot;></xref>Katalog eller mappe.       </td></tr><tr><td><xref uid=&quot;langword_csharp_Archive&quot; name=&quot;Archive&quot; href=&quot;&quot;></xref></td><td><xref uid=&quot;langword_csharp_vbArchive&quot; name=&quot;vbArchive&quot; href=&quot;&quot;></xref>Filen er endret siden forrige sikkerhetskopiering.       </td></tr><tr><td><xref uid=&quot;langword_csharp_Alias&quot; name=&quot;Alias&quot; href=&quot;&quot;></xref></td><td><xref uid=&quot;langword_csharp_vbAlias&quot; name=&quot;vbAlias&quot; href=&quot;&quot;></xref>Filen har et annet navn.       </td></tr></tbody></table><div class=&quot;alert NOTE&quot;>    Disse opplistinger er angitt i Visual Basic-språket. Navnet kan brukes hvor som helst i koden i stedet for de faktiske verdiene.      </div>"
  overload: Microsoft.VisualBasic.FileSystem.GetAttr*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "<code>Pathname</code>er ugyldig eller inneholder jokertegn."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "Målfilen finnes ikke."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Boolean@)
  id: Input(System.Int32,System.Boolean@)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Input(Int32,Boolean)
  nameWithType: FileSystem.Input(Int32,Boolean)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Boolean)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Leser data fra en åpen sekvensielle fil og tilordner dataene til variabler."
  remarks: "Den `Input` -funksjonen er angitt for bakoverkompatibilitet og kan påvirke ytelsen. For ikke-eldre applikasjoner i `My.Computer.FileSystem` objektet gir bedre ytelse. Hvis du vil ha mer informasjon, se [tilgang til filen med Visual Basic](~/add/includes/ajax-current-ext-md.md).       Data som er lest med `Input` vanligvis skrives til en fil ved hjelp av `Write`. Bruk denne funksjonen bare med filer som er åpnet i `Input` eller `Binary` modus.      > [!IMPORTANT] > Ved lesing fra filer, ikke gjøre beslutninger om innholdet i filen basert på filtypen. For eksempel kan en fil som heter Form1.vb ikke kildefil Visual Basic 2005.       Når lest er standard streng eller numeriske data som tilordnet til variabler uten endring. Tabellen nedenfor viser hvordan andre inndata behandles.      |||   |-|-|   | Data | Verdien som er tilordnet til variabelen |   | Som avgrenser komma eller tom linje | Tom |   | NULL #| `DBNull`|   | TRUE # eller FALSE #| `True` or `False`|   |#`yyyy-mm-dd hh:mm:ss`#| Dato og/eller klokkeslett som er representert av uttrykket |   |#ERROR `errornumber` #| `errornumber` (variabelen er et objekt som er merket som en feil) |       Hvis du kommer til slutten av filen mens du er skrive inn et dataelement, inndataene er stoppet, og det oppstår en feil.      > [!NOTE] > Den `Input` funksjonen er ikke lokalisert. For eksempel i den tyske versjonen returneres hvis du inndata 3,14159, bare 3, fordi komma behandles som variable skilletegn i stedet for som desimaltegn.      > [!IMPORTANT] > Lesing fra en fil ved hjelp av den `Input` funksjonen krever `Read` tilgang fra den `FileIOPermissionAccess` opplisting. Hvis du vil ha mer informasjon, kan du se <xref:System.Security.Permissions.FileIOPermissionAccess>.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `Input` function to read data from a file into two variables. This example assumes that `TestFile` is a file that has some lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: (\"Hello\", 234).  \n  \n [!code-vb[VbVbalrCatRef#35](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._237_1.vb)]"
  syntax:
    content: public static void Input (int FileNumber, ref bool Value);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Kreves. Et gyldig tall."
    - id: Value
      type: System.Boolean
      description: "Kreves. Variabelen som er tilordnet verdiene lest fra filen, kan ikke være en matrise eller et objekt variabel."
  overload: Microsoft.VisualBasic.FileSystem.Input*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Filen er ugyldig."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Byte@)
  id: Input(System.Int32,System.Byte@)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Input(Int32,Byte)
  nameWithType: FileSystem.Input(Int32,Byte)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Byte)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Leser data fra en åpen sekvensielle fil og tilordner dataene til variabler."
  remarks: "Den `Input` -funksjonen er angitt for bakoverkompatibilitet og kan påvirke ytelsen. For ikke-eldre applikasjoner i `My.Computer.FileSystem` objektet gir bedre ytelse. Hvis du vil ha mer informasjon, se [tilgang til filen med Visual Basic](~/add/includes/ajax-current-ext-md.md).       Data som er lest med `Input` vanligvis skrives til en fil ved hjelp av `Write`. Bruk denne funksjonen bare med filer som er åpnet i `Input` eller `Binary` modus.      > [!IMPORTANT] > Ved lesing fra filer, ikke gjøre beslutninger om innholdet i filen basert på filtypen. For eksempel kan en fil som heter Form1.vb ikke kildefil Visual Basic 2005.       Når lest er standard streng eller numeriske data som tilordnet til variabler uten endring. Tabellen nedenfor viser hvordan andre inndata behandles.      |||   |-|-|   | Data | Verdien som er tilordnet til variabelen |   | Som avgrenser komma eller tom linje | Tom |   | NULL #| `DBNull`|   | TRUE # eller FALSE #| `True` or `False`|   |#`yyyy-mm-dd hh:mm:ss`#| Dato og/eller klokkeslett som er representert av uttrykket |   |#ERROR `errornumber` #| `errornumber` (variabelen er et objekt som er merket som en feil) |       Hvis du kommer til slutten av filen mens du er skrive inn et dataelement, inndataene er stoppet, og det oppstår en feil.      > [!NOTE] > Den `Input` funksjonen er ikke lokalisert. For eksempel i den tyske versjonen returneres hvis du inndata 3,14159, bare 3, fordi komma behandles som variable skilletegn i stedet for som desimaltegn.      > [!IMPORTANT] > Lesing fra en fil ved hjelp av den `Input` funksjonen krever `Read` tilgang fra den `FileIOPermissionAccess` opplisting. Hvis du vil ha mer informasjon, kan du se <xref:System.Security.Permissions.FileIOPermissionAccess>.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `Input` function to read data from a file into two variables. This example assumes that `TestFile` is a file that has some lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: (\"Hello\", 234).  \n  \n [!code-vb[VbVbalrCatRef#35](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._73_1.vb)]"
  syntax:
    content: public static void Input (int FileNumber, ref byte Value);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Kreves. Et gyldig tall."
    - id: Value
      type: System.Byte
      description: "Kreves. Variabelen som er tilordnet verdiene lest fra filen, kan ikke være en matrise eller et objekt variabel."
  overload: Microsoft.VisualBasic.FileSystem.Input*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Filen er ugyldig."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Char@)
  id: Input(System.Int32,System.Char@)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Input(Int32,Char)
  nameWithType: FileSystem.Input(Int32,Char)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Char)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Leser data fra en åpen sekvensielle fil og tilordner dataene til variabler."
  remarks: "Den `Input` -funksjonen er angitt for bakoverkompatibilitet og kan påvirke ytelsen. For ikke-eldre applikasjoner i `My.Computer.FileSystem` objektet gir bedre ytelse. Hvis du vil ha mer informasjon, se [tilgang til filen med Visual Basic](~/add/includes/ajax-current-ext-md.md).       Data som er lest med `Input` vanligvis skrives til en fil ved hjelp av `Write`. Bruk denne funksjonen bare med filer som er åpnet i `Input` eller `Binary` modus.      > [!IMPORTANT] > Ved lesing fra filer, ikke gjøre beslutninger om innholdet i filen basert på filtypen. For eksempel kan en fil som heter Form1.vb ikke kildefil Visual Basic 2005.       Når lest er standard streng eller numeriske data som tilordnet til variabler uten endring. Tabellen nedenfor viser hvordan andre inndata behandles.      |||   |-|-|   | Data | Verdien som er tilordnet til variabelen |   | Som avgrenser komma eller tom linje | Tom |   | NULL #| `DBNull`|   | TRUE # eller FALSE #| `True` or `False`|   |#`yyyy-mm-dd hh:mm:ss`#| Dato og/eller klokkeslett som er representert av uttrykket |   |#ERROR `errornumber` #| `errornumber` (variabelen er et objekt som er merket som en feil) |       Hvis du kommer til slutten av filen mens du er skrive inn et dataelement, inndataene er stoppet, og det oppstår en feil.      > [!NOTE] > Den `Input` funksjonen er ikke lokalisert. For eksempel i den tyske versjonen returneres hvis du inndata 3,14159, bare 3, fordi komma behandles som variable skilletegn i stedet for som desimaltegn.      > [!IMPORTANT] > Lesing fra en fil ved hjelp av den `Input` funksjonen krever `Read` tilgang fra den `FileIOPermissionAccess` opplisting. Hvis du vil ha mer informasjon, kan du se <xref:System.Security.Permissions.FileIOPermissionAccess>.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `Input` function to read data from a file into two variables. This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: (\"Hello\", 234).  \n  \n [!code-vb[VbVbalrCatRef#35](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._91_1.vb)]"
  syntax:
    content: public static void Input (int FileNumber, ref char Value);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Kreves. Et gyldig tall."
    - id: Value
      type: System.Char
      description: "Kreves. Variabelen som er tilordnet verdiene lest fra filen, kan ikke være en matrise eller et objekt variabel."
  overload: Microsoft.VisualBasic.FileSystem.Input*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Filen er ugyldig."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.DateTime@)
  id: Input(System.Int32,System.DateTime@)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Input(Int32,DateTime)
  nameWithType: FileSystem.Input(Int32,DateTime)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,DateTime)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Leser data fra en åpen sekvensielle fil og tilordner dataene til variabler."
  remarks: "Den `Input` -funksjonen er angitt for bakoverkompatibilitet og kan påvirke ytelsen. For ikke-eldre applikasjoner i `My.Computer.FileSystem` objektet gir bedre ytelse. Hvis du vil ha mer informasjon, se [tilgang til filen med Visual Basic](~/add/includes/ajax-current-ext-md.md).       Data som er lest med `Input` vanligvis skrives til en fil ved hjelp av `Write`. Bruk denne funksjonen bare med filer som er åpnet i `Input` eller `Binary` modus.      > [!IMPORTANT] > Ved lesing fra filer, ikke gjøre beslutninger om innholdet i filen basert på filtypen. For eksempel kan en fil som heter Form1.vb ikke kildefil Visual Basic 2005.       Når lest er standard streng eller numeriske data som tilordnet til variabler uten endring. Tabellen nedenfor viser hvordan andre inndata behandles.      |||   |-|-|   | Data | Verdien som er tilordnet til variabelen |   | Som avgrenser komma eller tom linje | Tom |   | NULL #| `DBNull`|   | TRUE # eller FALSE #| `True` or `False`|   |#`yyyy-mm-dd hh:mm:ss`#| Dato og/eller klokkeslett som er representert av uttrykket |   |#ERROR `errornumber` #| `errornumber` (variabelen er et objekt som er merket som en feil) |       Hvis du kommer til slutten av filen mens du er skrive inn et dataelement, inndataene er stoppet, og det oppstår en feil.      > [!NOTE] > Den `Input` funksjonen er ikke lokalisert. For eksempel i den tyske versjonen returneres hvis du inndata 3,14159, bare 3, fordi komma behandles som variable skilletegn i stedet for som desimaltegn.      > [!IMPORTANT] > Lesing fra en fil ved hjelp av den `Input` funksjonen krever `Read` tilgang fra den `FileIOPermissionAccess` opplisting. Hvis du vil ha mer informasjon, kan du se <xref:System.Security.Permissions.FileIOPermissionAccess>.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `Input` function to read data from a file into two variables. This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: (\"Hello\", 234).  \n  \n [!code-vb[VbVbalrCatRef#35](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._169_1.vb)]"
  syntax:
    content: public static void Input (int FileNumber, ref DateTime Value);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Kreves. Et gyldig tall."
    - id: Value
      type: System.DateTime
      description: "Kreves. Variabelen som er tilordnet verdiene lest fra filen, kan ikke være en matrise eller et objekt variabel."
  overload: Microsoft.VisualBasic.FileSystem.Input*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Filen er ugyldig."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Decimal@)
  id: Input(System.Int32,System.Decimal@)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Input(Int32,Decimal)
  nameWithType: FileSystem.Input(Int32,Decimal)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Decimal)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Leser data fra en åpen sekvensielle fil og tilordner dataene til variabler."
  remarks: "Den `Input` -funksjonen er angitt for bakoverkompatibilitet og kan påvirke ytelsen. For ikke-eldre applikasjoner i `My.Computer.FileSystem` objektet gir bedre ytelse. Hvis du vil ha mer informasjon, se [tilgang til filen med Visual Basic](~/add/includes/ajax-current-ext-md.md).       Data som er lest med `Input` vanligvis skrives til en fil ved hjelp av `Write`. Bruk denne funksjonen bare med filer som er åpnet i `Input` eller `Binary` modus.      > [!IMPORTANT] > Ved lesing fra filer, ikke gjøre beslutninger om innholdet i filen basert på filtypen. For eksempel kan en fil som heter Form1.vb ikke kildefil Visual Basic 2005.       Når lest er standard streng eller numeriske data som tilordnet til variabler uten endring. Tabellen nedenfor viser hvordan andre inndata behandles.      |||   |-|-|   | Data | Verdien som er tilordnet til variabelen |   | Som avgrenser komma eller tom linje | Tom |   | NULL #| `DBNull`|   | TRUE # eller FALSE #| `True` or `False`|   |#`yyyy-mm-dd hh:mm:ss`#| Dato og/eller klokkeslett som er representert av uttrykket |   |#ERROR `errornumber` #| `errornumber` (variabelen er et objekt som er merket som en feil) |       Hvis du kommer til slutten av filen mens du er skrive inn et dataelement, inndataene er stoppet, og det oppstår en feil.      > [!NOTE] > Den `Input` funksjonen er ikke lokalisert. For eksempel i den tyske versjonen returneres hvis du inndata 3,14159, bare 3, fordi komma behandles som variable skilletegn i stedet for som desimaltegn.      > [!IMPORTANT] > Lesing fra en fil ved hjelp av den `Input` funksjonen krever `Read` tilgang fra den `FileIOPermissionAccess` opplisting. Hvis du vil ha mer informasjon, kan du se <xref:System.Security.Permissions.FileIOPermissionAccess>.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `Input` function to read data from a file into two variables. This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: (\"Hello\", 234).  \n  \n [!code-vb[VbVbalrCatRef#35](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._46_1.vb)]"
  syntax:
    content: public static void Input (int FileNumber, ref decimal Value);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Kreves. Et gyldig tall."
    - id: Value
      type: System.Decimal
      description: "Kreves. Variabelen som er tilordnet verdiene lest fra filen, kan ikke være en matrise eller et objekt variabel."
  overload: Microsoft.VisualBasic.FileSystem.Input*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Filen er ugyldig."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Double@)
  id: Input(System.Int32,System.Double@)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Input(Int32,Double)
  nameWithType: FileSystem.Input(Int32,Double)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Double)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Leser data fra en åpen sekvensielle fil og tilordner dataene til variabler."
  remarks: "Den `Input` -funksjonen er angitt for bakoverkompatibilitet og kan påvirke ytelsen. For ikke-eldre applikasjoner i `My.Computer.FileSystem` objektet gir bedre ytelse. Hvis du vil ha mer informasjon, se [tilgang til filen med Visual Basic](~/add/includes/ajax-current-ext-md.md).       Data som er lest med `Input` vanligvis skrives til en fil ved hjelp av `Write`. Bruk denne funksjonen bare med filer som er åpnet i `Input` eller `Binary` modus.      > [!IMPORTANT] > Ved lesing fra filer, ikke gjøre beslutninger om innholdet i filen basert på filtypen. For eksempel kan en fil som heter Form1.vb ikke kildefil Visual Basic 2005.       Når lest er standard streng eller numeriske data som tilordnet til variabler uten endring. Tabellen nedenfor viser hvordan andre inndata behandles.      |||   |-|-|   | Data | Verdien som er tilordnet til variabelen |   | Som avgrenser komma eller tom linje | Tom |   | NULL #| `DBNull`|   | TRUE # eller FALSE #| `True` or `False`|   |#`yyyy-mm-dd hh:mm:ss`#| Dato og/eller klokkeslett som er representert av uttrykket |   |#ERROR `errornumber` #| `errornumber` (variabelen er et objekt som er merket som en feil) |       Hvis du kommer til slutten av filen mens du er skrive inn et dataelement, inndataene er stoppet, og det oppstår en feil.      > [!NOTE] > Den `Input` funksjonen er ikke lokalisert. For eksempel i den tyske versjonen returneres hvis du inndata 3,14159, bare 3, fordi komma behandles som variable skilletegn i stedet for som desimaltegn.      > [!IMPORTANT] > Lesing fra en fil ved hjelp av den `Input` funksjonen krever `Read` tilgang fra den `FileIOPermissionAccess` opplisting. Hvis du vil ha mer informasjon, kan du se <xref:System.Security.Permissions.FileIOPermissionAccess>.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `Input` function to read data from a file into two variables. This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: (\"Hello\", 234).  \n  \n [!code-vb[VbVbalrCatRef#35](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._204_1.vb)]"
  syntax:
    content: public static void Input (int FileNumber, ref double Value);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Kreves. Et gyldig tall."
    - id: Value
      type: System.Double
      description: "Kreves. Variabelen som er tilordnet verdiene lest fra filen, kan ikke være en matrise eller et objekt variabel."
  overload: Microsoft.VisualBasic.FileSystem.Input*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Filen er ugyldig."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int16@)
  id: Input(System.Int32,System.Int16@)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Input(Int32,Int16)
  nameWithType: FileSystem.Input(Int32,Int16)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Int16)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Leser data fra en åpen sekvensielle fil og tilordner dataene til variabler."
  remarks: "Den `Input` -funksjonen er angitt for bakoverkompatibilitet og kan påvirke ytelsen. For ikke-eldre applikasjoner i `My.Computer.FileSystem` objektet gir bedre ytelse. Hvis du vil ha mer informasjon, se [tilgang til filen med Visual Basic](~/add/includes/ajax-current-ext-md.md).       Data som er lest med `Input` vanligvis skrives til en fil ved hjelp av `Write`. Bruk denne funksjonen bare med filer som er åpnet i `Input` eller `Binary` modus.      > [!IMPORTANT] > Ved lesing fra filer, ikke gjøre beslutninger om innholdet i filen basert på filtypen. For eksempel kan en fil som heter Form1.vb ikke kildefil Visual Basic 2005.       Når lest er standard streng eller numeriske data som tilordnet til variabler uten endring. Tabellen nedenfor viser hvordan andre inndata behandles.      |||   |-|-|   | Data | Verdien som er tilordnet til variabelen |   | Som avgrenser komma eller tom linje | Tom |   | NULL #| `DBNull`|   | TRUE # eller FALSE #| `True` or `False`|   |#`yyyy-mm-dd hh:mm:ss`#| Dato og/eller klokkeslett som er representert av uttrykket |   |#ERROR `errornumber` #| `errornumber` (variabelen er et objekt som er merket som en feil) |       Hvis du kommer til slutten av filen mens du er skrive inn et dataelement, inndataene er stoppet, og det oppstår en feil.      > [!NOTE] > Den `Input` funksjonen er ikke lokalisert. For eksempel i den tyske versjonen returneres hvis du inndata 3,14159, bare 3, fordi komma behandles som variable skilletegn i stedet for som desimaltegn.      > [!IMPORTANT] > Lesing fra en fil ved hjelp av den `Input` funksjonen krever `Read` tilgang fra den `FileIOPermissionAccess` opplisting. Hvis du vil ha mer informasjon, kan du se <xref:System.Security.Permissions.FileIOPermissionAccess>.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `Input` function to read data from a file into two variables. This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: (\"Hello\", 234).  \n  \n [!code-vb[VbVbalrCatRef#35](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._81_1.vb)]"
  syntax:
    content: public static void Input (int FileNumber, ref short Value);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Kreves. Et gyldig tall."
    - id: Value
      type: System.Int16
      description: "Kreves. Variabelen som er tilordnet verdiene lest fra filen, kan ikke være en matrise eller et objekt variabel."
  overload: Microsoft.VisualBasic.FileSystem.Input*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Filen er ugyldig."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int32@)
  id: Input(System.Int32,System.Int32@)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Input(Int32,Int32)
  nameWithType: FileSystem.Input(Int32,Int32)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Int32)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Leser data fra en åpen sekvensielle fil og tilordner dataene til variabler."
  remarks: "Den `Input` -funksjonen er angitt for bakoverkompatibilitet og kan påvirke ytelsen. For ikke-eldre applikasjoner i `My.Computer.FileSystem` objektet gir bedre ytelse. Hvis du vil ha mer informasjon, se [tilgang til filen med Visual Basic](~/add/includes/ajax-current-ext-md.md).       Data som er lest med `Input` vanligvis skrives til en fil ved hjelp av `Write`. Bruk denne funksjonen bare med filer som er åpnet i `Input` eller `Binary` modus.      > [!IMPORTANT] > Ved lesing fra filer, ikke gjøre beslutninger om innholdet i filen basert på filtypen. For eksempel kan en fil som heter Form1.vb ikke kildefil Visual Basic 2005.       Når lest er standard streng eller numeriske data som tilordnet til variabler uten endring. Tabellen nedenfor viser hvordan andre inndata behandles.      |||   |-|-|   | Data | Verdien som er tilordnet til variabelen |   | Som avgrenser komma eller tom linje | Tom |   | NULL #| `DBNull`|   | TRUE # eller FALSE #| `True` or `False`|   |#`yyyy-mm-dd hh:mm:ss`#| Dato og/eller klokkeslett som er representert av uttrykket |   |#ERROR `errornumber` #| `errornumber` (variabelen er et objekt som er merket som en feil) |       Hvis du kommer til slutten av filen mens du er skrive inn et dataelement, inndataene er stoppet, og det oppstår en feil.      > [!NOTE] > Den `Input` funksjonen er ikke lokalisert. For eksempel i den tyske versjonen returneres hvis du inndata 3,14159, bare 3, fordi komma behandles som variable skilletegn i stedet for som desimaltegn.      > [!IMPORTANT] > Lesing fra en fil ved hjelp av den `Input` funksjonen krever `Read` tilgang fra den `FileIOPermissionAccess` opplisting. Hvis du vil ha mer informasjon, kan du se <xref:System.Security.Permissions.FileIOPermissionAccess>.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `Input` function to read data from a file into two variables. This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: (\"Hello\", 234).  \n  \n [!code-vb[VbVbalrCatRef#35](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._207_1.vb)]"
  syntax:
    content: public static void Input (int FileNumber, ref int Value);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Kreves. Et gyldig tall."
    - id: Value
      type: System.Int32
      description: "Kreves. Variabelen som er tilordnet verdiene lest fra filen, kan ikke være en matrise eller et objekt variabel."
  overload: Microsoft.VisualBasic.FileSystem.Input*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Filen er ugyldig."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int64@)
  id: Input(System.Int32,System.Int64@)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Input(Int32,Int64)
  nameWithType: FileSystem.Input(Int32,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Leser data fra en åpen sekvensielle fil og tilordner dataene til variabler."
  remarks: "Den `Input` -funksjonen er angitt for bakoverkompatibilitet og kan påvirke ytelsen. For ikke-eldre applikasjoner i `My.Computer.FileSystem` objektet gir bedre ytelse. Hvis du vil ha mer informasjon, se [tilgang til filen med Visual Basic](~/add/includes/ajax-current-ext-md.md).       Data som er lest med `Input` vanligvis skrives til en fil ved hjelp av `Write`. Bruk denne funksjonen bare med filer som er åpnet i `Input` eller `Binary` modus.      > [!IMPORTANT] > Ved lesing fra filer, ikke gjøre beslutninger om innholdet i filen basert på filtypen. For eksempel kan en fil som heter Form1.vb ikke kildefil Visual Basic 2005.       Når lest er standard streng eller numeriske data som tilordnet til variabler uten endring. Tabellen nedenfor viser hvordan andre inndata behandles.      |||   |-|-|   | Data | Verdien som er tilordnet til variabelen |   | Som avgrenser komma eller tom linje | Tom |   | NULL #| `DBNull`|   | TRUE # eller FALSE #| `True` or `False`|   |#`yyyy-mm-dd hh:mm:ss`#| Dato og/eller klokkeslett som er representert av uttrykket |   |#ERROR `errornumber` #| `errornumber` (variabelen er et objekt som er merket som en feil) |       Hvis du kommer til slutten av filen mens du er skrive inn et dataelement, inndataene er stoppet, og det oppstår en feil.      > [!NOTE] > Den `Input` funksjonen er ikke lokalisert. For eksempel i den tyske versjonen returneres hvis du inndata 3,14159, bare 3, fordi komma behandles som variable skilletegn i stedet for som desimaltegn.      > [!IMPORTANT] > Lesing fra en fil ved hjelp av den `Input` funksjonen krever `Read` tilgang fra den `FileIOPermissionAccess` opplisting. Hvis du vil ha mer informasjon, kan du se <xref:System.Security.Permissions.FileIOPermissionAccess>.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `Input` function to read data from a file into two variables. This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: (\"Hello\", 234).  \n  \n [!code-vb[VbVbalrCatRef#35](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._31_1.vb)]"
  syntax:
    content: public static void Input (int FileNumber, ref long Value);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Kreves. Et gyldig tall."
    - id: Value
      type: System.Int64
      description: "Kreves. Variabelen som er tilordnet verdiene lest fra filen, kan ikke være en matrise eller et objekt variabel."
  overload: Microsoft.VisualBasic.FileSystem.Input*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Filen er ugyldig."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Object@)
  id: Input(System.Int32,System.Object@)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Input(Int32,Object)
  nameWithType: FileSystem.Input(Int32,Object)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Object)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Leser data fra en åpen sekvensielle fil og tilordner dataene til variabler."
  remarks: "Den `Input` -funksjonen er angitt for bakoverkompatibilitet og kan påvirke ytelsen. For ikke-eldre applikasjoner i `My.Computer.FileSystem` objektet gir bedre ytelse. Hvis du vil ha mer informasjon, se [tilgang til filen med Visual Basic](~/add/includes/ajax-current-ext-md.md).       Data som er lest med `Input` vanligvis skrives til en fil ved hjelp av `Write`. Bruk denne funksjonen bare med filer som er åpnet i `Input` eller `Binary` modus.      > [!IMPORTANT] > Ved lesing fra filer, ikke gjøre beslutninger om innholdet i filen basert på filtypen. For eksempel kan en fil som heter Form1.vb ikke kildefil Visual Basic 2005.       Når lest er standard streng eller numeriske data som tilordnet til variabler uten endring. Tabellen nedenfor viser hvordan andre inndata behandles.      |||   |-|-|   | Data | Verdien som er tilordnet til variabelen |   | Som avgrenser komma eller tom linje | Tom |   | NULL #| `DBNull`|   | TRUE # eller FALSE #| `True` or `False`|   |#`yyyy-mm-dd hh:mm:ss`#| Dato og/eller klokkeslett som er representert av uttrykket |   |#ERROR `errornumber` #| `errornumber` (variabelen er et objekt som er merket som en feil) |       Hvis du kommer til slutten av filen mens du er skrive inn et dataelement, inndataene er stoppet, og det oppstår en feil.      > [!NOTE] > Den `Input` funksjonen er ikke lokalisert. For eksempel i den tyske versjonen returneres hvis du inndata 3,14159, bare 3, fordi komma behandles som variable skilletegn i stedet for som desimaltegn.      > [!IMPORTANT] > Lesing fra en fil ved hjelp av den `Input` funksjonen krever `Read` tilgang fra den `FileIOPermissionAccess` opplisting. Hvis du vil ha mer informasjon, kan du se <xref:System.Security.Permissions.FileIOPermissionAccess>.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `Input` function to read data from a file into two variables. This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: (\"Hello\", 234).  \n  \n [!code-vb[VbVbalrCatRef#35](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._244_1.vb)]"
  syntax:
    content: public static void Input (int FileNumber, ref object Value);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Kreves. Et gyldig tall."
    - id: Value
      type: System.Object
      description: "Kreves. Variabelen som er tilordnet verdiene lest fra filen, kan ikke være en matrise eller et objekt variabel."
  overload: Microsoft.VisualBasic.FileSystem.Input*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Filen er ugyldig."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Single@)
  id: Input(System.Int32,System.Single@)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Input(Int32,Single)
  nameWithType: FileSystem.Input(Int32,Single)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Single)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Leser data fra en åpen sekvensielle fil og tilordner dataene til variabler."
  remarks: "Den `Input` -funksjonen er angitt for bakoverkompatibilitet og kan påvirke ytelsen. For ikke-eldre applikasjoner i `My.Computer.FileSystem` objektet gir bedre ytelse. Hvis du vil ha mer informasjon, se [tilgang til filen med Visual Basic](~/add/includes/ajax-current-ext-md.md).       Data som er lest med `Input` vanligvis skrives til en fil ved hjelp av `Write`. Bruk denne funksjonen bare med filer som er åpnet i `Input` eller `Binary` modus.      > [!IMPORTANT] > Ved lesing fra filer, ikke gjøre beslutninger om innholdet i filen basert på filtypen. For eksempel kan en fil som heter Form1.vb ikke kildefil Visual Basic 2005.       Når lest er standard streng eller numeriske data som tilordnet til variabler uten endring. Tabellen nedenfor viser hvordan andre inndata behandles.      |||   |-|-|   | Data | Verdien som er tilordnet til variabelen |   | Som avgrenser komma eller tom linje | Tom |   | NULL #| `DBNull`|   | TRUE # eller FALSE #| `True` or `False`|   |#`yyyy-mm-dd hh:mm:ss`#| Dato og/eller klokkeslett som er representert av uttrykket |   |#ERROR `errornumber` #| `errornumber` (variabelen er et objekt som er merket som en feil) |       Hvis du kommer til slutten av filen mens du er skrive inn et dataelement, inndataene er stoppet, og det oppstår en feil.      > [!NOTE] > Den `Input` funksjonen er ikke lokalisert. For eksempel i den tyske versjonen returneres hvis du inndata 3,14159, bare 3, fordi komma behandles som variable skilletegn i stedet for som desimaltegn.      > [!IMPORTANT] > Lesing fra en fil ved hjelp av den `Input` funksjonen krever `Read` tilgang fra den `FileIOPermissionAccess` opplisting. Hvis du vil ha mer informasjon, kan du se <xref:System.Security.Permissions.FileIOPermissionAccess>.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `Input` function to read data from a file into two variables. This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: (\"Hello\", 234).  \n  \n [!code-vb[VbVbalrCatRef#35](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._115_1.vb)]"
  syntax:
    content: public static void Input (int FileNumber, ref float Value);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Kreves. Et gyldig tall."
    - id: Value
      type: System.Single
      description: "Kreves. Variabelen som er tilordnet verdiene lest fra filen, kan ikke være en matrise eller et objekt variabel."
  overload: Microsoft.VisualBasic.FileSystem.Input*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Filen er ugyldig."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.String@)
  id: Input(System.Int32,System.String@)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Input(Int32,String)
  nameWithType: FileSystem.Input(Int32,String)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,String)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Leser data fra en åpen sekvensielle fil og tilordner dataene til variabler."
  remarks: "Den `Input` -funksjonen er angitt for bakoverkompatibilitet og kan påvirke ytelsen. For ikke-eldre applikasjoner i `My.Computer.FileSystem` objektet gir bedre ytelse. Hvis du vil ha mer informasjon, se [tilgang til filen med Visual Basic](~/add/includes/ajax-current-ext-md.md).       Data som er lest med `Input` vanligvis skrives til en fil ved hjelp av `Write`. Bruk denne funksjonen bare med filer som er åpnet i `Input` eller `Binary` modus.      > [!IMPORTANT] > Ved lesing fra filer, ikke gjøre beslutninger om innholdet i filen basert på filtypen. For eksempel kan en fil som heter Form1.vb ikke kildefil Visual Basic 2005.       Når lest er standard streng eller numeriske data som tilordnet til variabler uten endring. Tabellen nedenfor viser hvordan andre inndata behandles.      |||   |-|-|   | Data | Verdien som er tilordnet til variabelen |   | Som avgrenser komma eller tom linje | Tom |   | NULL #| `DBNull`|   | TRUE # eller FALSE #| `True` or `False`|   |#`yyyy-mm-dd hh:mm:ss`#| Dato og/eller klokkeslett som er representert av uttrykket |   |#ERROR `errornumber` #| `errornumber` (variabelen er et objekt som er merket som en feil) |       Hvis du kommer til slutten av filen mens du er skrive inn et dataelement, inndataene er stoppet, og det oppstår en feil.      > [!NOTE] > Den `Input` funksjonen er ikke lokalisert. For eksempel i den tyske versjonen returneres hvis du inndata 3,14159, bare 3, fordi komma behandles som variable skilletegn i stedet for som desimaltegn.      > [!IMPORTANT] > Lesing fra en fil ved hjelp av den `Input` funksjonen krever `Read` tilgang fra den `FileIOPermissionAccess` opplisting. Hvis du vil ha mer informasjon, kan du se <xref:System.Security.Permissions.FileIOPermissionAccess>.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `Input` function to read data from a file into two variables. This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: (\"Hello\", 234).  \n  \n [!code-vb[VbVbalrCatRef#35](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._140_1.vb)]"
  syntax:
    content: public static void Input (int FileNumber, ref string Value);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Kreves. Et gyldig tall."
    - id: Value
      type: System.String
      description: "Kreves. Variabelen som er tilordnet verdiene lest fra filen, kan ikke være en matrise eller et objekt variabel."
  overload: Microsoft.VisualBasic.FileSystem.Input*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Filen er ugyldig."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)
  id: InputString(System.Int32,System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: InputString(Int32,Int32)
  nameWithType: FileSystem.InputString(Int32,Int32)
  fullName: Microsoft.VisualBasic.FileSystem.InputString(Int32,Int32)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Returnerer <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;> </xref> verdi som inneholder tegn fra en fil som er åpnet i <xref uid=&quot;langword_csharp_Input&quot; name=&quot;Input&quot; href=&quot;&quot;> </xref> eller <xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> modus. Den <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funksjonen gir deg bedre produktivitet og ytelse i i/u-operasjoner enn <xref uid=&quot;langword_csharp_InputString&quot; name=&quot;InputString&quot; href=&quot;&quot;> </xref>. Hvis du vil ha mer informasjon, se <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "Den `InputString` -funksjonen er angitt for bakoverkompatibilitet og kan påvirke ytelsen. For ikke-eldre applikasjoner i `My.Computer.FileSystem` objektet gir bedre ytelse. Hvis du vil ha mer informasjon, se [tilgang til filen med Visual Basic](~/add/includes/ajax-current-ext-md.md).       Data lest med den `InputString` funksjon vanligvis skrives til en fil ved hjelp av `Print` eller `FilePut`. Bruk denne funksjonen bare med filer som er åpnet i `Input` eller `Binary` modus.       I motsetning til det `Input` -funksjonen, den `InputString` -funksjonen returnerer alle tegnene leses. Dette omfatter komma, linjeskift, linjeskift, anførselstegn og innledende mellomrom.       Med filer som er åpnet `Binary` tilgang til et forsøk på å lese gjennom filen ved hjelp av den `InputString` fungere før `EOF` returnerer `True` genererer en feil. Bruk av `LOF` og `Loc` fungerer i stedet for `EOF` når du lese binære filer ved hjelp av `InputString`, eller Bruk `FileGet` når du bruker den `EOF` funksjonen.      > [!NOTE] > Ved lesing fra filer, ikke gjøre sikkerhet beslutninger om innholdet i filen basert på filtypen. For eksempel kan en fil med navnet Form1.vb ikke kildefil Visual Basic."
  example:
  - "This example uses the `InputString` function to read one character at a time from a file and print it to the `Output` window. This example assumes that `MyFile` is a text file that has several lines of sample data.  \n  \n [!code-vb[VbVbalrCatRef#33](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._220_1.vb)]"
  syntax:
    content: public static string InputString (int FileNumber, int CharCount);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Kreves. Et gyldig tall."
    - id: CharCount
      type: System.Int32
      description: "Kreves. Et gyldig numerisk uttrykk som angir hvor mange tegn som skal leses."
    return:
      type: System.String
      description: "Returnerer <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;> </xref> verdi som inneholder tegn fra en fil som er åpnet i <xref uid=&quot;langword_csharp_Input&quot; name=&quot;Input&quot; href=&quot;&quot;> </xref> eller <xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> modus. Den <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funksjonen gir deg bedre produktivitet og ytelse i i/u-operasjoner enn <xref uid=&quot;langword_csharp_InputString&quot; name=&quot;InputString&quot; href=&quot;&quot;> </xref>."
  overload: Microsoft.VisualBasic.FileSystem.InputString*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "<code>FileNumber</code>finnes ikke."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>CharCount</code>&lt; 0 or &gt; 214."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Kill(System.String)
  id: Kill(System.String)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Kill(String)
  nameWithType: FileSystem.Kill(String)
  fullName: Microsoft.VisualBasic.FileSystem.Kill(String)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Sletter filer fra en disk. Den <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funksjonen gir deg bedre produktivitet og ytelse i i/u-operasjoner enn <xref uid=&quot;langword_csharp_Kill&quot; name=&quot;Kill&quot; href=&quot;&quot;> </xref>. Hvis du vil ha mer informasjon, se <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref> ."
  remarks: "`Kill`støtter bruk av flere tegn (`*`) og ett tegn (`?`) jokertegn å angi flere filer.       **Obs!** for å utføre, den `Kill` funksjonen krever `Read` og `PathDiscovery` flagg for <xref:System.Security.Permissions.FileIOPermission>skal gis til koden som kjører.</xref:System.Security.Permissions.FileIOPermission> Hvis du vil ha mer informasjon, kan du se <xref:System.Security.SecurityException> [kode tilgangstillatelser](http://msdn.microsoft.com/en-us/e5ae402f-6dda-4732-bbe8-77296630f675)</xref:System.Security.SecurityException>"
  example:
  - "This example uses the `Kill` function to delete a file from a disk.  \n  \n [!code-vb[VbVbalrCatRef#60](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._250_1.vb)]"
  syntax:
    content: public static void Kill (string PathName);
    parameters:
    - id: PathName
      type: System.String
      description: "Kreves. <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;></xref>uttrykket som angir én eller flere filnavn som skal slettes. `PathName`kan inkludere mappen eller mappen og stasjonen."
  overload: Microsoft.VisualBasic.FileSystem.Kill*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Target-filene åpne."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "Finner ikke target-filer."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "Ingen tilgang."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.LineInput(System.Int32)
  id: LineInput(System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: LineInput(Int32)
  nameWithType: FileSystem.LineInput(Int32)
  fullName: Microsoft.VisualBasic.FileSystem.LineInput(Int32)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Leser en enkelt linje fra en åpen sekvensielle fil og tilordne den til en <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;> </xref> variabel."
  remarks: "Den `LineInput` -funksjonen er angitt for bakoverkompatibilitet og kan påvirke ytelsen. For ikke-eldre applikasjoner i `My.Computer.FileSystem` objektet gir bedre ytelse. Hvis du vil ha mer informasjon, se [tilgang til filen med Visual Basic](~/add/includes/ajax-current-ext-md.md).       Data som er lest med `LineInput` vanligvis skrives til en fil ved hjelp av `Print`.      > [!IMPORTANT] > Ved lesing fra filer, ikke ta beslutninger om innholdet av en fil basert på filtypen. For eksempel kan en fil som heter Form1.vb ikke kildefil Visual Basic.       Den `LineInput` funksjonen leser fra en fil ett tegn på en gang til det kommer linjeskift (`Chr(`13`)`) eller vognretur retur/linje feeden (`Chr(`13`)` + `Chr(`10`)`) rekkefølge. Vognretur retur/linje feed sekvenser hoppes over i stedet for legges til tegnstrengen.      > [!IMPORTANT] > Lesing fra en fil ved hjelp av den `LineInput` funksjonen krever `Read` tilgang fra den <xref:System.Security.Permissions.FileIOPermissionAccess>opplisting.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `LineInput` function to read a line from a sequential file and assign it to a variable. This example assumes that `TestFile` is a text file that has several lines of sample data.  \n  \n [!code-vb[VbVbalrCatRef#19](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._158_1.vb)]"
  syntax:
    content: public static string LineInput (int FileNumber);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Kreves. Et gyldig tall."
    return:
      type: System.String
      description: "Leser en enkelt linje fra en åpen sekvensielle fil og tilordne den til en <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;> </xref> variabel."
  overload: Microsoft.VisualBasic.FileSystem.LineInput*
  exceptions:
  - type: System.IO.EndOfStreamException
    commentId: T:System.IO.EndOfStreamException
    description: "Nådde slutten av filen."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "<code>FileNumber</code>finnes ikke."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Loc(System.Int32)
  id: Loc(System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Loc(Int32)
  nameWithType: FileSystem.Loc(Int32)
  fullName: Microsoft.VisualBasic.FileSystem.Loc(Int32)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Returnerer en <xref uid=&quot;langword_csharp_Long&quot; name=&quot;Long&quot; href=&quot;&quot;> </xref> verdi som angir posisjonen for lese-og skrivetilgang i en åpen fil."
  remarks: "Den `Loc` funksjonen er nullbasert; bruker den til å hente den første byten i en fil returnere 0.       Den `Loc` -funksjonen er angitt for bakoverkompatibilitet og kan påvirke ytelsen. For ikke-eldre applikasjoner i `My.Computer.FileSystem` objektet gir bedre ytelse. Hvis du vil ha mer informasjon, se [tilgang til filen med Visual Basic](~/add/includes/ajax-current-ext-md.md).       Nedenfor beskrives returverdien for hver filtilgangsmodus: |||   |-|-|   | Modus | Returverdi |   | `Random`| Siste postnummeret lese fra eller skrive til filen. |   | `Sequential`| Gjeldende byte posisjon i filen dividert 128. Informasjonen som returneres av `Loc` for sekvensielle filer, verken brukes eller kreves. |   | `Binary`| Posisjonen for den siste byten lese eller skrive. |"
  example:
  - "This example uses the `Loc` function to return the current read/write position in an open file. This example assumes that `MyFile` is a text file that has several lines of sample data.  \n  \n [!code-vb[VbVbalrCatRef#17](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._178_1.vb)]"
  syntax:
    content: public static long Loc (int FileNumber);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Kreves. Et gyldig <xref uid=&quot;langword_csharp_Integer&quot; name=&quot;Integer&quot; href=&quot;&quot;> </xref> filnummer."
    return:
      type: System.Int64
      description: "Returnerer en <xref uid=&quot;langword_csharp_Long&quot; name=&quot;Long&quot; href=&quot;&quot;> </xref> verdi som angir posisjonen for lese-og skrivetilgang i en åpen fil."
  overload: Microsoft.VisualBasic.FileSystem.Loc*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Filen er ugyldig."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Lock(System.Int32)
  id: Lock(System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Lock(Int32)
  nameWithType: FileSystem.Lock(Int32)
  fullName: Microsoft.VisualBasic.FileSystem.Lock(Int32)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Kontrollerer tilgang av andre prosesser for hele eller deler av en fil som er åpnet ved hjelp av den <xref uid=&quot;langword_csharp_Open&quot; name=&quot;Open&quot; href=&quot;&quot;> </xref> funksjonen. Den <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funksjonen gir deg bedre produktivitet og ytelse i i/u-operasjoner enn <xref uid=&quot;langword_csharp_Lock&quot; name=&quot;Lock&quot; href=&quot;&quot;> </xref> og <xref uid=&quot;langword_csharp_Unlock&quot; name=&quot;Unlock&quot; href=&quot;&quot;> </xref>. Hvis du vil ha mer informasjon, se <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "Den `Lock` og `Unlock` funksjoner er brukt i miljøer der flere prosesser trenger tilgang til den samme filen.       `Lock`og `Unlock` er alltid brukes i par. Argumentene til `Lock` og `Unlock` må være identiske.       Hvis `Record`, eller `FromRecord` og `ToRecord` er ikke angitt, blir låsen for hele filen. Hvis `Record` alene er angitt i én post blir låses/frigis.       Hvis filen er åpnet for sekvensielle inndata eller utdata, `Lock` og `Unlock` påvirke hele filen, uavhengig av området som angis av `FromRecord` og`ToRecord`."
  example:
  - "This example illustrates the use of the `Lock` and `Unlock` functions. This example assumes that `People.txt` is a file that contains records of the structure `Person`.  \n  \n [!code-vb[VbVbalrCatRef#13](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._243_1.vb)]"
  syntax:
    content: public static void Lock (int FileNumber);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Kreves. Et gyldig tall."
  overload: Microsoft.VisualBasic.FileSystem.Lock*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Filen er ugyldig."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Lock(System.Int32,System.Int64)
  id: Lock(System.Int32,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Lock(Int32,Int64)
  nameWithType: FileSystem.Lock(Int32,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.Lock(Int32,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Kontrollerer tilgang av andre prosesser for hele eller deler av en fil som er åpnet ved hjelp av den <xref uid=&quot;langword_csharp_Open&quot; name=&quot;Open&quot; href=&quot;&quot;> </xref> funksjonen. Den <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funksjonen gir deg bedre produktivitet og ytelse i i/u-operasjoner enn <xref uid=&quot;langword_csharp_Lock&quot; name=&quot;Lock&quot; href=&quot;&quot;> </xref> og <xref uid=&quot;langword_csharp_Unlock&quot; name=&quot;Unlock&quot; href=&quot;&quot;> </xref>. Hvis du vil ha mer informasjon, se <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "Den `Lock` og `Unlock` funksjoner er brukt i miljøer der flere prosesser trenger tilgang til den samme filen.       `Lock`og `Unlock` er alltid brukes i par. Argumentene til `Lock` og `Unlock` må være identiske.       Hvis `Record`, eller `FromRecord` og `ToRecord` er ikke angitt, blir låsen for hele filen. Hvis `Record` alene er angitt i én post blir låses/frigis.       Hvis filen er åpnet for sekvensielle inndata eller utdata, `Lock` og `Unlock` påvirke hele filen, uavhengig av området som angis av `FromRecord` og`ToRecord`."
  example:
  - "This example illustrates the use of the `Lock` and `Unlock` functions. This example assumes that `People.txt` is a file that contains records of the structure `Person`.  \n  \n [!code-vb[VbVbalrCatRef#13](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._38_1.vb)]"
  syntax:
    content: public static void Lock (int FileNumber, long Record);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Kreves. Et gyldig tall."
    - id: Record
      type: System.Int64
      description: "Valgfritt. Antall den eneste post eller byte til låsing eller opplåsing av"
  overload: Microsoft.VisualBasic.FileSystem.Lock*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Filen er ugyldig."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Lock(System.Int32,System.Int64,System.Int64)
  id: Lock(System.Int32,System.Int64,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Lock(Int32,Int64,Int64)
  nameWithType: FileSystem.Lock(Int32,Int64,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.Lock(Int32,Int64,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Kontrollerer tilgang av andre prosesser for hele eller deler av en fil som er åpnet ved hjelp av den <xref uid=&quot;langword_csharp_Open&quot; name=&quot;Open&quot; href=&quot;&quot;> </xref> funksjonen. Den <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funksjonen gir deg bedre produktivitet og ytelse i i/u-operasjoner enn <xref uid=&quot;langword_csharp_Lock&quot; name=&quot;Lock&quot; href=&quot;&quot;> </xref> og <xref uid=&quot;langword_csharp_Unlock&quot; name=&quot;Unlock&quot; href=&quot;&quot;> </xref>. Hvis du vil ha mer informasjon, se <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "Den `Lock` og `Unlock` funksjoner er brukt i miljøer der flere prosesser trenger tilgang til den samme filen.       `Lock`og `Unlock` er alltid brukes i par. Argumentene til `Lock` og `Unlock` må være identiske.       Hvis `Record`, eller `FromRecord` og `ToRecord` er ikke angitt, blir låsen for hele filen. Hvis `Record` alene er angitt i én post blir låses/frigis.       Hvis filen er åpnet for sekvensielle inndata eller utdata, `Lock` og `Unlock` påvirke hele filen, uavhengig av området som angis av `FromRecord` og`ToRecord`."
  example:
  - "This example illustrates the use of the `Lock` and `Unlock` functions. This example assumes that `People.txt` is a file that contains records of the structure `Person`.  \n  \n [!code-vb[VbVbalrCatRef#13](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._116_1.vb)]"
  syntax:
    content: public static void Lock (int FileNumber, long FromRecord, long ToRecord);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Kreves. Et gyldig tall."
    - id: FromRecord
      type: System.Int64
      description: "Valgfritt. Antall første posten eller byte til låsing eller opplåsing av."
    - id: ToRecord
      type: System.Int64
      description: "Valgfritt. Antall siste posten eller byte til låsing eller opplåsing av."
  overload: Microsoft.VisualBasic.FileSystem.Lock*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Filen er ugyldig."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.LOF(System.Int32)
  id: LOF(System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: LOF(Int32)
  nameWithType: FileSystem.LOF(Int32)
  fullName: Microsoft.VisualBasic.FileSystem.LOF(Int32)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Returnerer en <xref uid=&quot;langword_csharp_Long&quot; name=&quot;Long&quot; href=&quot;&quot;> </xref> som representerer størrelsen, i byte av en fil åpnet ved hjelp av den <xref uid=&quot;langword_csharp_FileOpen&quot; name=&quot;FileOpen&quot; href=&quot;&quot;> </xref> funksjonen. Den <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funksjonen gir deg bedre produktivitet og ytelse i i/u-operasjoner enn <xref uid=&quot;langword_csharp_LOF&quot; name=&quot;LOF&quot; href=&quot;&quot;> </xref>. Hvis du vil ha mer informasjon, se <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "Bruk av `FileLen` funksjonen til å hente lengden på en fil som ikke er åpen."
  example:
  - "This example uses the `LOF` function to determine the size of an open file. This example assumes that `TestFile` is a text file that contains sample data.  \n  \n [!code-vb[VbVbalrCatRef#23](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._83_1.vb)]"
  syntax:
    content: public static long LOF (int FileNumber);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Kreves. En <xref uid=&quot;langword_csharp_Integer&quot; name=&quot;Integer&quot; href=&quot;&quot;> </xref> som inneholder et ugyldig filnummer."
    return:
      type: System.Int64
      description: "Returnerer en <xref uid=&quot;langword_csharp_Long&quot; name=&quot;Long&quot; href=&quot;&quot;> </xref> som representerer størrelsen, i byte av en fil åpnet ved hjelp av den <xref uid=&quot;langword_csharp_FileOpen&quot; name=&quot;FileOpen&quot; href=&quot;&quot;> </xref> funksjonen. Den <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funksjonen gir deg bedre produktivitet og ytelse i i/u-operasjoner enn <xref uid=&quot;langword_csharp_LOF&quot; name=&quot;LOF&quot; href=&quot;&quot;> </xref>."
  overload: Microsoft.VisualBasic.FileSystem.LOF*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Filen er ugyldig."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.MkDir(System.String)
  id: MkDir(System.String)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: MkDir(String)
  nameWithType: FileSystem.MkDir(String)
  fullName: Microsoft.VisualBasic.FileSystem.MkDir(String)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Oppretter en ny mappe. Den <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funksjonen gir deg bedre produktivitet og ytelse i i/u-operasjoner enn <xref uid=&quot;langword_csharp_MkDir&quot; name=&quot;MkDir&quot; href=&quot;&quot;> </xref>. Hvis du vil ha mer informasjon, kan du se <xref:Microsoft.VisualBasic.FileIO.FileSystem.CreateDirectory*>.</xref:Microsoft.VisualBasic.FileIO.FileSystem.CreateDirectory*>"
  remarks: "Denne funksjonen oppretter en ny mappe."
  example:
  - "This example uses the `MkDir` function to create a directory. If the drive is not specified, the new directory is created on the current drive.  \n  \n [!code-vb[VbVbalrCatRef#38](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._246_1.vb)]"
  syntax:
    content: public static void MkDir (string Path);
    parameters:
    - id: Path
      type: System.String
      description: "Kreves. <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;></xref>uttrykk som identifiserer mappen som skal opprettes. Den `Path` kan inneholde stasjonen. Hvis ingen stasjon er angitt, <xref uid=&quot;langword_csharp_MkDir&quot; name=&quot;MkDir&quot; href=&quot;&quot;> </xref> oppretter ny mappe på gjeldende stasjon."
  overload: Microsoft.VisualBasic.FileSystem.MkDir*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>Path</code>er ikke angitt eller er tom."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "Ingen tilgang."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Mappen finnes allerede."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])
  id: Print(System.Int32,System.Object[])
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Print(Int32,Object[])
  nameWithType: FileSystem.Print(Int32,Object[])
  fullName: Microsoft.VisualBasic.FileSystem.Print(Int32,Object[])
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Skriver formatert som viser data i en sekvensiell fil."
  remarks: "Den `Print` og `PrintLine` funksjoner er angitt for bakoverkompatibilitet og kan påvirke ytelsen. For ikke-eldre applikasjoner i `My.Computer.FileSystem` objektet gir bedre ytelse. Hvis du vil ha mer informasjon, se [tilgang til filen med Visual Basic](~/add/includes/ajax-current-ext-md.md).       `Print`ikke Inkluder linjeskifttegn på slutten av linjen. imidlertid `PrintLine` omfatter linjeskifttegn.       Data som skrives med `Print` vanligvis lese fra en fil ved hjelp av `LineInput` eller `Input`.       Hvis du utelater `Output` for `PrintLine`, en tom linje skrives til filen, for `Print`, ingenting er utdata. Flere uttrykk atskilt med komma justeres på fanen grensene, men blande komma og `TAB` kan føre til inkonsekvente resultater.       For `Boolean` dataene, enten `True` eller `False` skrives. Den `True` og `False` nøkkelord er ikke oversatt, uavhengig av den nasjonale innstillingen.       Date-data skrives til filen ved hjelp av standard korte datoformatet gjenkjennes av systemet. Når dato eller Klokkeslettkomponenten mangler eller null, bare delen angitt skrives til filen.       Ingenting er skrevet til filen hvis `Output` dataene er tom. Men hvis `Output` listen dataene `DBNull`, `Null` er skrevet til filen.       For `Error` dataene, utdataene vises som `Error errorcode`. Den `Error` nøkkelordet oversettes ikke uavhengig av den nasjonale innstillingen.       Alle data som er skrevet til filen ved hjelp av `Print` er internasjonal; som er dataene er riktig formatert med riktig desimaltegnet. Hvis brukeren vil ha utdata for bruk av flere nasjonale `Write` som skal brukes.       Skriving til en fil ved hjelp av den `Print` eller `PrintLine` funksjoner krever `Write` tilgang fra den `FileIOPermissionAccess` opplisting. Hvis du vil ha mer informasjon, kan du se <xref:System.Security.Permissions.FileIOPermissionAccess>.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `Print` and `PrintLine` functions to write data to a file.  \n  \n [!code-vb[VbVbalrCatRef#53](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._146_1.vb)]"
  syntax:
    content: public static void Print (int FileNumber, object[] Output);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Kreves. Et gyldig tall."
    - id: Output
      type: System.Object[]
      description: "Valgfritt. Null eller flere kommadelt uttrykk til å skrive til en fil.       Den `Output` innstillingene-argumentet er: <xref uid=&quot;langword_csharp_T:System.IO.IOException&quot; name=&quot;T:System.IO.IOException&quot; href=&quot;&quot;> </xref>: fil-modus er ugyldig.       <xref uid=&quot;langword_csharp_T:System.IO.IOException&quot; name=&quot;T:System.IO.IOException&quot; href=&quot;&quot;></xref>: `FileNumber` finnes ikke."
  overload: Microsoft.VisualBasic.FileSystem.Print*
  exceptions: []
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])
  id: PrintLine(System.Int32,System.Object[])
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: PrintLine(Int32,Object[])
  nameWithType: FileSystem.PrintLine(Int32,Object[])
  fullName: Microsoft.VisualBasic.FileSystem.PrintLine(Int32,Object[])
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Skriver formatert som viser data i en sekvensiell fil."
  remarks: "Den `Print` og `PrintLine` funksjoner er angitt for bakoverkompatibilitet og kan påvirke ytelsen. For ikke-eldre applikasjoner i `My.Computer.FileSystem` objektet gir bedre ytelse. Hvis du vil ha mer informasjon, se [tilgang til filen med Visual Basic](~/add/includes/ajax-current-ext-md.md).       `Print`ikke Inkluder linjeskifttegn på slutten av linjen. imidlertid`PrintLine` omfatter linjeskifttegn.       Data som skrives med `Print` vanligvis lese fra en fil ved hjelp av `LineInput` eller `Input`.       Hvis du utelater `Output` for `PrintLine`, en tom linje skrives til filen, for `Print`, ingenting er utdata. Flere uttrykk atskilt med komma justeres på fanen grensene, men blande komma og `TAB` kan føre til inkonsekvente resultater.       For `Boolean` dataene, enten `True` eller `False` skrives. Den `True` og `False` nøkkelord er ikke oversatt, uavhengig av den nasjonale innstillingen.       Datodata skrives til filen ved hjelp av standard korte datoformatet gjenkjent av systemet. Når dato eller Klokkeslettkomponenten mangler eller null, bare delen angitt skrives til filen.       Ingenting er skrevet til filen hvis `Output` dataene er tom. Men hvis `Output` listen dataene `DBNull`, `Null` er skrevet til filen.       For `Error` dataene, utdataene vises som `Error errorcode`. Den `Error` nøkkelordet oversettes ikke uavhengig av den nasjonale innstillingen.       Alle data som er skrevet til filen ved hjelp av `Print` er internasjonal; som er dataene er riktig formatert med riktig desimaltegnet. Hvis brukeren vil ha utdata for bruk av flere nasjonale `Write` som skal brukes.       Skriving til en fil ved hjelp av den `Print` eller `PrintLine` funksjoner krever `Write` tilgang fra den `FileIOPermissionAccess` opplisting. Hvis du vil ha mer informasjon, kan du se <xref:System.Security.Permissions.FileIOPermissionAccess>.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `Print` and `PrintLine` functions to write data to a file.  \n  \n [!code-vb[VbVbalrCatRef#53](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._245_1.vb)]"
  syntax:
    content: public static void PrintLine (int FileNumber, object[] Output);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Kreves. Et gyldig tall."
    - id: Output
      type: System.Object[]
      description: "Valgfritt. Null eller flere kommadelt uttrykk til å skrive til en fil.       Den `Output` innstillingene-argumentet er: <xref uid=&quot;langword_csharp_T:System.IO.IOException&quot; name=&quot;T:System.IO.IOException&quot; href=&quot;&quot;> </xref>: fil-modus er ugyldig.       <xref uid=&quot;langword_csharp_T:System.IO.IOException&quot; name=&quot;T:System.IO.IOException&quot; href=&quot;&quot;></xref>: `FileNumber` finnes ikke."
  overload: Microsoft.VisualBasic.FileSystem.PrintLine*
  exceptions: []
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Rename(System.String,System.String)
  id: Rename(System.String,System.String)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Rename(String,String)
  nameWithType: FileSystem.Rename(String,String)
  fullName: Microsoft.VisualBasic.FileSystem.Rename(String,String)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Endrer navn på en diskfil eller mappe. Den <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funksjonen gir deg bedre produktivitet og ytelse i i/u-operasjoner enn <xref uid=&quot;langword_csharp_Rename&quot; name=&quot;Rename&quot; href=&quot;&quot;> </xref>. Hvis du vil ha mer informasjon, se <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "Den`Rename` funksjonen endrer navn på en fil og flyttes til en annen katalog Hvis det er nødvendig. Den `Rename` funksjon kan flytte en fil på tvers av stasjoner, men den kan bare gi nytt navn til en eksisterende mappe når både `NewPath` og `OldPath` ligger på samme stasjon. `Rename`kan ikke opprette en ny fil eller mappe.       Ved hjelp av den `Rename` funksjonen på en åpen fil produserer en feil. Du må lukke en åpen fil før du endrer navnet på den. `Rename`argumenter kan ikke inneholde flere tegn (*) og ett tegn (?) jokertegn.      > [!IMPORTANT] > Ved `Rename` for å kopiere en fil fra en ubeskyttet plasseringen til en beskyttet plassering, beholder filen mindre begrenset rettigheter. Kontroller at du ikke er introduserer en mulig sikkerhetsrisiko."
  example:
  - "This example uses the `Rename` function to rename a file. For purposes of this example, assume that the directories that are specified already exist.  \n  \n [!code-vb[VbVbalrCatRef#30](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._97_1.vb)]"
  syntax:
    content: public static void Rename (string OldPath, string NewPath);
    parameters:
    - id: OldPath
      type: System.String
      description: "Kreves. <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;></xref>uttrykket som angir eksisterende filnavnet og plasseringen. `OldPath`kan inkludere mappen og stasjonen av filen."
    - id: NewPath
      type: System.String
      description: "Kreves. <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;></xref>uttrykket som angir nytt filnavn og plassering. `NewPath`kan inkludere mappen og stasjonen til målplasseringen. Angitt filnavn av `NewPath` kan ikke finnes."
  overload: Microsoft.VisualBasic.FileSystem.Rename*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Banen er ugyldig."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>OldPath</code>filen finnes ikke."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Kan ikke gi nytt navn til en annen enhet."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Reset
  id: Reset
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Reset()
  nameWithType: FileSystem.Reset()
  fullName: Microsoft.VisualBasic.FileSystem.Reset()
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Lukker alle disken filer som åpnes ved bruk av <xref uid=&quot;langword_csharp_FileOpen&quot; name=&quot;FileOpen&quot; href=&quot;&quot;> </xref> funksjonen. Den <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funksjonen gir deg bedre produktivitet og ytelse i i/u-operasjoner enn <xref uid=&quot;langword_csharp_Reset&quot; name=&quot;Reset&quot; href=&quot;&quot;> </xref>. Hvis du vil ha mer informasjon, se <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "Den `Reset` funksjonen lukker alle aktive filer som åpnes av den `FileOpen` funksjonen og har samme funksjon som `FileClose()` uten parametere."
  example:
  - "This example uses the `Reset` function to close all open files and write the contents of all file buffers to disk. Note the use of the `Object` variable `FileNumber` as both a string and a number.  \n  \n [!code-vb[VbVbalrCatRef#12](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._117_1.vb)]"
  syntax:
    content: public static void Reset ();
    parameters: []
  overload: Microsoft.VisualBasic.FileSystem.Reset*
  exceptions: []
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.RmDir(System.String)
  id: RmDir(System.String)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: RmDir(String)
  nameWithType: FileSystem.RmDir(String)
  fullName: Microsoft.VisualBasic.FileSystem.RmDir(String)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Fjerner en eksisterende mappe. Den <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funksjonen gir deg bedre produktivitet og ytelse i i/u-operasjoner enn <xref uid=&quot;langword_csharp_RmDir&quot; name=&quot;RmDir&quot; href=&quot;&quot;> </xref>. Hvis du vil ha mer informasjon, kan du se <xref:Microsoft.VisualBasic.FileIO.FileSystem.DeleteDirectory*>.</xref:Microsoft.VisualBasic.FileIO.FileSystem.DeleteDirectory*>"
  remarks: "Oppstår en feil hvis du prøver å bruke `RmDir` i en katalog som inneholder filer. Bruk av `Kill` funksjon for å slette alle filer før du prøver å fjerne en mappe."
  example:
  - "This example uses the `RmDir` function to remove an existing directory.  \n  \n [!code-vb[VbVbalrCatRef#31](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._20_1.vb)]"
  syntax:
    content: public static void RmDir (string Path);
    parameters:
    - id: Path
      type: System.String
      description: "Kreves. <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;></xref>uttrykk som identifiserer katalog eller mappe som skal fjernes. `Path`kan inkludere stasjonen. Hvis ingen stasjon er angitt, <xref uid=&quot;langword_csharp_RmDir&quot; name=&quot;RmDir&quot; href=&quot;&quot;> </xref> fjerner mappe på gjeldende stasjon."
  overload: Microsoft.VisualBasic.FileSystem.RmDir*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>Path</code>er ikke angitt eller er tom."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Målmappen inneholder filer."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "Mappen finnes ikke."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Seek(System.Int32)
  id: Seek(System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Seek(Int32)
  nameWithType: FileSystem.Seek(Int32)
  fullName: Microsoft.VisualBasic.FileSystem.Seek(Int32)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Returnerer en <xref uid=&quot;langword_csharp_Long&quot; name=&quot;Long&quot; href=&quot;&quot;> </xref> angir gjeldende skrivetilgang plasseringen i en fil åpnet ved hjelp av den <xref uid=&quot;langword_csharp_FileOpen&quot; name=&quot;FileOpen&quot; href=&quot;&quot;> </xref> funksjon eller angir plasseringen for neste skrivetilgang operasjon i en fil som er åpnet ved hjelp av den <xref uid=&quot;langword_csharp_FileOpen&quot; name=&quot;FileOpen&quot; href=&quot;&quot;> </xref> funksjonen. Den <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funksjonen gir deg bedre produktivitet og ytelse i i/u-operasjoner enn <xref uid=&quot;langword_csharp_Seek&quot; name=&quot;Seek&quot; href=&quot;&quot;> </xref>. Hvis du vil ha mer informasjon, se <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`Seek`Returnerer en verdi mellom 1 og 2 147 483 647 (samme som 2 ^ 31 – 1), med.       Nedenfor beskrives returverdier for hver filtilgangsmodus: |||   |-|-|   | Modus | Returverdi |   | `Random`| Antall neste post lese eller skrive |   | `Binary`, `Input`, `Output`, `Append`| Byte posisjonen der neste operasjon oppstår. Den første byten i en fil fra posisjon 1, den andre byten er i posisjon 2 og så videre. |"
  example:
  - "This example uses the `Seek` function to return the current file position. The example assumes `TestFile` is a file that contains records of the structure `Record`.  \n  \n [!code-vb[VbVbalrCatRef#47](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._100_1.vb)]  \n  \n For files opened in `Random` mode, `Seek` returns the number of next record.  \n  \n [!code-vb[VbVbalrCatRef#48](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._100_2.vb)]  \n  \n For files opened in modes other than `Random` mode, `Seek` returns the byte position at which the next operation occurs. Assume `TestFile` is a file that contains several lines of text.  \n  \n [!code-vb[VbVbalrCatRef#49](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._100_3.vb)]  \n  \n This example uses the `Seek` function to set the position for the next read or write in a file.  \n  \n For files opened in modes other than `Random` mode, `Seek` sets the byte position at which the next operation occurs. Assume `TestFile` is a file that contains several lines of text.  \n  \n [!code-vb[VbVbalrCatRef#52](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._100_4.vb)]"
  syntax:
    content: public static long Seek (int FileNumber);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Kreves. En <xref uid=&quot;langword_csharp_Integer&quot; name=&quot;Integer&quot; href=&quot;&quot;> </xref> som inneholder et ugyldig filnummer."
    return:
      type: System.Int64
      description: "Returnerer en <xref uid=&quot;langword_csharp_Long&quot; name=&quot;Long&quot; href=&quot;&quot;> </xref> angir gjeldende skrivetilgang plasseringen i en fil åpnet ved hjelp av den <xref uid=&quot;langword_csharp_FileOpen&quot; name=&quot;FileOpen&quot; href=&quot;&quot;> </xref> funksjon eller angir plasseringen for neste skrivetilgang operasjon i en fil som er åpnet ved hjelp av den <xref uid=&quot;langword_csharp_FileOpen&quot; name=&quot;FileOpen&quot; href=&quot;&quot;> </xref> funksjonen."
  overload: Microsoft.VisualBasic.FileSystem.Seek*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Filen er ugyldig."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Seek(System.Int32,System.Int64)
  id: Seek(System.Int32,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Seek(Int32,Int64)
  nameWithType: FileSystem.Seek(Int32,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.Seek(Int32,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Returnerer en <xref uid=&quot;langword_csharp_Long&quot; name=&quot;Long&quot; href=&quot;&quot;> </xref> angir gjeldende skrivetilgang plasseringen i en fil åpnet ved hjelp av den <xref uid=&quot;langword_csharp_FileOpen&quot; name=&quot;FileOpen&quot; href=&quot;&quot;> </xref> funksjon eller angir plasseringen for neste skrivetilgang operasjon i en fil som er åpnet ved hjelp av den <xref uid=&quot;langword_csharp_FileOpen&quot; name=&quot;FileOpen&quot; href=&quot;&quot;> </xref> funksjonen. Den <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funksjonen gir deg bedre produktivitet og ytelse i i/u-operasjoner enn <xref uid=&quot;langword_csharp_Seek&quot; name=&quot;Seek&quot; href=&quot;&quot;> </xref>. Hvis du vil ha mer informasjon, se <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`Seek`Returnerer en verdi mellom 1 og 2 147 483 647 (samme som 2 ^ 31 – 1), med.       Nedenfor beskrives returverdier for hver filtilgangsmodus: |||   |-|-|   | Modus | Returverdi |   | `Random`| Antall neste post lese eller skrive |   | `Binary`, `Input`, `Output`, `Append`| Byte posisjonen der neste operasjon oppstår. Den første byten i en fil fra posisjon 1, den andre byten er i posisjon 2 og så videre. |"
  example:
  - "This example uses the `Seek` function to return the current file position. The example assumes `TestFile` is a file that contains records of the structure `Record`.  \n  \n [!code-vb[VbVbalrCatRef#47](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._51_1.vb)]  \n  \n For files opened in `Random` mode, `Seek` returns the number of next record.  \n  \n [!code-vb[VbVbalrCatRef#48](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._51_2.vb)]  \n  \n For files opened in modes other than `Random` mode, `Seek` returns the byte position at which the next operation occurs. Assume `TestFile` is a file that contains several lines of text.  \n  \n [!code-vb[VbVbalrCatRef#49](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._51_3.vb)]  \n  \n This example uses the `Seek` function to set the position for the next read or write in a file.  \n  \n For files opened in modes other than `Random` mode, `Seek` sets the byte position at which the next operation occurs. Assume `TestFile` is a file that contains several lines of text.  \n  \n [!code-vb[VbVbalrCatRef#52](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._51_4.vb)]"
  syntax:
    content: public static void Seek (int FileNumber, long Position);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Kreves. En <xref uid=&quot;langword_csharp_Integer&quot; name=&quot;Integer&quot; href=&quot;&quot;> </xref> som inneholder et ugyldig filnummer."
    - id: Position
      type: System.Int64
      description: "Kreves. Tallet i området 1 – 2 147 483 647, med, som angir hvor neste skrivetilgang operasjonen skal utføres."
  overload: Microsoft.VisualBasic.FileSystem.Seek*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Filen er ugyldig."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.SetAttr(System.String,Microsoft.VisualBasic.FileAttribute)
  id: SetAttr(System.String,Microsoft.VisualBasic.FileAttribute)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: SetAttr(String,FileAttribute)
  nameWithType: FileSystem.SetAttr(String,FileAttribute)
  fullName: Microsoft.VisualBasic.FileSystem.SetAttr(String,FileAttribute)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Angir attributtet informasjon om en fil. Den <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funksjonen gir deg bedre produktivitet og ytelse i i/u-operasjoner enn <xref uid=&quot;langword_csharp_SetAttr&quot; name=&quot;SetAttr&quot; href=&quot;&quot;> </xref>. Hvis du vil ha mer informasjon, se <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "En kjøretidsfeil oppstår hvis du prøver å angi attributter for en åpen fil.       Den `Attributes` argumentet nummereringsverdier er som følger: |||   |-|-|-|   | Verdien | Konstant | Beskrivelse |   | `Normal`|`vbNormal`| Normal (standard). |   | `ReadOnly`|`vbReadOnly`| Skrivebeskyttet. |   | `Hidden`|`vbHidden`| Skjult. |   | `System`|`vbSystem`| Systemfil. |   | `Volume`|`vbVolume`| Volumnavnet |   | `Directory`|`vbDirectory`| Katalog eller mappe. |   | `Archive`|`vbArchive`| Filen er endret siden forrige sikkerhetskopiering. |   | `Alias`|`vbAlias`| Filen har et annet navn. |      > [!NOTE] > Disse opplistinger er angitt i Visual Basic-språket. Navnet kan brukes hvor som helst i koden i stedet for de faktiske verdiene."
  example:
  - "This example uses the `SetAttr` function to set attributes for a file.  \n  \n [!code-vb[VbVbalrCatRef#14](~/add/codesnippet/visualbasic/7c37826d-7b37-4e2d-b69a-_1.vb)]"
  syntax:
    content: public static void SetAttr (string PathName, Microsoft.VisualBasic.FileAttribute Attributes);
    parameters:
    - id: PathName
      type: System.String
      description: "Kreves. <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;></xref>uttrykket som angir et filnavn. `PathName`kan inneholde katalog eller mappe, og stasjon."
    - id: Attributes
      type: Microsoft.VisualBasic.FileAttribute
      description: "Kreves. Konstant eller numerisk uttrykk som inneholder summen angir filattributter."
  overload: Microsoft.VisualBasic.FileSystem.SetAttr*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>Attribute</code>typen er ugyldig."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.SPC(System.Int16)
  id: SPC(System.Int16)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: SPC(Int16)
  nameWithType: FileSystem.SPC(Int16)
  fullName: Microsoft.VisualBasic.FileSystem.SPC(Int16)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Brukes med den <xref uid=&quot;langword_csharp_Print&quot; name=&quot;Print&quot; href=&quot;&quot;> </xref> eller <xref uid=&quot;langword_csharp_PrintLine&quot; name=&quot;PrintLine&quot; href=&quot;&quot;> </xref> funksjon for å plassere utdata."
  remarks: "Hvis `Count` er mindre enn den utdata linjetykkelsen i flytter umiddelbart etterfølger antall mellomrom som skrives ut. Hvis`Count` er større enn linjebredden utdata `SPC` beregner den flytter formelen: `currentprintposition`(+ (`Count``Mod``width`)) Hvis den gjeldende flytter er 24, linjebredden utdata er 80 og du angi For eksempel `SPC(`90`)`, starter neste utskrift ved posisjon 34 (gjeldende flytter + resten av 90/80). Hvis forskjellen mellom gjeldende trykt posisjon og linjebredden utdata er mindre enn `Count` (eller `Count` `Mod` *bredden*), `SPC` funksjon til starten av den neste linjen og genererer mellomrom som er lik `Count` – (*bredden* – *gjeldendeutskriftsposisjon*).      > [!NOTE] > Kontroller tabellkolonnene er stor nok til å tillate bred bokstaver."
  example:
  - "This example uses the `SPC` function to position output in a file and in the **Output** window.  \n  \n [!code-vb[VbVbalrCatRef#16](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._222_1.vb)]"
  syntax:
    content: public static Microsoft.VisualBasic.SpcInfo SPC (short Count);
    parameters:
    - id: Count
      type: System.Int16
      description: "Kreves. Antall mellomrom som skal settes inn før visning eller utskrift neste uttrykk i en liste."
    return:
      type: Microsoft.VisualBasic.SpcInfo
      description: "Brukes med den <xref uid=&quot;langword_csharp_Print&quot; name=&quot;Print&quot; href=&quot;&quot;> </xref> eller <xref uid=&quot;langword_csharp_PrintLine&quot; name=&quot;PrintLine&quot; href=&quot;&quot;> </xref> funksjon for å plassere utdata."
  overload: Microsoft.VisualBasic.FileSystem.SPC*
  exceptions: []
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.TAB
  id: TAB
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: TAB()
  nameWithType: FileSystem.TAB()
  fullName: Microsoft.VisualBasic.FileSystem.TAB()
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Brukes med den <xref uid=&quot;langword_csharp_Print&quot; name=&quot;Print&quot; href=&quot;&quot;> </xref> eller <xref uid=&quot;langword_csharp_PrintLine&quot; name=&quot;PrintLine&quot; href=&quot;&quot;> </xref> funksjoner til å plassere utdata."
  remarks: "Hvis det gjeldende flytter på gjeldende linje er større enn `Column`, `TAB` hopper over til verdien i kolonnen som er lik `Column` på neste utdatalinje. Hvis `Column` er mindre enn 1 `TAB` flytter print posisjonen til kolonne 1. Hvis `Column` er større enn linjebredden utdata `TAB` beregner den flytter formelen: kolonnen REST bredde For eksempel hvis *bredden* er 80 og du angir `TAB(`90`)`, starter den neste utskriften ved kolonne 10 (resten av 90/80). Hvis `Column` er mindre enn den gjeldende print posisjonen, utskrift starter på den neste linjen posisjonen beregnede Skriv ut. Hvis de beregnede flytter er større enn gjeldende trykt posisjon, utskrift starter på den beregnede Skriv ut posisjon på samme linje.       Den lengst til venstre flytter på en output-linje er alltid 1. Når du bruker den `Print` eller `PrintLine` funksjoner til å skrive til filer, skrive ut lengst er gjeldende bredde for utdatafilen, som du kan angi ved hjelp av `FileWidth` funksjonen.       Den `TAB` funksjonen kan også brukes med den `WriteLine` funksjonen. Det kan ikke brukes med <xref:System.Diagnostics.Debug.WriteLine%2A?displayProperty=fullName>eller <xref:System.Console.WriteLine%2A?displayProperty=fullName>.</xref:System.Console.WriteLine%2A?displayProperty=fullName> </xref:System.Diagnostics.Debug.WriteLine%2A?displayProperty=fullName>      > [!NOTE] > Kontroller tabellkolonnene er stor nok til å inneholde bred bokstaver."
  example:
  - "This example uses the `TAB` function to position output in a file and in the **Output** window.  \n  \n [!code-vb[VbVbalrCatRef#37](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._165_1.vb)]"
  syntax:
    content: public static Microsoft.VisualBasic.TabInfo TAB ();
    parameters: []
    return:
      type: Microsoft.VisualBasic.TabInfo
      description: "Brukes med den <xref uid=&quot;langword_csharp_Print&quot; name=&quot;Print&quot; href=&quot;&quot;> </xref> eller <xref uid=&quot;langword_csharp_PrintLine&quot; name=&quot;PrintLine&quot; href=&quot;&quot;> </xref> funksjoner til å plassere utdata."
  overload: Microsoft.VisualBasic.FileSystem.TAB*
  exceptions: []
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.TAB(System.Int16)
  id: TAB(System.Int16)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: TAB(Int16)
  nameWithType: FileSystem.TAB(Int16)
  fullName: Microsoft.VisualBasic.FileSystem.TAB(Int16)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Brukes med den <xref uid=&quot;langword_csharp_Print&quot; name=&quot;Print&quot; href=&quot;&quot;> </xref> eller <xref uid=&quot;langword_csharp_PrintLine&quot; name=&quot;PrintLine&quot; href=&quot;&quot;> </xref> funksjoner til å plassere utdata."
  remarks: "Hvis den gjeldende flytter på gjeldende linje er større enn `Column`, `TAB` hopper over til verdien i kolonnen som er lik `Column` på neste utdatalinje. Hvis `Column` er mindre enn 1 `TAB` flytter print posisjonen til kolonne 1. Hvis `Column` er større enn linjebredden utdata `TAB` beregner den flytter formelen: kolonnen REST bredde For eksempel hvis *bredden* er 80 og du angir `TAB(`90`)`, starter neste utskrift ved kolonne 10 (resten av 90/80). Hvis `Column` er mindre enn den gjeldende print posisjonen, utskrift starter på den neste linjen posisjonen beregnede Skriv ut. Hvis de beregnede flytter er større enn gjeldende trykt posisjon, utskrift starter på den beregnede Skriv ut posisjon på samme linje.       Den lengst til venstre flytter på en output-linje er alltid 1. Når du bruker den `Print` eller `PrintLine` funksjoner til å skrive til filer, skrive ut lengst er gjeldende bredde for utdatafilen, som du kan angi ved hjelp av `FileWidth` funksjonen.       Den `TAB` funksjonen kan også brukes med den `WriteLine` funksjonen. Det kan ikke brukes med <xref:System.Diagnostics.Debug.WriteLine%2A?displayProperty=fullName>eller <xref:System.Console.WriteLine%2A?displayProperty=fullName>.</xref:System.Console.WriteLine%2A?displayProperty=fullName> </xref:System.Diagnostics.Debug.WriteLine%2A?displayProperty=fullName>      > [!NOTE] > Kontroller tabellkolonnene er stor nok til å inneholde bred bokstaver."
  example:
  - "This example uses the `TAB` function to position output in a file and in the **Output** window.  \n  \n [!code-vb[VbVbalrCatRef#37](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._125_1.vb)]"
  syntax:
    content: public static Microsoft.VisualBasic.TabInfo TAB (short Column);
    parameters:
    - id: Column
      type: System.Int16
      description: "Valgfritt. Antall kolonner flyttes til før visning og utskrift neste uttrykk i en liste. Hvis den utelates, <xref uid=&quot;langword_csharp_TAB&quot; name=&quot;TAB&quot; href=&quot;&quot;> </xref> flytter pekeren til starten av neste print sonen."
    return:
      type: Microsoft.VisualBasic.TabInfo
      description: "Brukes med den <xref uid=&quot;langword_csharp_Print&quot; name=&quot;Print&quot; href=&quot;&quot;> </xref> eller <xref uid=&quot;langword_csharp_PrintLine&quot; name=&quot;PrintLine&quot; href=&quot;&quot;> </xref> funksjoner til å plassere utdata."
  overload: Microsoft.VisualBasic.FileSystem.TAB*
  exceptions: []
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Unlock(System.Int32)
  id: Unlock(System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Unlock(Int32)
  nameWithType: FileSystem.Unlock(Int32)
  fullName: Microsoft.VisualBasic.FileSystem.Unlock(Int32)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Kontrollerer tilgang av andre prosesser for hele eller deler av en fil som er åpnet ved hjelp av den <xref uid=&quot;langword_csharp_Open&quot; name=&quot;Open&quot; href=&quot;&quot;> </xref> funksjonen. Den <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funksjonen gir deg bedre produktivitet og ytelse i i/u-operasjoner enn <xref uid=&quot;langword_csharp_Lock&quot; name=&quot;Lock&quot; href=&quot;&quot;> </xref> og <xref uid=&quot;langword_csharp_Unlock&quot; name=&quot;Unlock&quot; href=&quot;&quot;> </xref>. Hvis du vil ha mer informasjon, se <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "Den `Lock` og `Unlock` funksjoner er brukt i miljøer der flere prosesser trenger tilgang til den samme filen.       `Lock`og `Unlock` er alltid brukes i par. Argumentene til `Lock` og `Unlock` må være identiske.       Hvis `Record`, eller `FromRecord` og `ToRecord` er ikke angitt, blir låsen for hele filen. Hvis `Record` alene er angitt i én post blir låses/frigis.       Hvis filen er åpnet for sekvensielle inndata eller utdata, `Lock` og `Unlock` påvirke hele filen, uavhengig av området som angis av `FromRecord` og`ToRecord`."
  example:
  - "This example illustrates the use of the `Lock` and `Unlock` functions. This example assumes that `People.txt` is a file that contains records of the structure `Person`.  \n  \n [!code-vb[VbVbalrCatRef#13](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._26_1.vb)]"
  syntax:
    content: public static void Unlock (int FileNumber);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Kreves. Et gyldig tall."
  overload: Microsoft.VisualBasic.FileSystem.Unlock*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Filen er ugyldig."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Unlock(System.Int32,System.Int64)
  id: Unlock(System.Int32,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Unlock(Int32,Int64)
  nameWithType: FileSystem.Unlock(Int32,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.Unlock(Int32,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Kontrollerer tilgang av andre prosesser for hele eller deler av en fil som er åpnet ved hjelp av den <xref uid=&quot;langword_csharp_Open&quot; name=&quot;Open&quot; href=&quot;&quot;> </xref> funksjonen. Den <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funksjonen gir deg bedre produktivitet og ytelse i i/u-operasjoner enn <xref uid=&quot;langword_csharp_Lock&quot; name=&quot;Lock&quot; href=&quot;&quot;> </xref> og <xref uid=&quot;langword_csharp_Unlock&quot; name=&quot;Unlock&quot; href=&quot;&quot;> </xref>. Hvis du vil ha mer informasjon, se <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "Den `Lock` og `Unlock` funksjoner er brukt i miljøer der flere prosesser trenger tilgang til den samme filen.       `Lock`og `Unlock` er alltid brukes i par. Argumentene til `Lock` og `Unlock` må være identiske.       Hvis `Record`, eller `FromRecord` og `ToRecord` er ikke angitt, blir låsen for hele filen. Hvis `Record` alene er angitt i én post blir låses/frigis.       Hvis filen er åpnet for sekvensielle inndata eller utdata, `Lock` og `Unlock` påvirke hele filen, uavhengig av området som angis av `FromRecord` og`ToRecord`."
  example:
  - "This example illustrates the use of the `Lock` and `Unlock` functions. This example assumes that `People.txt` is a file that contains records of the structure `Person`.  \n  \n [!code-vb[VbVbalrCatRef#13](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._210_1.vb)]"
  syntax:
    content: public static void Unlock (int FileNumber, long Record);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Kreves. Et gyldig tall."
    - id: Record
      type: System.Int64
      description: "Valgfritt. Antall den eneste post eller byte til låsing eller opplåsing av"
  overload: Microsoft.VisualBasic.FileSystem.Unlock*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Filen er ugyldig."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Unlock(System.Int32,System.Int64,System.Int64)
  id: Unlock(System.Int32,System.Int64,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Unlock(Int32,Int64,Int64)
  nameWithType: FileSystem.Unlock(Int32,Int64,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.Unlock(Int32,Int64,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Kontrollerer tilgang av andre prosesser for hele eller deler av en fil som er åpnet ved hjelp av den <xref uid=&quot;langword_csharp_Open&quot; name=&quot;Open&quot; href=&quot;&quot;> </xref> funksjonen. Den <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> funksjonen gir deg bedre produktivitet og ytelse i i/u-operasjoner enn <xref uid=&quot;langword_csharp_Lock&quot; name=&quot;Lock&quot; href=&quot;&quot;> </xref> og <xref uid=&quot;langword_csharp_Unlock&quot; name=&quot;Unlock&quot; href=&quot;&quot;> </xref>. Hvis du vil ha mer informasjon, se <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "Den `Lock` og `Unlock` funksjoner er brukt i miljøer der flere prosesser trenger tilgang til den samme filen.       `Lock`og `Unlock` er alltid brukes i par. Argumentene til `Lock` og `Unlock` må være identiske.       Hvis `Record`, eller `FromRecord` og `ToRecord` er ikke angitt, blir låsen for hele filen. Hvis `Record` alene er angitt i én post blir låses/frigis.       Hvis filen er åpnet for sekvensielle inndata eller utdata, `Lock` og `Unlock` påvirke hele filen, uavhengig av området som angis av `FromRecord` og`ToRecord`."
  example:
  - "This example illustrates the use of the `Lock` and `Unlock` functions. This example assumes that `People.txt` is a file that contains records of the structure `Person`.  \n  \n [!code-vb[VbVbalrCatRef#13](~/add/codesnippet/visualbasic/93b8910d-5e06-4d09-8b8b-_1.vb)]"
  syntax:
    content: public static void Unlock (int FileNumber, long FromRecord, long ToRecord);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Kreves. Et gyldig tall."
    - id: FromRecord
      type: System.Int64
      description: "Valgfritt. Antall første posten eller byte til låsing eller opplåsing av."
    - id: ToRecord
      type: System.Int64
      description: "Valgfritt. Antall siste posten eller byte til låsing eller opplåsing av."
  overload: Microsoft.VisualBasic.FileSystem.Unlock*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Filen er ugyldig."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])
  id: Write(System.Int32,System.Object[])
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Write(Int32,Object[])
  nameWithType: FileSystem.Write(Int32,Object[])
  fullName: Microsoft.VisualBasic.FileSystem.Write(Int32,Object[])
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Skriver data til en sekvensiell fil. Data som skrives med <xref uid=&quot;langword_csharp_Write&quot; name=&quot;Write&quot; href=&quot;&quot;> </xref> vanligvis lese fra en fil ved hjelp av <xref uid=&quot;langword_csharp_Input&quot; name=&quot;Input&quot; href=&quot;&quot;> </xref>."
  remarks: "Den `Write` og `WriteLine` funksjoner er angitt for bakoverkompatibilitet og kan påvirke ytelsen. For ikke-eldre applikasjoner i `My.Computer.FileSystem` objektet gir bedre ytelse. Hvis du vil ha mer informasjon, se [tilgang til filen med Visual Basic](~/add/includes/ajax-current-ext-md.md).       Hvis du utelater `Output`, en tom linje skrives til filen. Flere uttrykk kan være atskilt med komma.       I motsetning til det `Print` -funksjonen, den `Write` funksjonen setter inn komma mellom elementer og anførselstegn rundt strenger som de er skrevet til filen. Du har ikke å sette eksplisitt skilletegn i listen. Når `Write` brukes til å skrive data til en fil, bare numeriske `Boolean`, dato, null, og `Error` datoformater støttes. Følgende universal forutsetninger etterfølges slik at dataene kan alltid lese og tolkes riktig ved hjelp av `Input`, uavhengig av nasjonal innstilling:-numeriske data skrives alltid med perioden som desimaltegn.      -For `Boolean` data, enten `#TRUE#` eller `#FALSE#` skrives. Den `True` og `False` nøkkelord er ikke oversatt, uavhengig av nasjonal innstilling.      -Dato data skrives til filen med det universale datoformatet. Når dato eller Klokkeslettkomponenten mangler eller null, bare delen angitt skrives til filen.      -Ingenting er skrevet til filen hvis `Output` data er tom. Imidlertid for null data `#NULL#` skrives.      -For `Error` dataene, utdataene vises som `#ERROR errorcode#`. Den `Error` nøkkelordet oversettes ikke, uavhengig av nasjonal innstilling.       `WriteLine`setter inn en tegnet (det vil si en vognretur retur/linje feeden, eller `Chr(13) + Chr(10)`), når det er skrevet det siste tegnet i `Output` til filen.       Du kan bygge inn anførselstegn i en streng ved å bruke doble anførselstegn, eller &quot;&quot;. For eksempel [!code-vb [VbVbalrCatRef&#63;](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._145_1.vb) ] returnerer en streng med verdien for `Double quotation marks aren&quot;t &quot;difficult&quot; to handle`.       Skriving til en fil ved hjelp av den `Write` eller `WriteLine` funksjoner krever `Append` tilgang fra den `FileIOPermissionAccess` opplisting. Hvis du vil ha mer informasjon, kan du se <xref:System.Security.Permissions.FileIOPermissionAccess>.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `Write` function to write raw data to a sequential file.  \n  \n [!code-vb[VbVbalrCatRef#64](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._145_2.vb)]"
  syntax:
    content: public static void Write (int FileNumber, object[] Output);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Kreves. En <xref uid=&quot;langword_csharp_Integer&quot; name=&quot;Integer&quot; href=&quot;&quot;> </xref> uttrykk som inneholder et gyldig filnummer."
    - id: Output
      type: System.Object[]
      description: "Valgfritt. Ett eller flere kommadelt uttrykk til å skrive til en fil."
  overload: Microsoft.VisualBasic.FileSystem.Write*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Filen er ugyldig."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])
  id: WriteLine(System.Int32,System.Object[])
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: WriteLine(Int32,Object[])
  nameWithType: FileSystem.WriteLine(Int32,Object[])
  fullName: Microsoft.VisualBasic.FileSystem.WriteLine(Int32,Object[])
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Skriver data til en sekvensiell fil. Data som skrives med <xref uid=&quot;langword_csharp_Write&quot; name=&quot;Write&quot; href=&quot;&quot;> </xref> vanligvis lese fra en fil ved hjelp av <xref uid=&quot;langword_csharp_Input&quot; name=&quot;Input&quot; href=&quot;&quot;> </xref>."
  remarks: "Den `Write` og `WriteLine` funksjoner er angitt for bakoverkompatibilitet og kan påvirke ytelsen. For ikke-eldre applikasjoner i `My.Computer.FileSystem` objektet gir bedre ytelse. Hvis du vil ha mer informasjon, se [tilgang til filen med Visual Basic](~/add/includes/ajax-current-ext-md.md).       Hvis du utelater `Output`, en tom linje skrives til filen. Flere uttrykk kan være atskilt med komma.       I motsetning til det `Print` -funksjonen, den `Write` funksjonen setter inn komma mellom elementer og anførselstegn rundt strenger som de er skrevet til filen. Du har ikke å sette eksplisitt skilletegn i listen. Når `Write` brukes til å skrive data til en fil, bare numeriske `Boolean`, dato, null, og `Error` datoformater støttes. Følgende universal forutsetninger etterfølges slik at dataene kan alltid lese og tolkes riktig ved hjelp av `Input`, uavhengig av nasjonal innstilling:-numeriske data skrives alltid med perioden som desimaltegn.      -For `Boolean` data, enten `#TRUE#` eller `#FALSE#` skrives. Den `True` og `False` nøkkelord er ikke oversatt, uavhengig av nasjonal innstilling.      -Dato data skrives til filen med det universale datoformatet. Når dato eller Klokkeslettkomponenten mangler eller null, bare delen angitt skrives til filen.      -Ingenting er skrevet til filen hvis `Output` data er tom. Imidlertid for null data `#NULL#` skrives.      -For `Error` dataene, utdataene vises som `#ERROR errorcode#`. Den `Error` nøkkelordet oversettes ikke, uavhengig av nasjonal innstilling.       `WriteLine`setter inn en tegnet (det vil si en vognretur retur/linje feeden, eller `Chr(13) + Chr(10)`), når det er skrevet det siste tegnet i `Output` til filen.       Du kan bygge inn anførselstegn i en streng ved å bruke doble anførselstegn, eller &quot;&quot;. For eksempel [!code-vb [VbVbalrCatRef&#63;](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._172_1.vb) ] returnerer en streng med verdien for `Double quotation marks aren&quot;t &quot;difficult&quot; to handle`.       Skriving til en fil ved hjelp av den `Write` eller `WriteLine` funksjoner krever `Append` tilgang fra den `FileIOPermissionAccess` opplisting. Hvis du vil ha mer informasjon, kan du se <xref:System.Security.Permissions.FileIOPermissionAccess>.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `Write` function to write raw data to a sequential file.  \n  \n [!code-vb[VbVbalrCatRef#64](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._172_2.vb)]"
  syntax:
    content: public static void WriteLine (int FileNumber, object[] Output);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Kreves. En <xref uid=&quot;langword_csharp_Integer&quot; name=&quot;Integer&quot; href=&quot;&quot;> </xref> uttrykk som inneholder et gyldig filnummer."
    - id: Output
      type: System.Object[]
      description: "Valgfritt. Ett eller flere kommadelt uttrykk til å skrive til en fil."
  overload: Microsoft.VisualBasic.FileSystem.WriteLine*
  exceptions: []
  platform:
  - net462
references:
- uid: System.Object
  isExternal: false
  name: System.Object
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.IO.FileNotFoundException
  isExternal: true
  name: System.IO.FileNotFoundException
- uid: System.IO.IOException
  isExternal: true
  name: System.IO.IOException
- uid: System.Security.SecurityException
  isExternal: true
  name: System.Security.SecurityException
- uid: System.IO.EndOfStreamException
  isExternal: true
  name: System.IO.EndOfStreamException
- uid: Microsoft.VisualBasic.FileSystem.ChDir(System.String)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: ChDir(String)
  nameWithType: FileSystem.ChDir(String)
  fullName: Microsoft.VisualBasic.FileSystem.ChDir(String)
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: Microsoft.VisualBasic.FileSystem.ChDrive(System.Char)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: ChDrive(Char)
  nameWithType: FileSystem.ChDrive(Char)
  fullName: Microsoft.VisualBasic.FileSystem.ChDrive(Char)
- uid: System.Char
  parent: System
  isExternal: true
  name: Char
  nameWithType: Char
  fullName: System.Char
- uid: Microsoft.VisualBasic.FileSystem.ChDrive(System.String)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: ChDrive(String)
  nameWithType: FileSystem.ChDrive(String)
  fullName: Microsoft.VisualBasic.FileSystem.ChDrive(String)
- uid: Microsoft.VisualBasic.FileSystem.CurDir
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: CurDir()
  nameWithType: FileSystem.CurDir()
  fullName: Microsoft.VisualBasic.FileSystem.CurDir()
- uid: Microsoft.VisualBasic.FileSystem.CurDir(System.Char)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: CurDir(Char)
  nameWithType: FileSystem.CurDir(Char)
  fullName: Microsoft.VisualBasic.FileSystem.CurDir(Char)
- uid: Microsoft.VisualBasic.FileSystem.Dir
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Dir()
  nameWithType: FileSystem.Dir()
  fullName: Microsoft.VisualBasic.FileSystem.Dir()
- uid: Microsoft.VisualBasic.FileSystem.Dir(System.String,Microsoft.VisualBasic.FileAttribute)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Dir(String,FileAttribute)
  nameWithType: FileSystem.Dir(String,FileAttribute)
  fullName: Microsoft.VisualBasic.FileSystem.Dir(String,FileAttribute)
- uid: Microsoft.VisualBasic.FileAttribute
  parent: Microsoft.VisualBasic
  isExternal: false
  name: FileAttribute
  nameWithType: FileAttribute
  fullName: Microsoft.VisualBasic.FileAttribute
- uid: Microsoft.VisualBasic.FileSystem.EOF(System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: EOF(Int32)
  nameWithType: FileSystem.EOF(Int32)
  fullName: Microsoft.VisualBasic.FileSystem.EOF(Int32)
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: Microsoft.VisualBasic.FileSystem.FileAttr(System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileAttr(Int32)
  nameWithType: FileSystem.FileAttr(Int32)
  fullName: Microsoft.VisualBasic.FileSystem.FileAttr(Int32)
- uid: Microsoft.VisualBasic.OpenMode
  parent: Microsoft.VisualBasic
  isExternal: false
  name: OpenMode
  nameWithType: OpenMode
  fullName: Microsoft.VisualBasic.OpenMode
- uid: Microsoft.VisualBasic.FileSystem.FileClose(System.Int32[])
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileClose(Int32[])
  nameWithType: FileSystem.FileClose(Int32[])
  fullName: Microsoft.VisualBasic.FileSystem.FileClose(Int32[])
- uid: System.Int32[]
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32[]
  spec.csharp:
  - uid: System.Int32
    name: Int32
    nameWithType: Int32
    fullName: Int32[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: Microsoft.VisualBasic.FileSystem.FileCopy(System.String,System.String)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileCopy(String,String)
  nameWithType: FileSystem.FileCopy(String,String)
  fullName: Microsoft.VisualBasic.FileSystem.FileCopy(String,String)
- uid: Microsoft.VisualBasic.FileSystem.FileDateTime(System.String)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileDateTime(String)
  nameWithType: FileSystem.FileDateTime(String)
  fullName: Microsoft.VisualBasic.FileSystem.FileDateTime(String)
- uid: System.DateTime
  parent: System
  isExternal: true
  name: DateTime
  nameWithType: DateTime
  fullName: System.DateTime
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Boolean@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileGet(Int32,Boolean,Int64)
  nameWithType: FileSystem.FileGet(Int32,Boolean,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Boolean,Int64)
- uid: System.Int64
  parent: System
  isExternal: true
  name: Int64
  nameWithType: Int64
  fullName: System.Int64
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Byte@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileGet(Int32,Byte,Int64)
  nameWithType: FileSystem.FileGet(Int32,Byte,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Byte,Int64)
- uid: System.Byte
  parent: System
  isExternal: true
  name: Byte
  nameWithType: Byte
  fullName: System.Byte
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Char@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileGet(Int32,Char,Int64)
  nameWithType: FileSystem.FileGet(Int32,Char,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Char,Int64)
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.DateTime@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileGet(Int32,DateTime,Int64)
  nameWithType: FileSystem.FileGet(Int32,DateTime,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,DateTime,Int64)
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Decimal@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileGet(Int32,Decimal,Int64)
  nameWithType: FileSystem.FileGet(Int32,Decimal,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Decimal,Int64)
- uid: System.Decimal
  parent: System
  isExternal: true
  name: Decimal
  nameWithType: Decimal
  fullName: System.Decimal
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Double@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileGet(Int32,Double,Int64)
  nameWithType: FileSystem.FileGet(Int32,Double,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Double,Int64)
- uid: System.Double
  parent: System
  isExternal: true
  name: Double
  nameWithType: Double
  fullName: System.Double
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int16@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileGet(Int32,Int16,Int64)
  nameWithType: FileSystem.FileGet(Int32,Int16,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Int16,Int64)
- uid: System.Int16
  parent: System
  isExternal: true
  name: Int16
  nameWithType: Int16
  fullName: System.Int16
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int32@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileGet(Int32,Int32,Int64)
  nameWithType: FileSystem.FileGet(Int32,Int32,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Int32,Int64)
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int64@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileGet(Int32,Int64,Int64)
  nameWithType: FileSystem.FileGet(Int32,Int64,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Int64,Int64)
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Single@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileGet(Int32,Single,Int64)
  nameWithType: FileSystem.FileGet(Int32,Single,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Single,Int64)
- uid: System.Single
  parent: System
  isExternal: true
  name: Single
  nameWithType: Single
  fullName: System.Single
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.ValueType@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileGet(Int32,ValueType,Int64)
  nameWithType: FileSystem.FileGet(Int32,ValueType,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,ValueType,Int64)
- uid: System.ValueType
  parent: System
  isExternal: true
  name: ValueType
  nameWithType: ValueType
  fullName: System.ValueType
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.String@,System.Int64,System.Boolean)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileGet(Int32,String,Int64,Boolean)
  nameWithType: FileSystem.FileGet(Int32,String,Int64,Boolean)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,String,Int64,Boolean)
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Array@,System.Int64,System.Boolean,System.Boolean)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileGet(Int32,Array,Int64,Boolean,Boolean)
  nameWithType: FileSystem.FileGet(Int32,Array,Int64,Boolean,Boolean)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Array,Int64,Boolean,Boolean)
- uid: System.Array
  parent: System
  isExternal: true
  name: Array
  nameWithType: Array
  fullName: System.Array
- uid: Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileGetObject(Int32,Object,Int64)
  nameWithType: FileSystem.FileGetObject(Int32,Object,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGetObject(Int32,Object,Int64)
- uid: Microsoft.VisualBasic.FileSystem.FileLen(System.String)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileLen(String)
  nameWithType: FileSystem.FileLen(String)
  fullName: Microsoft.VisualBasic.FileSystem.FileLen(String)
- uid: Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileOpen(Int32,String,OpenMode,OpenAccess,OpenShare,Int32)
  nameWithType: FileSystem.FileOpen(Int32,String,OpenMode,OpenAccess,OpenShare,Int32)
  fullName: Microsoft.VisualBasic.FileSystem.FileOpen(Int32,String,OpenMode,OpenAccess,OpenShare,Int32)
- uid: Microsoft.VisualBasic.OpenAccess
  parent: Microsoft.VisualBasic
  isExternal: false
  name: OpenAccess
  nameWithType: OpenAccess
  fullName: Microsoft.VisualBasic.OpenAccess
- uid: Microsoft.VisualBasic.OpenShare
  parent: Microsoft.VisualBasic
  isExternal: false
  name: OpenShare
  nameWithType: OpenShare
  fullName: Microsoft.VisualBasic.OpenShare
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Boolean,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FilePut(Int32,Boolean,Int64)
  nameWithType: FileSystem.FilePut(Int32,Boolean,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Boolean,Int64)
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Byte,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FilePut(Int32,Byte,Int64)
  nameWithType: FileSystem.FilePut(Int32,Byte,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Byte,Int64)
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Char,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FilePut(Int32,Char,Int64)
  nameWithType: FileSystem.FilePut(Int32,Char,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Char,Int64)
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.DateTime,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FilePut(Int32,DateTime,Int64)
  nameWithType: FileSystem.FilePut(Int32,DateTime,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,DateTime,Int64)
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Decimal,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FilePut(Int32,Decimal,Int64)
  nameWithType: FileSystem.FilePut(Int32,Decimal,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Decimal,Int64)
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Double,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FilePut(Int32,Double,Int64)
  nameWithType: FileSystem.FilePut(Int32,Double,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Double,Int64)
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int16,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FilePut(Int32,Int16,Int64)
  nameWithType: FileSystem.FilePut(Int32,Int16,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Int16,Int64)
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int32,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FilePut(Int32,Int32,Int64)
  nameWithType: FileSystem.FilePut(Int32,Int32,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Int32,Int64)
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int64,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FilePut(Int32,Int64,Int64)
  nameWithType: FileSystem.FilePut(Int32,Int64,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Int64,Int64)
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Single,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FilePut(Int32,Single,Int64)
  nameWithType: FileSystem.FilePut(Int32,Single,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Single,Int64)
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.ValueType,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FilePut(Int32,ValueType,Int64)
  nameWithType: FileSystem.FilePut(Int32,ValueType,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,ValueType,Int64)
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Object,System.Object,System.Object)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FilePut(Object,Object,Object)
  nameWithType: FileSystem.FilePut(Object,Object,Object)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Object,Object,Object)
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.String,System.Int64,System.Boolean)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FilePut(Int32,String,Int64,Boolean)
  nameWithType: FileSystem.FilePut(Int32,String,Int64,Boolean)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,String,Int64,Boolean)
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Array,System.Int64,System.Boolean,System.Boolean)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FilePut(Int32,Array,Int64,Boolean,Boolean)
  nameWithType: FileSystem.FilePut(Int32,Array,Int64,Boolean,Boolean)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Array,Int64,Boolean,Boolean)
- uid: Microsoft.VisualBasic.FileSystem.FilePutObject(System.Int32,System.Object,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FilePutObject(Int32,Object,Int64)
  nameWithType: FileSystem.FilePutObject(Int32,Object,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePutObject(Int32,Object,Int64)
- uid: Microsoft.VisualBasic.FileSystem.FileWidth(System.Int32,System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileWidth(Int32,Int32)
  nameWithType: FileSystem.FileWidth(Int32,Int32)
  fullName: Microsoft.VisualBasic.FileSystem.FileWidth(Int32,Int32)
- uid: Microsoft.VisualBasic.FileSystem.FreeFile
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FreeFile()
  nameWithType: FileSystem.FreeFile()
  fullName: Microsoft.VisualBasic.FileSystem.FreeFile()
- uid: Microsoft.VisualBasic.FileSystem.GetAttr(System.String)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: GetAttr(String)
  nameWithType: FileSystem.GetAttr(String)
  fullName: Microsoft.VisualBasic.FileSystem.GetAttr(String)
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Boolean@)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Input(Int32,Boolean)
  nameWithType: FileSystem.Input(Int32,Boolean)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Boolean)
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Byte@)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Input(Int32,Byte)
  nameWithType: FileSystem.Input(Int32,Byte)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Byte)
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Char@)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Input(Int32,Char)
  nameWithType: FileSystem.Input(Int32,Char)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Char)
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.DateTime@)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Input(Int32,DateTime)
  nameWithType: FileSystem.Input(Int32,DateTime)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,DateTime)
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Decimal@)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Input(Int32,Decimal)
  nameWithType: FileSystem.Input(Int32,Decimal)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Decimal)
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Double@)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Input(Int32,Double)
  nameWithType: FileSystem.Input(Int32,Double)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Double)
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int16@)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Input(Int32,Int16)
  nameWithType: FileSystem.Input(Int32,Int16)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Int16)
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int32@)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Input(Int32,Int32)
  nameWithType: FileSystem.Input(Int32,Int32)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Int32)
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int64@)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Input(Int32,Int64)
  nameWithType: FileSystem.Input(Int32,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Int64)
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Object@)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Input(Int32,Object)
  nameWithType: FileSystem.Input(Int32,Object)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Object)
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Single@)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Input(Int32,Single)
  nameWithType: FileSystem.Input(Int32,Single)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Single)
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.String@)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Input(Int32,String)
  nameWithType: FileSystem.Input(Int32,String)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,String)
- uid: Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: InputString(Int32,Int32)
  nameWithType: FileSystem.InputString(Int32,Int32)
  fullName: Microsoft.VisualBasic.FileSystem.InputString(Int32,Int32)
- uid: Microsoft.VisualBasic.FileSystem.Kill(System.String)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Kill(String)
  nameWithType: FileSystem.Kill(String)
  fullName: Microsoft.VisualBasic.FileSystem.Kill(String)
- uid: Microsoft.VisualBasic.FileSystem.LineInput(System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: LineInput(Int32)
  nameWithType: FileSystem.LineInput(Int32)
  fullName: Microsoft.VisualBasic.FileSystem.LineInput(Int32)
- uid: Microsoft.VisualBasic.FileSystem.Loc(System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Loc(Int32)
  nameWithType: FileSystem.Loc(Int32)
  fullName: Microsoft.VisualBasic.FileSystem.Loc(Int32)
- uid: Microsoft.VisualBasic.FileSystem.Lock(System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Lock(Int32)
  nameWithType: FileSystem.Lock(Int32)
  fullName: Microsoft.VisualBasic.FileSystem.Lock(Int32)
- uid: Microsoft.VisualBasic.FileSystem.Lock(System.Int32,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Lock(Int32,Int64)
  nameWithType: FileSystem.Lock(Int32,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.Lock(Int32,Int64)
- uid: Microsoft.VisualBasic.FileSystem.Lock(System.Int32,System.Int64,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Lock(Int32,Int64,Int64)
  nameWithType: FileSystem.Lock(Int32,Int64,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.Lock(Int32,Int64,Int64)
- uid: Microsoft.VisualBasic.FileSystem.LOF(System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: LOF(Int32)
  nameWithType: FileSystem.LOF(Int32)
  fullName: Microsoft.VisualBasic.FileSystem.LOF(Int32)
- uid: Microsoft.VisualBasic.FileSystem.MkDir(System.String)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: MkDir(String)
  nameWithType: FileSystem.MkDir(String)
  fullName: Microsoft.VisualBasic.FileSystem.MkDir(String)
- uid: Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Print(Int32,Object[])
  nameWithType: FileSystem.Print(Int32,Object[])
  fullName: Microsoft.VisualBasic.FileSystem.Print(Int32,Object[])
- uid: System.Object[]
  parent: System
  isExternal: true
  name: Object
  nameWithType: Object
  fullName: System.Object[]
  spec.csharp:
  - uid: System.Object
    name: Object
    nameWithType: Object
    fullName: Object[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: PrintLine(Int32,Object[])
  nameWithType: FileSystem.PrintLine(Int32,Object[])
  fullName: Microsoft.VisualBasic.FileSystem.PrintLine(Int32,Object[])
- uid: Microsoft.VisualBasic.FileSystem.Rename(System.String,System.String)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Rename(String,String)
  nameWithType: FileSystem.Rename(String,String)
  fullName: Microsoft.VisualBasic.FileSystem.Rename(String,String)
- uid: Microsoft.VisualBasic.FileSystem.Reset
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Reset()
  nameWithType: FileSystem.Reset()
  fullName: Microsoft.VisualBasic.FileSystem.Reset()
- uid: Microsoft.VisualBasic.FileSystem.RmDir(System.String)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: RmDir(String)
  nameWithType: FileSystem.RmDir(String)
  fullName: Microsoft.VisualBasic.FileSystem.RmDir(String)
- uid: Microsoft.VisualBasic.FileSystem.Seek(System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Seek(Int32)
  nameWithType: FileSystem.Seek(Int32)
  fullName: Microsoft.VisualBasic.FileSystem.Seek(Int32)
- uid: Microsoft.VisualBasic.FileSystem.Seek(System.Int32,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Seek(Int32,Int64)
  nameWithType: FileSystem.Seek(Int32,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.Seek(Int32,Int64)
- uid: Microsoft.VisualBasic.FileSystem.SetAttr(System.String,Microsoft.VisualBasic.FileAttribute)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: SetAttr(String,FileAttribute)
  nameWithType: FileSystem.SetAttr(String,FileAttribute)
  fullName: Microsoft.VisualBasic.FileSystem.SetAttr(String,FileAttribute)
- uid: Microsoft.VisualBasic.FileSystem.SPC(System.Int16)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: SPC(Int16)
  nameWithType: FileSystem.SPC(Int16)
  fullName: Microsoft.VisualBasic.FileSystem.SPC(Int16)
- uid: Microsoft.VisualBasic.SpcInfo
  parent: Microsoft.VisualBasic
  isExternal: false
  name: SpcInfo
  nameWithType: SpcInfo
  fullName: Microsoft.VisualBasic.SpcInfo
- uid: Microsoft.VisualBasic.FileSystem.TAB
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: TAB()
  nameWithType: FileSystem.TAB()
  fullName: Microsoft.VisualBasic.FileSystem.TAB()
- uid: Microsoft.VisualBasic.TabInfo
  parent: Microsoft.VisualBasic
  isExternal: false
  name: TabInfo
  nameWithType: TabInfo
  fullName: Microsoft.VisualBasic.TabInfo
- uid: Microsoft.VisualBasic.FileSystem.TAB(System.Int16)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: TAB(Int16)
  nameWithType: FileSystem.TAB(Int16)
  fullName: Microsoft.VisualBasic.FileSystem.TAB(Int16)
- uid: Microsoft.VisualBasic.FileSystem.Unlock(System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Unlock(Int32)
  nameWithType: FileSystem.Unlock(Int32)
  fullName: Microsoft.VisualBasic.FileSystem.Unlock(Int32)
- uid: Microsoft.VisualBasic.FileSystem.Unlock(System.Int32,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Unlock(Int32,Int64)
  nameWithType: FileSystem.Unlock(Int32,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.Unlock(Int32,Int64)
- uid: Microsoft.VisualBasic.FileSystem.Unlock(System.Int32,System.Int64,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Unlock(Int32,Int64,Int64)
  nameWithType: FileSystem.Unlock(Int32,Int64,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.Unlock(Int32,Int64,Int64)
- uid: Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Write(Int32,Object[])
  nameWithType: FileSystem.Write(Int32,Object[])
  fullName: Microsoft.VisualBasic.FileSystem.Write(Int32,Object[])
- uid: Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: WriteLine(Int32,Object[])
  nameWithType: FileSystem.WriteLine(Int32,Object[])
  fullName: Microsoft.VisualBasic.FileSystem.WriteLine(Int32,Object[])
- uid: Microsoft.VisualBasic.FileSystem.ChDir*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: ChDir
  nameWithType: FileSystem.ChDir
- uid: Microsoft.VisualBasic.FileSystem.ChDrive*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: ChDrive
  nameWithType: FileSystem.ChDrive
- uid: Microsoft.VisualBasic.FileSystem.CurDir*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: CurDir
  nameWithType: FileSystem.CurDir
- uid: Microsoft.VisualBasic.FileSystem.Dir*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Dir
  nameWithType: FileSystem.Dir
- uid: Microsoft.VisualBasic.FileSystem.EOF*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: EOF
  nameWithType: FileSystem.EOF
- uid: Microsoft.VisualBasic.FileSystem.FileAttr*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileAttr
  nameWithType: FileSystem.FileAttr
- uid: Microsoft.VisualBasic.FileSystem.FileClose*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileClose
  nameWithType: FileSystem.FileClose
- uid: Microsoft.VisualBasic.FileSystem.FileCopy*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileCopy
  nameWithType: FileSystem.FileCopy
- uid: Microsoft.VisualBasic.FileSystem.FileDateTime*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileDateTime
  nameWithType: FileSystem.FileDateTime
- uid: Microsoft.VisualBasic.FileSystem.FileGet*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileGet
  nameWithType: FileSystem.FileGet
- uid: Microsoft.VisualBasic.FileSystem.FileGetObject*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileGetObject
  nameWithType: FileSystem.FileGetObject
- uid: Microsoft.VisualBasic.FileSystem.FileLen*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileLen
  nameWithType: FileSystem.FileLen
- uid: Microsoft.VisualBasic.FileSystem.FileOpen*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileOpen
  nameWithType: FileSystem.FileOpen
- uid: Microsoft.VisualBasic.FileSystem.FilePut*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FilePut
  nameWithType: FileSystem.FilePut
- uid: Microsoft.VisualBasic.FileSystem.FilePutObject*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FilePutObject
  nameWithType: FileSystem.FilePutObject
- uid: Microsoft.VisualBasic.FileSystem.FileWidth*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileWidth
  nameWithType: FileSystem.FileWidth
- uid: Microsoft.VisualBasic.FileSystem.FreeFile*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FreeFile
  nameWithType: FileSystem.FreeFile
- uid: Microsoft.VisualBasic.FileSystem.GetAttr*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: GetAttr
  nameWithType: FileSystem.GetAttr
- uid: Microsoft.VisualBasic.FileSystem.Input*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Input
  nameWithType: FileSystem.Input
- uid: Microsoft.VisualBasic.FileSystem.InputString*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: InputString
  nameWithType: FileSystem.InputString
- uid: Microsoft.VisualBasic.FileSystem.Kill*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Kill
  nameWithType: FileSystem.Kill
- uid: Microsoft.VisualBasic.FileSystem.LineInput*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: LineInput
  nameWithType: FileSystem.LineInput
- uid: Microsoft.VisualBasic.FileSystem.Loc*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Loc
  nameWithType: FileSystem.Loc
- uid: Microsoft.VisualBasic.FileSystem.Lock*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Lock
  nameWithType: FileSystem.Lock
- uid: Microsoft.VisualBasic.FileSystem.LOF*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: LOF
  nameWithType: FileSystem.LOF
- uid: Microsoft.VisualBasic.FileSystem.MkDir*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: MkDir
  nameWithType: FileSystem.MkDir
- uid: Microsoft.VisualBasic.FileSystem.Print*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Print
  nameWithType: FileSystem.Print
- uid: Microsoft.VisualBasic.FileSystem.PrintLine*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: PrintLine
  nameWithType: FileSystem.PrintLine
- uid: Microsoft.VisualBasic.FileSystem.Rename*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Rename
  nameWithType: FileSystem.Rename
- uid: Microsoft.VisualBasic.FileSystem.Reset*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Reset
  nameWithType: FileSystem.Reset
- uid: Microsoft.VisualBasic.FileSystem.RmDir*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: RmDir
  nameWithType: FileSystem.RmDir
- uid: Microsoft.VisualBasic.FileSystem.Seek*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Seek
  nameWithType: FileSystem.Seek
- uid: Microsoft.VisualBasic.FileSystem.SetAttr*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: SetAttr
  nameWithType: FileSystem.SetAttr
- uid: Microsoft.VisualBasic.FileSystem.SPC*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: SPC
  nameWithType: FileSystem.SPC
- uid: Microsoft.VisualBasic.FileSystem.TAB*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: TAB
  nameWithType: FileSystem.TAB
- uid: Microsoft.VisualBasic.FileSystem.Unlock*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Unlock
  nameWithType: FileSystem.Unlock
- uid: Microsoft.VisualBasic.FileSystem.Write*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Write
  nameWithType: FileSystem.Write
- uid: Microsoft.VisualBasic.FileSystem.WriteLine*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: WriteLine
  nameWithType: FileSystem.WriteLine
