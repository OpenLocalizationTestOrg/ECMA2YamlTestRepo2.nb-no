### YamlMime:ManagedReference
items:
- uid: System.Diagnostics.Process
  id: Process
  children:
  - System.Diagnostics.Process.#ctor
  - System.Diagnostics.Process.BasePriority
  - System.Diagnostics.Process.BeginErrorReadLine
  - System.Diagnostics.Process.BeginOutputReadLine
  - System.Diagnostics.Process.CancelErrorRead
  - System.Diagnostics.Process.CancelOutputRead
  - System.Diagnostics.Process.Close
  - System.Diagnostics.Process.CloseMainWindow
  - System.Diagnostics.Process.Dispose(System.Boolean)
  - System.Diagnostics.Process.EnableRaisingEvents
  - System.Diagnostics.Process.EnterDebugMode
  - System.Diagnostics.Process.ErrorDataReceived
  - System.Diagnostics.Process.ExitCode
  - System.Diagnostics.Process.Exited
  - System.Diagnostics.Process.ExitTime
  - System.Diagnostics.Process.GetCurrentProcess
  - System.Diagnostics.Process.GetProcessById(System.Int32)
  - System.Diagnostics.Process.GetProcessById(System.Int32,System.String)
  - System.Diagnostics.Process.GetProcesses
  - System.Diagnostics.Process.GetProcesses(System.String)
  - System.Diagnostics.Process.GetProcessesByName(System.String)
  - System.Diagnostics.Process.GetProcessesByName(System.String,System.String)
  - System.Diagnostics.Process.Handle
  - System.Diagnostics.Process.HandleCount
  - System.Diagnostics.Process.HasExited
  - System.Diagnostics.Process.Id
  - System.Diagnostics.Process.Kill
  - System.Diagnostics.Process.LeaveDebugMode
  - System.Diagnostics.Process.MachineName
  - System.Diagnostics.Process.MainModule
  - System.Diagnostics.Process.MainWindowHandle
  - System.Diagnostics.Process.MainWindowTitle
  - System.Diagnostics.Process.MaxWorkingSet
  - System.Diagnostics.Process.MinWorkingSet
  - System.Diagnostics.Process.Modules
  - System.Diagnostics.Process.NonpagedSystemMemorySize
  - System.Diagnostics.Process.NonpagedSystemMemorySize64
  - System.Diagnostics.Process.OnExited
  - System.Diagnostics.Process.OutputDataReceived
  - System.Diagnostics.Process.PagedMemorySize
  - System.Diagnostics.Process.PagedMemorySize64
  - System.Diagnostics.Process.PagedSystemMemorySize
  - System.Diagnostics.Process.PagedSystemMemorySize64
  - System.Diagnostics.Process.PeakPagedMemorySize
  - System.Diagnostics.Process.PeakPagedMemorySize64
  - System.Diagnostics.Process.PeakVirtualMemorySize
  - System.Diagnostics.Process.PeakVirtualMemorySize64
  - System.Diagnostics.Process.PeakWorkingSet
  - System.Diagnostics.Process.PeakWorkingSet64
  - System.Diagnostics.Process.PriorityBoostEnabled
  - System.Diagnostics.Process.PriorityClass
  - System.Diagnostics.Process.PrivateMemorySize
  - System.Diagnostics.Process.PrivateMemorySize64
  - System.Diagnostics.Process.PrivilegedProcessorTime
  - System.Diagnostics.Process.ProcessName
  - System.Diagnostics.Process.ProcessorAffinity
  - System.Diagnostics.Process.Refresh
  - System.Diagnostics.Process.Responding
  - System.Diagnostics.Process.SafeHandle
  - System.Diagnostics.Process.SessionId
  - System.Diagnostics.Process.StandardError
  - System.Diagnostics.Process.StandardInput
  - System.Diagnostics.Process.StandardOutput
  - System.Diagnostics.Process.Start
  - System.Diagnostics.Process.Start(System.Diagnostics.ProcessStartInfo)
  - System.Diagnostics.Process.Start(System.String)
  - System.Diagnostics.Process.Start(System.String,System.String)
  - System.Diagnostics.Process.Start(System.String,System.String,System.Security.SecureString,System.String)
  - System.Diagnostics.Process.Start(System.String,System.String,System.String,System.Security.SecureString,System.String)
  - System.Diagnostics.Process.StartInfo
  - System.Diagnostics.Process.StartTime
  - System.Diagnostics.Process.SynchronizingObject
  - System.Diagnostics.Process.Threads
  - System.Diagnostics.Process.ToString
  - System.Diagnostics.Process.TotalProcessorTime
  - System.Diagnostics.Process.UserProcessorTime
  - System.Diagnostics.Process.VirtualMemorySize
  - System.Diagnostics.Process.VirtualMemorySize64
  - System.Diagnostics.Process.WaitForExit
  - System.Diagnostics.Process.WaitForExit(System.Int32)
  - System.Diagnostics.Process.WaitForInputIdle
  - System.Diagnostics.Process.WaitForInputIdle(System.Int32)
  - System.Diagnostics.Process.WorkingSet
  - System.Diagnostics.Process.WorkingSet64
  langs:
  - csharp
  name: Process
  nameWithType: Process
  fullName: System.Diagnostics.Process
  type: Class
  summary: "Gir tilgang til lokale og eksterne prosesser og gjør at du kan starte og stoppe prosesser som lokalt system.       For å bla gjennom .NET Framework-kildekode for denne typen, kan du se den [Referansekilde](http://referencesource.microsoft.com/#System/services/monitoring/system/diagnosticts/Process.cs#f8b2e604d6f1fe04)."
  remarks: "> [!NOTE]\n>  To view the .NET Framework source code for this type, see the [Reference Source](http://referencesource.microsoft.com/#System/services/monitoring/system/diagnosticts/Process.cs#f8b2e604d6f1fe04). You can browse through the source code online, download the reference for offline viewing, and step through the sources (including patches and updates) during debugging; see [instructions](http://referencesource.microsoft.com/).  \n  \n A Process component provides access to a process that is running on a computer. A process, in the simplest terms, is a running app. A thread is the basic unit to which the operating system allocates processor time. A thread can execute any part of the code of the process, including parts currently being executed by another thread.  \n  \n The Process component is a useful tool for starting, stopping, controlling, and monitoring apps. You can use the Process component, to obtain a list of the processes that are running, or you can start a new process. A Process component is used to access system processes. After a Process component has been initialized, it can be used to obtain information about the running process. Such information includes the set of threads, the loaded modules (.dll and .exe files), and performance information such as the amount of memory the process is using.  \n  \n This type implements the <xref:System.IDisposable> interface. When you have finished using the type, you should dispose of it either directly or indirectly. To dispose of the type directly, call its <xref:System.IDisposable.Dispose%2A> method in a `try`/`catch` block. To dispose of it indirectly, use a language construct such as `using` (in C#) or `Using` (in Visual Basic). For more information, see the “Using an Object that Implements IDisposable” section in the <xref:System.IDisposable> interface topic.  \n  \n> [!NOTE]\n>  32-bit processes cannot access the modules of a 64-bit process. If you try to get information about a 64-bit process from a 32-bit process, you will get a <xref:System.ComponentModel.Win32Exception> exception. A 64-bit process, on the other hand, can access the modules of a 32-bit process.  \n  \n The process component obtains information about a group of properties all at once. After the Process component has obtained information about one member of any group, it will cache the values for the other properties in that group and not obtain new information about the other members of the group until you call the <xref:System.Diagnostics.Process.Refresh%2A> method. Therefore, a property value is not guaranteed to be any newer than the last call to the <xref:System.Diagnostics.Process.Refresh%2A> method. The group breakdowns are operating-system dependent.  \n  \n If you have a path variable declared in your system using quotes, you must fully qualify that path when starting any process found in that location. Otherwise, the system will not find the path. For example, if `c:\\mypath` is not in your path, and you add it using quotation marks: `path = %path%;\"c:\\mypath\"`, you must fully qualify any process in `c:\\mypath` when starting it.  \n  \n A system process is uniquely identified on the system by its process identifier. Like many Windows resources, a process is also identified by its handle, which might not be unique on the computer. A handle is the generic term for an identifier of a resource. The operating system persists the process handle, which is accessed through the <xref:System.Diagnostics.Process.Handle%2A> property of the Process component, even when the process has exited. Thus, you can get the process's administrative information, such as the <xref:System.Diagnostics.Process.ExitCode%2A> (usually either zero for success or a nonzero error code) and the <xref:System.Diagnostics.Process.ExitTime%2A>. Handles are an extremely valuable resource, so leaking handles is more virulent than leaking memory.  \n  \n> [!NOTE]\n>  This class contains a link demand and an inheritance demand at the class level that applies to all members. A <xref:System.Security.SecurityException> is thrown when either the immediate caller or the derived class does not have full-trust permission. For details about security demands, see [Link Demands](~/add/includes/ajax-current-ext-md.md).  \n  \n<a name=\"Core\"></a>   \n## [!INCLUDE[net_core](~/add/includes/net-core-md.md)] Notes  \n In the .NET Framework on the desktop, the Process class by default uses <xref:System.Console> encodings, which are typically code page encodings, for the input, output, and error streams. For example code, on systems whose culture is English (United States), code page 437 is the default encoding for the <xref:System.Console> class. However, [!INCLUDE[net_core](~/add/includes/net-core-md.md)] may make only a limited subset of these encodings available. If this is the case, it uses <xref:System.Text.Encoding.UTF8%2A?displayProperty=fullName> as the default encoding.  \n  \n If a Process object depends on specific code page encodings, you can still make them available by doing the following *before* you call any Process methods:  \n  \n1.  Add a reference to the System.Text.Encoding.CodePages.dll assembly to your project.  \n  \n2.  Retrieve the <xref:System.Text.EncodingProvider> object from the <xref:System.Text.CodePagesEncodingProvider.Instance%2A?displayProperty=fullName> property.  \n  \n3.  Pass the <xref:System.Text.EncodingProvider> object to the <xref:System.Text.Encoding.RegisterProvider%2A?displayProperty=fullName> method to make the additional encodings supported by the encoding provider available.  \n  \n The Process class will then automatically use the default system encoding rather than UTF8, provided that you have registered the encoding provider before calling any Process methods."
  example:
  - "The following example uses an instance of the Process class to start a process.  \n  \n [!code-cpp[Process.Start_instance#1](~/add/codesnippet/cpp/t-system.diagnostics.pro_1_1.cpp)]\n [!code-vb[Process.Start_instance#1](~/add/codesnippet/visualbasic/t-system.diagnostics.pro_1_1.vb)]\n [!code-cs[Process.Start_instance#1](~/add/codesnippet/csharp/t-system.diagnostics.pro_1_1.cs)]  \n  \n The following example uses the Process class itself and a static <xref:System.Diagnostics.Process.Start%2A> method to start a process.  \n  \n [!code-vb[Process.Start_static#1](~/add/codesnippet/visualbasic/t-system.diagnostics.pro_1_2.vb)]\n [!code-cs[Process.Start_static#1](~/add/codesnippet/csharp/t-system.diagnostics.pro_1_2.cs)]\n [!code-cpp[Process.Start_static#1](~/add/codesnippet/cpp/t-system.diagnostics.pro_1_2.cpp)]  \n  \n The following F# example defines a `runProc` function that starts a process, captures all output and error information, and records the number of milliseconds that the process has run.  The `runProc` function has three parameters: the name of application to launch, the arguments to supply to the application, and the starting directory.  \n  \n [!code-fs[System.Diagnostics.Process#1](~/add/codesnippet/fsharp/t-system.diagnostics.pro_1_3.fs)]  \n  \n The code for the `runProc` function was written by [ImaginaryDevelopment](http://fssnip.net/authors/ImaginaryDevelopment) and is available under the [Microsoft Public License](http://opensource.org/licenses/ms-pl)."
  syntax:
    content: >-
      [System.ComponentModel.DefaultEvent("Exited")]

      [System.ComponentModel.DefaultProperty("StartInfo")]

      [System.ComponentModel.Designer("System.Diagnostics.Design.ProcessDesigner, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]

      [System.Diagnostics.MonitoringDescription("ProcessDesc")]

      public class Process : System.ComponentModel.Component
  inheritance:
  - System.Object
  - System.MarshalByRefObject
  - System.ComponentModel.Component
  implements: []
  inheritedMembers:
  - System.ComponentModel.Component.CanRaiseEvents
  - System.ComponentModel.Component.Container
  - System.ComponentModel.Component.DesignMode
  - System.ComponentModel.Component.Dispose
  - System.ComponentModel.Component.Disposed
  - System.ComponentModel.Component.Events
  - System.ComponentModel.Component.GetService(System.Type)
  - System.ComponentModel.Component.Site
  - System.MarshalByRefObject.CreateObjRef(System.Type)
  - System.MarshalByRefObject.GetLifetimeService
  - System.MarshalByRefObject.InitializeLifetimeService
  - System.MarshalByRefObject.MemberwiseClone(System.Boolean)
  platform:
  - net462
- uid: System.Diagnostics.Process.#ctor
  id: '#ctor'
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: Process()
  nameWithType: Process.Process()
  fullName: System.Diagnostics.Process.Process()
  type: Constructor
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Initialiserer en ny forekomst av den <xref href=&quot;System.Diagnostics.Process&quot;> </xref> klasse."
  remarks: "Hvis du ikke angir den <xref:System.Diagnostics.Process.MachineName%2A>egenskapen standard er den lokale datamaskinen (&quot;.&quot;).</xref:System.Diagnostics.Process.MachineName%2A>       Har du to alternativer for å knytte et nytt <xref:System.Diagnostics.Process>komponent med en prosess på datamaskinen.</xref:System.Diagnostics.Process> Alternativet første er å bruke konstruktøren til å opprette den <xref:System.Diagnostics.Process>komponent, angi de riktige medlemmene av den <xref:System.Diagnostics.Process.StartInfo%2A>egenskapen og kall <xref:System.Diagnostics.Process.Start%2A>å knytte den <xref:System.Diagnostics.Process>med en ny systemprosess.</xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.Start%2A> </xref:System.Diagnostics.Process.StartInfo%2A> </xref:System.Diagnostics.Process> Alternativet andre er å knytte den <xref:System.Diagnostics.Process>med en kjører systemprosess ved hjelp av <xref:System.Diagnostics.Process.GetProcessById%2A>eller en av de <xref:System.Diagnostics.Process.GetProcesses%2A>returverdier.</xref:System.Diagnostics.Process.GetProcesses%2A> </xref:System.Diagnostics.Process.GetProcessById%2A> </xref:System.Diagnostics.Process>       Hvis du bruker en `static` overbelaste av den <xref:System.Diagnostics.Process.Start%2A>metode for å starte en ny systemprosess metoden oppretter en ny <xref:System.Diagnostics.Process>komponent knyttes til prosessen.</xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.Start%2A>       Når den <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName>egenskapen er satt til standardverdien, `true`, du kan starte programmer og dokumenter på en måte som ligner på bruk av den `Run` dialogboksen av `Start` menyen.</xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName> Når <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName>er `false`, kan du starte bare kjørbare.</xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName>       Kjørbar fil som du kan ringe fra kommandolinjen kan startes i en av to måter: ved å angi de riktige medlemmene av den <xref:System.Diagnostics.Process.StartInfo%2A>egenskapen og kaller den <xref:System.Diagnostics.Process.Start%2A>metoden uten parametere, eller ved å sende den nødvendige parameteren til den `static` <xref:System.Diagnostics.Process.Start%2A>medlem.</xref:System.Diagnostics.Process.Start%2A> </xref:System.Diagnostics.Process.Start%2A> </xref:System.Diagnostics.Process.StartInfo%2A>       Du kan opprette en <xref:System.Diagnostics.Process>sekundkomponenten ved hjelp av konstruktøren, ett av statiske <xref:System.Diagnostics.Process.Start%2A>overlastingene eller noen av de <xref:System.Diagnostics.Process.GetProcessById%2A>, <xref:System.Diagnostics.Process.GetProcesses%2A>, eller <xref:System.Diagnostics.Process.GetProcessesByName%2A>metoder.</xref:System.Diagnostics.Process.GetProcessesByName%2A> </xref:System.Diagnostics.Process.GetProcesses%2A> </xref:System.Diagnostics.Process.GetProcessById%2A> </xref:System.Diagnostics.Process.Start%2A> </xref:System.Diagnostics.Process> Når du har gjort dette, har du en visning i den tilknyttede prosessen. Dette er ikke en dynamisk visning som oppdateres automatisk når prosessen-egenskapene har blitt endret i minnet. Du må i stedet kalle <xref:System.Diagnostics.Process.Refresh%2A>for komponenten som skal oppdateres av <xref:System.Diagnostics.Process>egenskapsinformasjon i programmet.</xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.Refresh%2A>"
  syntax:
    content: public Process ();
    parameters: []
  overload: System.Diagnostics.Process.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.Process.BasePriority
  id: BasePriority
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: BasePriority
  nameWithType: Process.BasePriority
  fullName: System.Diagnostics.Process.BasePriority
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Henter basisprioriteten for den tilknyttede prosessen."
  remarks: "BasePriority av prosessen er Start prioriteten for tråder som er opprettet i den tilknyttede prosessen. Du kan vise informasjon om basisprioriteten via System-skjermen prioritet Base teller.       Basert på tidspunktet forløpt eller andre øker, operativsystemet kan endre basisprioriteten når en prosess som skal plasseres lengre enn andre.       Egenskapen BasePriority kan du vise Start prioriteten tilordnet til en prosess. Fordi den er skrivebeskyttet, kan du bruke BasePriority til å angi prioritet for prosessen. Hvis du vil endre prioriteten, kan du bruke den <xref:System.Diagnostics.Process.PriorityClass%2A>egenskapen.</xref:System.Diagnostics.Process.PriorityClass%2A> BasePriority er synlig bruker System-Monitor, da den <xref:System.Diagnostics.Process.PriorityClass%2A>ikke.</xref:System.Diagnostics.Process.PriorityClass%2A> Både BasePriority og <xref:System.Diagnostics.Process.PriorityClass%2A>kan vises programmatisk.</xref:System.Diagnostics.Process.PriorityClass%2A> Tabellen nedenfor viser forholdet mellom BasePriority verdiene og <xref:System.Diagnostics.Process.PriorityClass%2A>verdier.</xref:System.Diagnostics.Process.PriorityClass%2A>      | BasePriority | PriorityClass |   |------------------|-------------------|   |&4; | <xref:System.Diagnostics.ProcessPriorityClass>|   |&8; | <xref:System.Diagnostics.ProcessPriorityClass>|   |&13; | <xref:System.Diagnostics.ProcessPriorityClass>|   |&24; | <xref:System.Diagnostics.ProcessPriorityClass>|</xref:System.Diagnostics.ProcessPriorityClass></xref:System.Diagnostics.ProcessPriorityClass></xref:System.Diagnostics.ProcessPriorityClass></xref:System.Diagnostics.ProcessPriorityClass>"
  example:
  - "The following example starts an instance of Notepad. The example then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays the process's exit code.  \n  \n [!code-cpp[Diag_Process_MemoryProperties64#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_3_1.cpp)]\n [!code-cs[Diag_Process_MemoryProperties64#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_3_1.cs)]\n [!code-vb[Diag_Process_MemoryProperties64#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_3_1.vb)]"
  syntax:
    content: public int BasePriority { get; }
    return:
      type: System.Int32
      description: "Basisprioriteten som beregnes fra de <xref:System.Diagnostics.Process.PriorityClass*>for den tilknyttede prosessen.</xref:System.Diagnostics.Process.PriorityClass*>"
  overload: System.Diagnostics.Process.BasePriority*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Plattformen er Windows 98 eller installasjonen (Windows Me); Angi den &lt;xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName&gt; egenskapen <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> å få tilgang til denne egenskapen i Windows 98 og Windows."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Prosessen ble avsluttet.       - eller - prosessen har ikke startet, slik at det er ingen prosess-ID."
  platform:
  - net462
- uid: System.Diagnostics.Process.BeginErrorReadLine
  id: BeginErrorReadLine
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: BeginErrorReadLine()
  nameWithType: Process.BeginErrorReadLine()
  fullName: System.Diagnostics.Process.BeginErrorReadLine()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Starter Asynkrone leseoperasjoner på den omadresserte <xref:System.Diagnostics.Process.StandardError*>dataflyten for applikasjonen.</xref:System.Diagnostics.Process.StandardError*>"
  remarks: "Den <xref:System.Diagnostics.Process.StandardError%2A>kan kopiere dataflyten synkron eller asynkron.</xref:System.Diagnostics.Process.StandardError%2A> Metoder som <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, og <xref:System.IO.StreamReader.ReadToEnd%2A>utføre synkron leseoperasjoner i utdata feilflyt av prosessen.</xref:System.IO.StreamReader.ReadToEnd%2A> </xref:System.IO.StreamReader.ReadLine%2A> </xref:System.IO.StreamReader.Read%2A> Disse synkron lese operasjoner ikke fyller ut før den tilknyttede <xref:System.Diagnostics.Process>skriver til den <xref:System.Diagnostics.Process.StandardError%2A>flyten eller lukker dataflyten.</xref:System.Diagnostics.Process.StandardError%2A> </xref:System.Diagnostics.Process>       I motsetning BeginErrorReadLine starter Asynkrone leseoperasjoner på den <xref:System.Diagnostics.Process.StandardError%2A>dataflyten.</xref:System.Diagnostics.Process.StandardError%2A> Denne metoden aktiverer angitte hendelsesbehandlingen for dataflyten-utdata, og returnerer umiddelbart til oppkalleren, som kan utføre andre arbeid mens utdataene dataflyten er rettet mot hendelsesbehandlingen.       Følg disse trinnene for å utføre Asynkrone leseoperasjoner på <xref:System.Diagnostics.Process.StandardError%2A>for en <xref:System.Diagnostics.Process>: 1.</xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.StandardError%2A>  Set <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> to `false`.</xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>      2.  Set <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardError%2A> to `true`.</xref:System.Diagnostics.ProcessStartInfo.RedirectStandardError%2A>      3.  Legg til hendelsesbehandlingen til den <xref:System.Diagnostics.Process.ErrorDataReceived>hendelsen.</xref:System.Diagnostics.Process.ErrorDataReceived> Hendelsesbehandlingen må samsvare med den <xref:System.Diagnostics.DataReceivedEventHandler?displayProperty=fullName>representanten signatur.</xref:System.Diagnostics.DataReceivedEventHandler?displayProperty=fullName>      4.  Start <xref:System.Diagnostics.Process>.</xref:System.Diagnostics.Process>      5.  Kall BeginErrorReadLine for <xref:System.Diagnostics.Process>.</xref:System.Diagnostics.Process> Kallet starter Asynkrone leseoperasjoner på <xref:System.Diagnostics.Process.StandardError%2A>.</xref:System.Diagnostics.Process.StandardError%2A>       Når Asynkrone leseoperasjoner start, hendelsesbehandlingen kalles hver gang de tilknyttede <xref:System.Diagnostics.Process>skriver en tekstlinje til den <xref:System.Diagnostics.Process.StandardError%2A>dataflyten.</xref:System.Diagnostics.Process.StandardError%2A> </xref:System.Diagnostics.Process>       Du kan avbryte en asynkron operasjon ved å kalle <xref:System.Diagnostics.Process.CancelErrorRead%2A>.</xref:System.Diagnostics.Process.CancelErrorRead%2A> Du kan avbryte leseoperasjonen ved oppkalleren eller hendelsesbehandlingen. Etter avbryting, kan du kalle BeginErrorReadLine på nytt for å gjenoppta Asynkrone leseoperasjoner.      > [!NOTE] > Du kan ikke blande asynkrone og Synkrone leseoperasjoner på en omadressert dataflyt. Når omdirigerte dataflyten for en <xref:System.Diagnostics.Process>er åpnet i asynkron eller synkron modus, mer leser alle operasjoner i denne dataflyten må være i samme modus.</xref:System.Diagnostics.Process> For eksempel ikke følger BeginErrorReadLine med et kall til <xref:System.IO.StreamReader.ReadLine%2A>på den <xref:System.Diagnostics.Process.StandardError%2A>dataflyten eller omvendt.</xref:System.Diagnostics.Process.StandardError%2A> </xref:System.IO.StreamReader.ReadLine%2A> Du kan imidlertid lese to ulike dataflyter i forskjellige modi. Du kan for eksempel kalle BeginErrorReadLine og kaller <xref:System.IO.StreamReader.ReadLine%2A>for den <xref:System.Diagnostics.Process.StandardOutput%2A>dataflyten.</xref:System.Diagnostics.Process.StandardOutput%2A> </xref:System.IO.StreamReader.ReadLine%2A>"
  example:
  - "The following example uses the `net view` command to list the available network resources on a remote computer. The user supplies the target computer name as a command-line argument. The user can also supply a file name for error output. The example collects the output of the net command, waits for the process to finish, and then writes the output results to the console. If the user supplies the optional error file, the example writes errors to the file.  \n  \n [!code-cpp[Process_AsyncStreams#2](~/add/codesnippet/cpp/m-system.diagnostics.pro_4_1.cpp)]\n [!code-cs[Process_AsyncStreams#2](~/add/codesnippet/csharp/m-system.diagnostics.pro_4_1.cs)]\n [!code-vb[Process_AsyncStreams#2](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_4_1.vb)]"
  syntax:
    content: public void BeginErrorReadLine ();
    parameters: []
  overload: System.Diagnostics.Process.BeginErrorReadLine*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "The &lt;xref:System.Diagnostics.ProcessStartInfo.RedirectStandardError%2A?displayProperty=fullName&gt; property is <xref uid=\"langword_csharp_false\" name=\"false\" href=\"\"></xref>.  \n  \n \\- or -  \n  \n An asynchronous read operation is already in progress on the <xref:System.Diagnostics.Process.StandardError*> stream.  \n  \n \\- or -  \n  \n The <xref:System.Diagnostics.Process.StandardError*> stream has been used by a synchronous read operation."
  platform:
  - net462
- uid: System.Diagnostics.Process.BeginOutputReadLine
  id: BeginOutputReadLine
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: BeginOutputReadLine()
  nameWithType: Process.BeginOutputReadLine()
  fullName: System.Diagnostics.Process.BeginOutputReadLine()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Starter Asynkrone leseoperasjoner på den omadresserte <xref:System.Diagnostics.Process.StandardOutput*>dataflyten for applikasjonen.</xref:System.Diagnostics.Process.StandardOutput*>"
  remarks: "Den <xref:System.Diagnostics.Process.StandardOutput%2A>kan kopiere dataflyten synkron eller asynkron.</xref:System.Diagnostics.Process.StandardOutput%2A> Metoder som <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, og <xref:System.IO.StreamReader.ReadToEnd%2A>utføre synkron leseoperasjoner i output-dataflyt av prosessen.</xref:System.IO.StreamReader.ReadToEnd%2A> </xref:System.IO.StreamReader.ReadLine%2A> </xref:System.IO.StreamReader.Read%2A> Disse synkron lese operasjoner ikke fyller ut før den tilknyttede <xref:System.Diagnostics.Process>skriver til den <xref:System.Diagnostics.Process.StandardOutput%2A>flyten eller lukker dataflyten.</xref:System.Diagnostics.Process.StandardOutput%2A> </xref:System.Diagnostics.Process>       I motsetning BeginOutputReadLine starter Asynkrone leseoperasjoner på den <xref:System.Diagnostics.Process.StandardOutput%2A>dataflyten.</xref:System.Diagnostics.Process.StandardOutput%2A> Denne metoden gjør det mulig for en angitt hendelsesbehandling for dataflyten-utdata, og returnerer umiddelbart til oppkalleren, som kan utføre andre arbeid mens utdataene dataflyten er rettet mot hendelsesbehandlingen.       Følg disse trinnene for å utføre Asynkrone leseoperasjoner på <xref:System.Diagnostics.Process.StandardOutput%2A>for en <xref:System.Diagnostics.Process>: 1.</xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.StandardOutput%2A>  Set <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> to `false`.</xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>      2.  Set <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput%2A> to `true`.</xref:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput%2A>      3.  Legg til hendelsesbehandlingen til den <xref:System.Diagnostics.Process.OutputDataReceived>hendelsen.</xref:System.Diagnostics.Process.OutputDataReceived> Hendelsesbehandlingen må samsvare med den <xref:System.Diagnostics.DataReceivedEventHandler?displayProperty=fullName>representanten signatur.</xref:System.Diagnostics.DataReceivedEventHandler?displayProperty=fullName>      4.  Start <xref:System.Diagnostics.Process>.</xref:System.Diagnostics.Process>      5.  Kall BeginOutputReadLine for <xref:System.Diagnostics.Process>.</xref:System.Diagnostics.Process> Kallet starter Asynkrone leseoperasjoner på <xref:System.Diagnostics.Process.StandardOutput%2A>.</xref:System.Diagnostics.Process.StandardOutput%2A>       Når Asynkrone leseoperasjoner start, hendelsesbehandlingen kalles hver gang de tilknyttede <xref:System.Diagnostics.Process>skriver en tekstlinje til den <xref:System.Diagnostics.Process.StandardOutput%2A>dataflyten.</xref:System.Diagnostics.Process.StandardOutput%2A> </xref:System.Diagnostics.Process>       Du kan avbryte en asynkron operasjon ved å kalle <xref:System.Diagnostics.Process.CancelOutputRead%2A>.</xref:System.Diagnostics.Process.CancelOutputRead%2A> Du kan avbryte leseoperasjonen ved oppkalleren eller hendelsesbehandlingen. Etter avbryting, kan du kalle BeginOutputReadLine på nytt for å gjenoppta Asynkrone leseoperasjoner.      > [!NOTE] > Du kan ikke blande asynkrone og Synkrone leseoperasjoner på en omadressert dataflyt. Når omdirigerte dataflyten for en <xref:System.Diagnostics.Process>er åpnet i asynkron eller synkron modus, mer leser alle operasjoner i denne dataflyten må være i samme modus.</xref:System.Diagnostics.Process> For eksempel ikke følger BeginOutputReadLine med et kall til <xref:System.IO.StreamReader.ReadLine%2A>på den <xref:System.Diagnostics.Process.StandardOutput%2A>dataflyten eller omvendt.</xref:System.Diagnostics.Process.StandardOutput%2A> </xref:System.IO.StreamReader.ReadLine%2A> Du kan imidlertid lese to ulike dataflyter i forskjellige modi. Du kan for eksempel kalle BeginOutputReadLine og kaller <xref:System.IO.StreamReader.ReadLine%2A>for den <xref:System.Diagnostics.Process.StandardError%2A>dataflyten.</xref:System.Diagnostics.Process.StandardError%2A> </xref:System.IO.StreamReader.ReadLine%2A>"
  example:
  - "The following example illustrates how to perform asynchronous read operations on the redirected <xref:System.Diagnostics.Process.StandardOutput%2A> stream of the `sort` command. The `sort` command is a console application that reads and sorts text input.  \n  \n The example creates an event delegate for the `SortOutputHandler` event handler and associates it with the <xref:System.Diagnostics.Process.OutputDataReceived> event. The event handler receives text lines from the redirected <xref:System.Diagnostics.Process.StandardOutput%2A> stream, formats the text, and writes the text to the screen.  \n  \n [!code-cpp[Process_AsyncStreams#1](~/add/codesnippet/cpp/m-system.diagnostics.pro_13_1.cpp)]\n [!code-vb[Process_AsyncStreams#1](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_13_1.vb)]\n [!code-cs[Process_AsyncStreams#1](~/add/codesnippet/csharp/m-system.diagnostics.pro_13_1.cs)]"
  syntax:
    content: public void BeginOutputReadLine ();
    parameters: []
  overload: System.Diagnostics.Process.BeginOutputReadLine*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "The &lt;xref:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput%2A?displayProperty=fullName&gt; property is <xref uid=\"langword_csharp_false\" name=\"false\" href=\"\"></xref>.  \n  \n \\- or -  \n  \n An asynchronous read operation is already in progress on the <xref:System.Diagnostics.Process.StandardOutput*> stream.  \n  \n \\- or -  \n  \n The <xref:System.Diagnostics.Process.StandardOutput*> stream has been used by a synchronous read operation."
  platform:
  - net462
- uid: System.Diagnostics.Process.CancelErrorRead
  id: CancelErrorRead
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: CancelErrorRead()
  nameWithType: Process.CancelErrorRead()
  fullName: System.Diagnostics.Process.CancelErrorRead()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Avbryter den asynkrone leseoperasjon på den omadresserte <xref:System.Diagnostics.Process.StandardError*>dataflyten for en applikasjon.</xref:System.Diagnostics.Process.StandardError*>"
  remarks: "<xref:System.Diagnostics.Process.BeginErrorReadLine%2A>starter en asynkron leseoperasjon på den <xref:System.Diagnostics.Process.StandardError%2A>dataflyten.</xref:System.Diagnostics.Process.StandardError%2A></xref:System.Diagnostics.Process.BeginErrorReadLine%2A> CancelErrorRead avsluttes den asynkrone skrivebeskyttede operasjonen.       Du kan fortsette asynkrone leseoperasjonen etter avbryting, ved å kalle <xref:System.Diagnostics.Process.BeginErrorReadLine%2A>på nytt.</xref:System.Diagnostics.Process.BeginErrorReadLine%2A>       Når du kaller CancelErrorRead, lese alle pågående operasjoner for <xref:System.Diagnostics.Process.StandardError%2A>er fullført, og deretter hendelsesbehandlingen er deaktivert.</xref:System.Diagnostics.Process.StandardError%2A> Alle videre omdirigert utdata til <xref:System.Diagnostics.Process.StandardError%2A>er lagret i en buffer.</xref:System.Diagnostics.Process.StandardError%2A> Hvis du aktiverer hendelsesbehandlingen med et kall til på nytt <xref:System.Diagnostics.Process.BeginErrorReadLine%2A>, lagret utdataene sendes til hendelsesbehandlingen og Asynkrone leseoperasjoner gjenoppta.</xref:System.Diagnostics.Process.BeginErrorReadLine%2A> Hvis du vil endre hendelsesbehandlingen før du fortsetter Asynkrone leseoperasjoner, må du fjerne den eksisterende hendelsesbehandlingen før du legger til nye hendelsesbehandlingen: ```   // At this point the DataReceivedEventHandler(ErrorHandler1)    // has executed a CancelErrorRead.      // Remove the prior event handler.   process.ErrorDataReceived -=        new DataReceivedEventHandler(ErrorHandler1);      // Register a new event handler.   process.ErrorDataReceived +=        new DataReceivedEventHandler(ErrorHandler2);      // Call the corresponding BeginErrorReadLine.   process.BeginErrorReadLine();   ```       >  [!NOTE] > du kan ikke blande asynkrone og Synkrone leseoperasjoner på den omadresserte <xref:System.Diagnostics.Process.StandardError%2A>dataflyten.</xref:System.Diagnostics.Process.StandardError%2A> Når omdirigerte dataflyten for en <xref:System.Diagnostics.Process>er åpnet i asynkron eller synkron modus, mer leser alle operasjoner i denne dataflyten må være i samme modus.</xref:System.Diagnostics.Process> Hvis du avbryter en asynkron leseoperasjon på <xref:System.Diagnostics.Process.StandardError%2A>og trenger å lese fra dataflyten på nytt, må du bruke <xref:System.Diagnostics.Process.BeginErrorReadLine%2A>å gjenoppta Asynkrone leseoperasjoner.</xref:System.Diagnostics.Process.BeginErrorReadLine%2A> </xref:System.Diagnostics.Process.StandardError%2A> CancelErrorRead følger ikke med et kall til synkron skrivebeskyttede metodene for <xref:System.Diagnostics.Process.StandardError%2A>eksempel <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, eller <xref:System.IO.StreamReader.ReadToEnd%2A>.</xref:System.IO.StreamReader.ReadToEnd%2A> </xref:System.IO.StreamReader.ReadLine%2A> </xref:System.IO.StreamReader.Read%2A> </xref:System.Diagnostics.Process.StandardError%2A>"
  example:
  - "The following example starts the `nmake` command with user supplied arguments. The error and output streams are read asynchronously; the collected text lines are displayed to the console as well as written to a log file. If the command output exceeds a specified number of lines, the asynchronous read operations are canceled.  \n  \n [!code-cpp[Process_AsyncStreams#3](~/add/codesnippet/cpp/m-system.diagnostics.pro_7_1.cpp)]\n [!code-cs[Process_AsyncStreams#3](~/add/codesnippet/csharp/m-system.diagnostics.pro_7_1.cs)]\n [!code-vb[Process_AsyncStreams#3](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_7_1.vb)]"
  syntax:
    content: public void CancelErrorRead ();
    parameters: []
  overload: System.Diagnostics.Process.CancelErrorRead*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Den <xref:System.Diagnostics.Process.StandardError*>dataflyten er ikke aktivert for asynkrone leseoperasjoner.</xref:System.Diagnostics.Process.StandardError*>"
  platform:
  - net462
- uid: System.Diagnostics.Process.CancelOutputRead
  id: CancelOutputRead
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: CancelOutputRead()
  nameWithType: Process.CancelOutputRead()
  fullName: System.Diagnostics.Process.CancelOutputRead()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Avbryter den asynkrone leseoperasjon på den omadresserte <xref:System.Diagnostics.Process.StandardOutput*>dataflyten for en applikasjon.</xref:System.Diagnostics.Process.StandardOutput*>"
  remarks: "<xref:System.Diagnostics.Process.BeginOutputReadLine%2A>starter en asynkron leseoperasjon på den <xref:System.Diagnostics.Process.StandardOutput%2A>dataflyten.</xref:System.Diagnostics.Process.StandardOutput%2A></xref:System.Diagnostics.Process.BeginOutputReadLine%2A> CancelOutputRead avsluttes den asynkrone skrivebeskyttede operasjonen.       Du kan fortsette Asynkrone leseoperasjoner etter avbryting, ved å kalle <xref:System.Diagnostics.Process.BeginOutputReadLine%2A>på nytt.</xref:System.Diagnostics.Process.BeginOutputReadLine%2A>       Når du kaller CancelOutputRead, lese alle pågående operasjoner for <xref:System.Diagnostics.Process.StandardOutput%2A>er fullført, og deretter hendelsesbehandlingen er deaktivert.</xref:System.Diagnostics.Process.StandardOutput%2A> Alle videre omdirigert utdata til <xref:System.Diagnostics.Process.StandardOutput%2A>er lagret i en buffer.</xref:System.Diagnostics.Process.StandardOutput%2A> Hvis du aktiverer hendelsesbehandlingen med et kall til på nytt <xref:System.Diagnostics.Process.BeginOutputReadLine%2A>, lagret utdataene sendes til hendelsesbehandlingen og Asynkrone leseoperasjoner gjenoppta.</xref:System.Diagnostics.Process.BeginOutputReadLine%2A> Hvis du vil endre hendelsesbehandlingen før du fortsetter Asynkrone leseoperasjoner, må du fjerne den eksisterende hendelsesbehandlingen før du legger til nye hendelsesbehandlingen: ```   // At this point the DataReceivedEventHandler(OutputHandler1)    // has executed a CancelOutputRead.      // Remove the prior event handler.   process.OutputDataReceived -=        new DataReceivedEventHandler(OutputHandler1);      // Register a new event handler.   process.OutputDataReceived +=        new DataReceivedEventHandler(OutputHandler2);      // Call the corresponding BeginOutputReadLine.   process.BeginOutputReadLine();   ```       >  [!NOTE] > du kan ikke blande asynkrone og Synkrone leseoperasjoner på den omadresserte <xref:System.Diagnostics.Process.StandardOutput%2A>dataflyten.</xref:System.Diagnostics.Process.StandardOutput%2A> Når omdirigerte dataflyten for en <xref:System.Diagnostics.Process>er åpnet i asynkron eller synkron modus, mer leser alle operasjoner i denne dataflyten må være i samme modus.</xref:System.Diagnostics.Process> Hvis du avbryter en asynkron leseoperasjon på <xref:System.Diagnostics.Process.StandardOutput%2A>og trenger å lese fra dataflyten på nytt, må du bruke <xref:System.Diagnostics.Process.BeginOutputReadLine%2A>å gjenoppta Asynkrone leseoperasjoner.</xref:System.Diagnostics.Process.BeginOutputReadLine%2A> </xref:System.Diagnostics.Process.StandardOutput%2A> CancelOutputRead følger ikke med et kall til synkron skrivebeskyttede metodene for <xref:System.Diagnostics.Process.StandardOutput%2A>eksempel <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, eller <xref:System.IO.StreamReader.ReadToEnd%2A>.</xref:System.IO.StreamReader.ReadToEnd%2A> </xref:System.IO.StreamReader.ReadLine%2A> </xref:System.IO.StreamReader.Read%2A> </xref:System.Diagnostics.Process.StandardOutput%2A>"
  example:
  - "The following example starts the `nmake` command with user supplied arguments. The error and output streams are read asynchronously; the collected text lines are displayed to the console as well as written to a log file. If the command output exceeds a specified number of lines, the asynchronous read operations are canceled.  \n  \n [!code-cpp[Process_AsyncStreams#3](~/add/codesnippet/cpp/m-system.diagnostics.pro_3_1.cpp)]\n [!code-cs[Process_AsyncStreams#3](~/add/codesnippet/csharp/m-system.diagnostics.pro_3_1.cs)]\n [!code-vb[Process_AsyncStreams#3](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_3_1.vb)]"
  syntax:
    content: public void CancelOutputRead ();
    parameters: []
  overload: System.Diagnostics.Process.CancelOutputRead*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Den <xref:System.Diagnostics.Process.StandardOutput*>dataflyten er ikke aktivert for asynkrone leseoperasjoner.</xref:System.Diagnostics.Process.StandardOutput*>"
  platform:
  - net462
- uid: System.Diagnostics.Process.Close
  id: Close
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: Close()
  nameWithType: Process.Close()
  fullName: System.Diagnostics.Process.Close()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Frigjør alle ressurser som er tilknyttet denne komponenten."
  remarks: "Metoden Close fører til at prosessen stoppe venter Avslutt hvis den ventet, lukker prosessreferanse, og fjerner prosessen egenskaper. Lukk lukkes ikke standard utdata, inndataene og feil-lesere og skrivere hvis de er det refereres til eksternt.      > [!NOTE] > Den <xref:System.Diagnostics.Process.Dispose%2A>metodekall avsluttende.</xref:System.Diagnostics.Process.Dispose%2A> Starter den <xref:System.Diagnostics.Process>objekt i en `using` blokk disposes ressurser uten å kalle Lukk.</xref:System.Diagnostics.Process>"
  example:
  - "The following example starts an instance of Notepad. It then retrieves the physical memory usage of the associated process at 2-second intervals for a maximum of 10 seconds. The example detects whether the process exits before 10 seconds have elapsed. The example closes the process if it is still running after 10 seconds.  \n  \n [!code-cpp[process_refresh#1](~/add/codesnippet/cpp/m-system.diagnostics.pro_0_1.cpp)]\n [!code-cs[process_refresh#1](~/add/codesnippet/csharp/m-system.diagnostics.pro_0_1.cs)]\n [!code-vb[process_refresh#1](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_0_1.vb)]"
  syntax:
    content: public void Close ();
    parameters: []
  overload: System.Diagnostics.Process.Close*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.Process.CloseMainWindow
  id: CloseMainWindow
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: CloseMainWindow()
  nameWithType: Process.CloseMainWindow()
  fullName: System.Diagnostics.Process.CloseMainWindow()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Lukker en prosess som har et brukergrensesnitt ved å sende en close-melding til hovedvinduet."
  remarks: "Når en prosess kjøres, er den meldingen løkken i en ventende tilstand. Meldingen sløyfen utfører hver gang en Windows-melding er sendt til prosessen av operativsystemet. Kaller CloseMainWindow sender en forespørsel om nær hovedvinduet som, i et velformet program, lukker underordnede windows og opphever alle kjørende meldingen løkker for programmet. Forespørselen om å avslutte prosessen ved å kalle CloseMainWindow tvinger ikke programmet avsluttes. Programmet kan be om Brukerbekreftelse før du avslutter, eller den kan avslå for å avslutte. Hvis du vil tvinge programmet til å avslutte, kan du bruke den <xref:System.Diagnostics.Process.Kill%2A>metoden.</xref:System.Diagnostics.Process.Kill%2A> Virkemåten for CloseMainWindow er identisk med en bruker lukker en applikasjon hovedvinduet med system-menyen. Forespørselen om å avslutte prosessen lukker hovedvinduet tvinger derfor ikke programmet avsluttes umiddelbart.       Data redigert prosessen eller ressurser tildelt prosessen kan gå tapt hvis du kaller <xref:System.Diagnostics.Process.Kill%2A>.</xref:System.Diagnostics.Process.Kill%2A> <xref:System.Diagnostics.Process.Kill%2A>forårsaker en unormal avsluttet, og bør brukes bare når det er nødvendig.</xref:System.Diagnostics.Process.Kill%2A> CloseMainWindow aktiverer en vanlige avslutning av prosessen og lukker alle windows, så er det best for programmer med et grensesnitt. Hvis CloseMainWindow mislykkes, kan du bruke <xref:System.Diagnostics.Process.Kill%2A>prosessen må avsluttes.</xref:System.Diagnostics.Process.Kill%2A> <xref:System.Diagnostics.Process.Kill%2A>er den eneste måten å avslutte prosessene som ikke har grafiske grensesnitt.</xref:System.Diagnostics.Process.Kill%2A>       Du kan ringe <xref:System.Diagnostics.Process.Kill%2A>og CloseMainWindow bare for prosessene som kjører på den lokale datamaskinen.</xref:System.Diagnostics.Process.Kill%2A> Du kan ikke føre til at prosesser på eksterne datamaskiner for å avslutte. Du kan bare vise informasjon om som kjører på eksterne datamaskiner."
  example:
  - "The following example starts an instance of Notepad. It then retrieves the physical memory usage of the associated process at 2 second intervals for a maximum of 10 seconds. The example detects whether the process exits before 10 seconds have elapsed. The example closes the process if it is still running after 10 seconds.  \n  \n [!code-cpp[process_refresh#1](~/add/codesnippet/cpp/m-system.diagnostics.pro_18_1.cpp)]\n [!code-cs[process_refresh#1](~/add/codesnippet/csharp/m-system.diagnostics.pro_18_1.cs)]\n [!code-vb[process_refresh#1](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_18_1.vb)]"
  syntax:
    content: public bool CloseMainWindow ();
    parameters: []
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Hvis Lukk meldingen ble sendt; <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> hvis den tilknyttede prosessen ikke har en hovedvinduet, eller hvis hovedvinduet er deaktivert (for eksempel hvis en modal dialogboks vises)."
  overload: System.Diagnostics.Process.CloseMainWindow*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Plattformen er Windows 98 eller installasjonen (Windows Me); Angi den &lt;xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName&gt; egenskapen <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> å få tilgang til denne egenskapen i Windows 98 og Windows."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Prosessen er allerede avsluttet.       - eller - ingen prosess er knyttet til dette <xref href=&quot;System.Diagnostics.Process&quot;> </xref> objektet."
  platform:
  - net462
- uid: System.Diagnostics.Process.Dispose(System.Boolean)
  id: Dispose(System.Boolean)
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: Dispose(Boolean)
  nameWithType: Process.Dispose(Boolean)
  fullName: System.Diagnostics.Process.Dispose(Boolean)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Frigi alle ressurser som brukes av denne prosessen."
  syntax:
    content: protected override void Dispose (bool disposing);
    parameters:
    - id: disposing
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>å frigjøre både administrerte og uforvaltede ressurser. <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> frigi bare uforvaltede ressurser."
  overload: System.Diagnostics.Process.Dispose*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.Process.EnableRaisingEvents
  id: EnableRaisingEvents
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: EnableRaisingEvents
  nameWithType: Process.EnableRaisingEvents
  fullName: System.Diagnostics.Process.EnableRaisingEvents
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Henter eller angir om den <xref href=&quot;System.Diagnostics.Process.Exited&quot;> </xref> hendelsen skal oppstå når du avslutter prosessen."
  remarks: "Egenskapen EnableRaisingEvents angir om komponenten skal varsles når operativsystemet er avsluttet en prosess. Egenskapen EnableRaisingEvents brukes til å varsle programmet som en prosess ble avsluttet i asynkron behandling. Tving programmet synkront vente for en avslutningshendelse som (som avbryter behandling av programmet før hendelsen avsluttes oppstod), bruker den <xref:System.Diagnostics.Process.WaitForExit%2A>metoden.</xref:System.Diagnostics.Process.WaitForExit%2A>      > [!NOTE] > Hvis du bruker Visual Studio, og dobbeltklikk en <xref:System.Diagnostics.Process>komponenten i prosjektet, en <xref:System.Diagnostics.Process.Exited>hendelsen representanten og hendelsesbehandlingen genereres automatisk.</xref:System.Diagnostics.Process.Exited> </xref:System.Diagnostics.Process> Ekstra kode angir egenskapen EnableRaisingEvents til `false`. Du må endre denne egenskapen til `true` for hendelsesbehandlingen som skal utføres når den tilknyttede prosessen avsluttes.       Når en tilknyttede prosessen avslutter etter avsluttet av operativsystemet enten gjennom en vanlig eller unormal avslutning varsler operativsystemet hver prosesskomponenten prosessen ble tilknyttet, så lenge komponentens EnableRaisingEvents verdi er `true`. Hvis en komponent startet prosessen, kan deretter komponenten tilgang til administrative informasjonen for den tilknyttede prosessen som fremdeles som lagres av operativsystemet. Denne informasjonen omfatter den <xref:System.Diagnostics.Process.ExitTime%2A>, og <xref:System.Diagnostics.Process.ExitCode%2A>.</xref:System.Diagnostics.Process.ExitCode%2A> </xref:System.Diagnostics.Process.ExitTime%2A>       Når den tilknyttede prosessen avsluttes, <xref:System.Diagnostics.Process.Handle%2A>av komponenten lenger peker til en eksisterende prosess-ressurs.</xref:System.Diagnostics.Process.Handle%2A> I stedet kan den bare brukes til å få tilgang til den operativsystemet informasjon om ressursen prosessen. Operativsystemet er oppmerksom på at det finnes referanser til avsluttet prosesser som ikke er utgitt av <xref:System.Diagnostics.Process>komponenter, slik at den beholder den <xref:System.Diagnostics.Process.ExitTime%2A>og <xref:System.Diagnostics.Process.Handle%2A>informasjonen i minnet.</xref:System.Diagnostics.Process.Handle%2A> </xref:System.Diagnostics.Process.ExitTime%2A> </xref:System.Diagnostics.Process>       Det er en kostnaden for å se for en prosess å avslutte. Hvis EnableRaisingEvents `true`, <xref:System.Diagnostics.Process.Exited>denne hendelsen oppstår når den tilknyttede prosessen avslutter.</xref:System.Diagnostics.Process.Exited> Prosedyrer som du har angitt for den <xref:System.Diagnostics.Process.Exited>hendelsen kjøre på dette tidspunktet.</xref:System.Diagnostics.Process.Exited>       Noen ganger programmet starter en prosess, men trenger ikke å bli varslet om avslutning. Programmet kan for eksempel start Notisblokk slik at brukeren kan utføre tekstformatering, men Kontroller ytterligere bruken av den Notisblokk. Du kan velge å ikke bli varslet når-prosessen avslutter, fordi den ikke er relevante for kontinuerlig drift av programmet. Angi EnableRaisingEvents til `false` lagrer systemressurser."
  example:
  - "The following code example creates a process that prints a file. It sets the EnableRaisingEvents property to cause the process to raise the <xref:System.Diagnostics.Process.Exited> event when it exits. The <xref:System.Diagnostics.Process.Exited> event handler displays process information.  \n  \n [!code-vb[System.Diagnostics.Process.EnableExited#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_38_1.vb)]\n [!code-cs[System.Diagnostics.Process.EnableExited#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_38_1.cs)]"
  syntax:
    content: public bool EnableRaisingEvents { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Hvis den <xref href=&quot;System.Diagnostics.Process.Exited&quot;> </xref> hendelsen skal oppstå når den tilknyttede prosessen avsluttes (via en avsluttes eller et kall til <xref:System.Diagnostics.Process.Kill*>); ellers <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>.</xref:System.Diagnostics.Process.Kill*> Standard <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Diagnostics.Process.EnableRaisingEvents*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.Process.EnterDebugMode
  id: EnterDebugMode
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: EnterDebugMode()
  nameWithType: Process.EnterDebugMode()
  fullName: System.Diagnostics.Process.EnterDebugMode()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Legger en <xref href=&quot;System.Diagnostics.Process&quot;> </xref> behandler komponenten i tilstand for å kunne samhandle med operativsystemet som kjører i en spesiell modus ved å aktivere egenskapen opprinnelig <xref uid=&quot;langword_csharp_SeDebugPrivilege&quot; name=&quot;SeDebugPrivilege&quot; href=&quot;&quot;> </xref> på gjeldende tråd."
  remarks: "Noen operativsystemet som kjører i en spesiell modus. Forsøk på å lese egenskapene for eller legge ved disse prosessene er ikke mulig med mindre du har ringt EnterDebugMode for komponenten. Kall <xref:System.Diagnostics.Process.LeaveDebugMode%2A>Når du ikke lenger trenger tilgang til disse prosessene som kjører i spesielle modus.</xref:System.Diagnostics.Process.LeaveDebugMode%2A>"
  syntax:
    content: public static void EnterDebugMode ();
    parameters: []
  overload: System.Diagnostics.Process.EnterDebugMode*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.Process.ErrorDataReceived
  id: ErrorDataReceived
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: ErrorDataReceived
  nameWithType: Process.ErrorDataReceived
  fullName: System.Diagnostics.Process.ErrorDataReceived
  type: Event
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Oppstår når et program skriver til den omadresserte <xref:System.Diagnostics.Process.StandardError*>dataflyten.</xref:System.Diagnostics.Process.StandardError*>"
  remarks: "Hendelsen ErrorDataReceived indikerer at den tilknyttede prosessen er skrevet til den omadresserte <xref:System.Diagnostics.Process.StandardError%2A>dataflyten.</xref:System.Diagnostics.Process.StandardError%2A>       Hendelsen oppstår bare under Asynkrone leseoperasjoner <xref:System.Diagnostics.Process.StandardError%2A>.</xref:System.Diagnostics.Process.StandardError%2A> Hvis du vil starte Asynkrone leseoperasjoner, må du omadressere <xref:System.Diagnostics.Process.StandardError%2A>dataflyten for et <xref:System.Diagnostics.Process>, Legg til hendelsesbehandlingen til ErrorDataReceived-hendelse, og kall <xref:System.Diagnostics.Process.BeginErrorReadLine%2A>.</xref:System.Diagnostics.Process.BeginErrorReadLine%2A> </xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.StandardError%2A> Deretter ErrorDataReceived hendelsen signaler hver gang prosessen skriver en linje til omdirigerte <xref:System.Diagnostics.Process.StandardError%2A>dataflyten før prosessen avslutter eller samtaler <xref:System.Diagnostics.Process.CancelErrorRead%2A>.</xref:System.Diagnostics.Process.CancelErrorRead%2A> </xref:System.Diagnostics.Process.StandardError%2A>      > [!NOTE] > Programmet som behandler asynkrone utdataene kalle den <xref:System.Diagnostics.Process.WaitForExit%2A>metode for å sikre at utdatabufferen har blitt tømt.</xref:System.Diagnostics.Process.WaitForExit%2A>"
  example:
  - "The following example uses the `net view` command to list the available network resources on a remote computer. The user supplies the target computer name as a command-line argument. The user can also supply a file name for error output. The example collects the output of the net command, waits for the process to finish, and then writes the output results to the console. If the user supplies the optional error file, the example writes errors to the file.  \n  \n [!code-cpp[Process_AsyncStreams#2](~/add/codesnippet/cpp/e-system.diagnostics.pro_0_1.cpp)]\n [!code-cs[Process_AsyncStreams#2](~/add/codesnippet/csharp/e-system.diagnostics.pro_0_1.cs)]\n [!code-vb[Process_AsyncStreams#2](~/add/codesnippet/visualbasic/e-system.diagnostics.pro_0_1.vb)]"
  syntax:
    content: public event System.Diagnostics.DataReceivedEventHandler ErrorDataReceived;
    return:
      type: System.Diagnostics.DataReceivedEventHandler
      description: "Som skal legges til."
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.Process.ExitCode
  id: ExitCode
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: ExitCode
  nameWithType: Process.ExitCode
  fullName: System.Diagnostics.Process.ExitCode
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Henter verdien som den tilknyttede prosessen angitt når den er avsluttet."
  remarks: "Bruk ExitCode til å hente status systemprosessen returneres når den er avsluttet. Du kan bruke avsluttingskoden mye som et heltall returverdi fra en `main()` prosedyren.       ExitCode-verdien for en prosess gjenspeiler bestemte convention implementeres av programutvikleren for denne prosessen. Hvis du bruker kodeverdi Avslutt foreta avgjørelsene i koden, må du at Avslutt kode convention brukes av prosessen.       Utviklere vanligvis angir en vellykket avsluttes med en ExitCode verdien null, og angi feil ved nullverdier metoden kall kan bruke til å finne årsaken til en unormal blir avsluttet. Det er ikke nødvendig å følge disse retningslinjene, men de er i convention.       Hvis du prøver å få ExitCode før prosessen er avsluttet, oppstår det et unntak i forsøket. Undersøk den <xref:System.Diagnostics.Process.HasExited%2A>egenskapen først for å bekrefte om den tilknyttede prosessen ble avsluttet.</xref:System.Diagnostics.Process.HasExited%2A>      > [!NOTE] > Når standard utdata er omadressert til asynkrone hendelsesbehandling, er det mulig at output-behandling ikke vil har fullført når <xref:System.Diagnostics.Process.HasExited%2A>returnerer `true`.</xref:System.Diagnostics.Process.HasExited%2A> For å sikre at asynkrone hendelseshåndtering er fullført, kan du kalle <xref:System.Diagnostics.Process.WaitForExit>overbelastning som tar ingen parameter før du kontrollerer <xref:System.Diagnostics.Process.HasExited%2A>.</xref:System.Diagnostics.Process.HasExited%2A> </xref:System.Diagnostics.Process.WaitForExit>       Du kan bruke den <xref:System.Diagnostics.Process.CloseMainWindow%2A>eller <xref:System.Diagnostics.Process.Kill%2A>metode til å få en tilknyttet prosess å avslutte.</xref:System.Diagnostics.Process.Kill%2A> </xref:System.Diagnostics.Process.CloseMainWindow%2A>       Det er to måter å blir varslet når den tilknyttede prosessen avsluttes: synkront og asynkront. Synkron varsling avhengig kaller den <xref:System.Diagnostics.Process.WaitForExit%2A>metode for å stoppe behandlingen av programmet til den tilknyttede komponenten avslutter.</xref:System.Diagnostics.Process.WaitForExit%2A> Asynkron varsling avhengig av <xref:System.Diagnostics.Process.Exited>hendelsen.</xref:System.Diagnostics.Process.Exited> Når du bruker asynkron varsling <xref:System.Diagnostics.Process.EnableRaisingEvents%2A>må settes til `true` for den <xref:System.Diagnostics.Process>komponent som skal motta varsling prosessen ble avsluttet.</xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.EnableRaisingEvents%2A>"
  example:
  - "The following example starts an instance of Notepad. The example then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays the process's exit code.  \n  \n [!code-cpp[Diag_Process_MemoryProperties64#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_6_1.cpp)]\n [!code-cs[Diag_Process_MemoryProperties64#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_6_1.cs)]\n [!code-vb[Diag_Process_MemoryProperties64#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_6_1.vb)]"
  syntax:
    content: public int ExitCode { get; }
    return:
      type: System.Int32
      description: "Koden som den tilknyttede prosessen angitt når den er avsluttet."
  overload: System.Diagnostics.Process.ExitCode*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Prosessen ble ikke avsluttet.       - eller - prosessen <xref:System.Diagnostics.Process.Handle*>er ikke gyldig.</xref:System.Diagnostics.Process.Handle*>"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Du prøver å få tilgang til ExitCode-egenskapen for en prosess som kjører på en ekstern datamaskin. Denne egenskapen er bare tilgjengelig for prosessene som kjører på den lokale datamaskinen."
  platform:
  - net462
- uid: System.Diagnostics.Process.Exited
  id: Exited
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: Exited
  nameWithType: Process.Exited
  fullName: System.Diagnostics.Process.Exited
  type: Event
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Forekommer når en prosessen avsluttes."
  remarks: "Hendelsen Exited indikerer at den tilknyttede prosessen ble avsluttet. Denne forekomsten betyr enten at prosessen avsluttede (avbrutt) eller ble lukket. Denne hendelsen kan oppstå hvis verdien for den <xref:System.Diagnostics.Process.EnableRaisingEvents%2A>egenskapen `true`.</xref:System.Diagnostics.Process.EnableRaisingEvents%2A>       Det er to måter å blir varslet når den tilknyttede prosessen avsluttes: synkront og asynkront. Synkron varsling betyr kaller den <xref:System.Diagnostics.Process.WaitForExit%2A>metode til å blokkere gjeldende tråd før prosessen avslutter.</xref:System.Diagnostics.Process.WaitForExit%2A> Asynkron varsling bruker hendelsen Exited, som tillater kall tråden fortsette kjøringen i mellomtiden. I det siste tilfellet <xref:System.Diagnostics.Process.EnableRaisingEvents%2A>må settes til `true` for programmet som kaller mottar hendelsen Exited.</xref:System.Diagnostics.Process.EnableRaisingEvents%2A>       Når operativsystemet slås av en prosess varsler alle andre prosesser som har registrert behandlingsprogrammer for Exited-hendelsen. Behandlingen av prosessen som bare er avsluttet nå, kan brukes til å få tilgang til enkelte egenskaper som <xref:System.Diagnostics.Process.ExitTime%2A>og <xref:System.Diagnostics.Process.HasExited%2A>at operativsystemet opprettholder før den frigir håndtaket fullstendig.</xref:System.Diagnostics.Process.HasExited%2A> </xref:System.Diagnostics.Process.ExitTime%2A>      > [!NOTE] > Selv om du har en referanse til en exited prosess, du kan ikke kalle <xref:System.Diagnostics.Process.Start%2A>på nytt for å koble til den samme prosessen.</xref:System.Diagnostics.Process.Start%2A> Kaller <xref:System.Diagnostics.Process.Start%2A>frigir den tilknyttede prosessen og kobler til en prosess med den samme filen, men en helt ny <xref:System.Diagnostics.Process.Handle%2A>.</xref:System.Diagnostics.Process.Handle%2A> automatisk</xref:System.Diagnostics.Process.Start%2A>       Hvis du vil ha mer informasjon om bruk av hendelsen Exited i Windows Forms-programmer, kan du se den <xref:System.Diagnostics.Process.SynchronizingObject%2A>egenskapen.</xref:System.Diagnostics.Process.SynchronizingObject%2A>"
  example:
  - "The following code example creates a process that prints a file. It raises the Exited event when the process exits because the <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> property was set when the process was created. The Exited event handler displays process information.  \n  \n [!code-vb[System.Diagnostics.Process.EnableExited#1](~/add/codesnippet/visualbasic/e-system.diagnostics.pro_1_1.vb)]\n [!code-cs[System.Diagnostics.Process.EnableExited#1](~/add/codesnippet/csharp/e-system.diagnostics.pro_1_1.cs)]"
  syntax:
    content: public event EventHandler Exited;
    return:
      type: System.EventHandler
      description: "Som skal legges til."
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.Process.ExitTime
  id: ExitTime
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: ExitTime
  nameWithType: Process.ExitTime
  fullName: System.Diagnostics.Process.ExitTime
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Henter tidspunktet da den tilknyttede prosessen ble avsluttet."
  remarks: "Hvis prosessen ikke er avsluttet, oppstår det et unntak under forsøk på å hente egenskapen ExitTime. Bruk <xref:System.Diagnostics.Process.HasExited%2A>før du henter ExitTime-egenskapen for å finne ut om den tilknyttede prosessen ble avsluttet.</xref:System.Diagnostics.Process.HasExited%2A>"
  example:
  - "The following code example creates a process that prints a file. The process raises the <xref:System.Diagnostics.Process.Exited> event when it exits, and the event handler displays the ExitTime property and other process information.  \n  \n [!code-vb[System.Diagnostics.Process.EnableExited#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_14_1.vb)]\n [!code-cs[System.Diagnostics.Process.EnableExited#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_14_1.cs)]"
  syntax:
    content: public DateTime ExitTime { get; }
    return:
      type: System.DateTime
      description: "En <xref:System.DateTime>som angir når den tilknyttede prosessen ble avsluttet.</xref:System.DateTime>"
  overload: System.Diagnostics.Process.ExitTime*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Plattformen er Windows 98 eller installasjonen (Windows Me), som ikke støtter denne egenskapen."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Du prøver å få tilgang til egenskapen ExitTime for en prosess som kjører på en ekstern datamaskin. Denne egenskapen er bare tilgjengelig for prosessene som kjører på den lokale datamaskinen."
  platform:
  - net462
- uid: System.Diagnostics.Process.GetCurrentProcess
  id: GetCurrentProcess
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: GetCurrentProcess()
  nameWithType: Process.GetCurrentProcess()
  fullName: System.Diagnostics.Process.GetCurrentProcess()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Henter en ny <xref href=&quot;System.Diagnostics.Process&quot;> </xref> komponent knyttes til aktive prosessen."
  remarks: "Bruk denne metoden til å opprette en ny <xref:System.Diagnostics.Process>serverforekomsten og knytt det til prosessen ressursen på den lokale datamaskinen.</xref:System.Diagnostics.Process>       Som den lignende <xref:System.Diagnostics.Process.GetProcessById%2A>, <xref:System.Diagnostics.Process.GetProcessesByName%2A>, og <xref:System.Diagnostics.Process.GetProcesses%2A>metoder, GetCurrentProcess knytter en eksisterende ressurs til en ny <xref:System.Diagnostics.Process>komponent.</xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.GetProcesses%2A> </xref:System.Diagnostics.Process.GetProcessesByName%2A> </xref:System.Diagnostics.Process.GetProcessById%2A>"
  example:
  - "The following example retrieves information of the current process, processes running on the local computer, all instances of Notepad running on the local computer, and a specific process on the local computer. It then retrieves information for the same processes on a remote computer.  \n  \n [!code-cpp[Process.GetProcesses_noexception#1](~/add/codesnippet/cpp/m-system.diagnostics.pro_10_1.cpp)]\n [!code-vb[Process.GetProcesses_noexception#1](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_10_1.vb)]\n [!code-cs[Process.GetProcesses_noexception#1](~/add/codesnippet/csharp/m-system.diagnostics.pro_10_1.cs)]"
  syntax:
    content: public static System.Diagnostics.Process GetCurrentProcess ();
    parameters: []
    return:
      type: System.Diagnostics.Process
      description: "En ny <xref href=&quot;System.Diagnostics.Process&quot;> </xref> komponent som er knyttet til prosess-ressursen som kjører programmet som kaller."
  overload: System.Diagnostics.Process.GetCurrentProcess*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.Process.GetProcessById(System.Int32)
  id: GetProcessById(System.Int32)
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: GetProcessById(Int32)
  nameWithType: Process.GetProcessById(Int32)
  fullName: System.Diagnostics.Process.GetProcessById(Int32)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Returnerer en ny <xref href=&quot;System.Diagnostics.Process&quot;> </xref> komponent, angitt i identifikatoren for en prosess på den lokale datamaskinen."
  remarks: "Bruk denne metoden til å opprette en ny <xref:System.Diagnostics.Process>komponent og knytt det til en ressurs for prosessen på den lokale datamaskinen.</xref:System.Diagnostics.Process> Prosess-ressursen finnes på datamaskinen, fordi GetProcessById ikke opprette en systemressurs, men knytter en ressurs i stedet en programgenererte <xref:System.Diagnostics.Process>komponent.</xref:System.Diagnostics.Process> En prosess <xref:System.Diagnostics.Process.Id%2A>kan hentes bare for en prosess som kjører på datamaskinen.</xref:System.Diagnostics.Process.Id%2A> Når du avslutter prosessen oppstår GetProcessById et unntak hvis du sender den utløpte IDen.       Identifikatoren for en prosess er unike på en bestemt datamaskin. GetProcessById returnerer mer enn én prosess. Hvis du vil hente alle prosessene som kjører en bestemt applikasjon, kan du bruke <xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29>.</xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29> Hvis det finnes flere prosesser på datamaskinen som kjører den angitte applikasjonen <xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29>returnerer en matrise som inneholder alle tilknyttede prosessene.</xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29> Du kan spørre hvert enkelt av disse prosessene i sin tur for utvalgets ID. Prosess-IDen kan vises i den `Processes` panelet i Windows Oppgavebehandling. Den `PID` kolonnen viser prosess-IDen som er tilordnet til en prosess."
  example:
  - "The following example retrieves information of the current process, processes running on the local computer, all instances of Notepad running on the local computer, and a specific process on the local computer. It then retrieves information for the same processes on a remote computer.  \n  \n [!code-cpp[Process.GetProcesses_noexception#1](~/add/codesnippet/cpp/m-system.diagnostics.pro_19_1.cpp)]\n [!code-vb[Process.GetProcesses_noexception#1](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_19_1.vb)]\n [!code-cs[Process.GetProcesses_noexception#1](~/add/codesnippet/csharp/m-system.diagnostics.pro_19_1.cs)]"
  syntax:
    content: public static System.Diagnostics.Process GetProcessById (int processId);
    parameters:
    - id: processId
      type: System.Int32
      description: "System-Unik identifikator for en prosess-ressurs."
    return:
      type: System.Diagnostics.Process
      description: "En <xref href=&quot;System.Diagnostics.Process&quot;> </xref> komponent som er knyttet til lokal prosess-ressursen som er identifisert av den <code> processId </code> parameteren."
  overload: System.Diagnostics.Process.GetProcessById*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Prosessen som er angitt av den <code> processId </code> parameteren kjører ikke. Identifikatoren kan være utløpt."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Prosessen ble ikke startet av dette objektet."
  platform:
  - net462
- uid: System.Diagnostics.Process.GetProcessById(System.Int32,System.String)
  id: GetProcessById(System.Int32,System.String)
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: GetProcessById(Int32,String)
  nameWithType: Process.GetProcessById(Int32,String)
  fullName: System.Diagnostics.Process.GetProcessById(Int32,String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Returnerer en ny <xref href=&quot;System.Diagnostics.Process&quot;> </xref> komponent, gitt en prosess-ID og navnet på en datamaskin på nettverket."
  remarks: "Bruk denne metoden til å opprette en ny <xref:System.Diagnostics.Process>komponent og knytt det til en ressurs for prosessen på en ekstern datamaskin på nettverket.</xref:System.Diagnostics.Process> Prosess-ressursen finnes på den angitte datamaskinen fordi GetProcessById ikke opprette en systemressurs, men knytter en ressurs i stedet en programgenererte <xref:System.Diagnostics.Process>komponent.</xref:System.Diagnostics.Process> En prosess <xref:System.Diagnostics.Process.Id%2A>kan hentes bare for en prosess som kjører på datamaskinen.</xref:System.Diagnostics.Process.Id%2A> Når du avslutter prosessen oppstår GetProcessById et unntak hvis du sender den utløpte IDen.       Identifikatoren for en prosess er unike på en bestemt datamaskin. GetProcessById returnerer mer enn én prosess. Hvis du vil hente alle prosessene som kjører en bestemt applikasjon, kan du bruke <xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29>.</xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29> Hvis det finnes flere prosesser på datamaskinen som kjører den angitte applikasjonen <xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29>returnerer en matrise som inneholder alle tilknyttede prosessene.</xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29> Du kan spørre hvert enkelt av disse prosessene i sin tur for utvalgets ID. Prosess-IDen kan vises i den `Processes` panelet i Windows Oppgavebehandling. Den `PID` kolonnen viser prosess-IDen som er tilordnet til en prosess.       Hvis du ikke angir en `machineName`, brukes den lokale datamaskinen. Du kan også angi den lokale datamaskinen ved å angi `machineName` til verdien &quot;.&quot; eller en tom streng (&quot;&quot;)."
  example:
  - "The following example retrieves information of the current process, processes running on the local computer, all instances of Notepad running on the local computer, and a specific process on the local computer. It then retrieves information for the same processes on a remote computer.  \n  \n [!code-cpp[Process.GetProcesses_noexception#1](~/add/codesnippet/cpp/m-system.diagnostics.pro_8_1.cpp)]\n [!code-vb[Process.GetProcesses_noexception#1](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_8_1.vb)]\n [!code-cs[Process.GetProcesses_noexception#1](~/add/codesnippet/csharp/m-system.diagnostics.pro_8_1.cs)]"
  syntax:
    content: public static System.Diagnostics.Process GetProcessById (int processId, string machineName);
    parameters:
    - id: processId
      type: System.Int32
      description: "System-Unik identifikator for en prosess-ressurs."
    - id: machineName
      type: System.String
      description: "Navnet på en datamaskin på nettverket."
    return:
      type: System.Diagnostics.Process
      description: "En <xref href=&quot;System.Diagnostics.Process&quot;> </xref> komponent som er knyttet til en ekstern prosess-ressursen som er identifisert av den <code> processId </code> parameteren."
  overload: System.Diagnostics.Process.GetProcessById*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Prosessen som er angitt av den <code> processId </code> parameteren kjører ikke. Identifikatoren kan være utløpt.       - eller - <code> machineName </code> syntaksen for parameteren er ugyldig. Navnet kan ha lengden null (0)."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>machineName</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Prosessen ble ikke startet av dette objektet."
  platform:
  - net462
- uid: System.Diagnostics.Process.GetProcesses
  id: GetProcesses
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: GetProcesses()
  nameWithType: Process.GetProcesses()
  fullName: System.Diagnostics.Process.GetProcesses()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Oppretter en ny <xref href=&quot;System.Diagnostics.Process&quot;> </xref> komponenten til hver ressurs prosessen på den lokale datamaskinen."
  remarks: "Bruk denne metoden til å opprette en rekke nye <xref:System.Diagnostics.Process>komponenter og knytte dem til alle prosessen ressursene på den lokale datamaskinen.</xref:System.Diagnostics.Process> Prosess-ressurser må finnes på den lokale datamaskinen fordi GetProcesses ikke opprette systemressurser, men heller knytter ressurser programgenererte <xref:System.Diagnostics.Process>komponenter.</xref:System.Diagnostics.Process> Denne matrisen er ikke tom fordi selve operativsystemet kjører bakgrunnsprosesser.       Hvis du ikke vil hente alle prosessene som kjører på datamaskinen, du kan begrense antall ved hjelp av den <xref:System.Diagnostics.Process.GetProcessById%2A>eller <xref:System.Diagnostics.Process.GetProcessesByName%2A>metode.</xref:System.Diagnostics.Process.GetProcessesByName%2A> </xref:System.Diagnostics.Process.GetProcessById%2A> <xref:System.Diagnostics.Process.GetProcessById%2A>oppretter en <xref:System.Diagnostics.Process>komponent som er forbundet med prosessen ble identifisert på systemet av prosess-IDen du overfører til metoden.</xref:System.Diagnostics.Process></xref:System.Diagnostics.Process.GetProcessById%2A> <xref:System.Diagnostics.Process.GetProcessesByName%2A>oppretter en matrise av <xref:System.Diagnostics.Process>komponenter som har tilknyttede prosessen ressurser dele den kjørbare filen sendes til metoden.</xref:System.Diagnostics.Process></xref:System.Diagnostics.Process.GetProcessesByName%2A>      > [!NOTE] > Flere Windows-tjenester kan lastes inn i den samme forekomsten av Tjenestevertsprosessen (svchost.exe). GetProcesses identifisere ikke de individuelle tjenestene. Se <xref:System.ServiceProcess.ServiceController.GetServices%2A>.</xref:System.ServiceProcess.ServiceController.GetServices%2A> for som"
  example:
  - "The following example retrieves information of the current process, processes running on the local computer, all instances of Notepad running on the local computer, and a specific process on the local computer. It then retrieves information for the same processes on a remote computer.  \n  \n [!code-cpp[Process.GetProcesses_noexception#1](~/add/codesnippet/cpp/m-system.diagnostics.pro_15_1.cpp)]\n [!code-vb[Process.GetProcesses_noexception#1](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_15_1.vb)]\n [!code-cs[Process.GetProcesses_noexception#1](~/add/codesnippet/csharp/m-system.diagnostics.pro_15_1.cs)]"
  syntax:
    content: public static System.Diagnostics.Process[] GetProcesses ();
    parameters: []
    return:
      type: System.Diagnostics.Process[]
      description: "En matrise av typen <xref href=&quot;System.Diagnostics.Process&quot;> </xref> som representerer alle prosessen ressurser kjører på den lokale datamaskinen."
  overload: System.Diagnostics.Process.GetProcesses*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.Process.GetProcesses(System.String)
  id: GetProcesses(System.String)
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: GetProcesses(String)
  nameWithType: Process.GetProcesses(String)
  fullName: System.Diagnostics.Process.GetProcesses(String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Oppretter en ny <xref href=&quot;System.Diagnostics.Process&quot;> </xref> komponenten til hver ressurs prosessen på den angitte datamaskinen."
  remarks: "Bruk denne metoden til å opprette en rekke nye <xref:System.Diagnostics.Process>komponenter og knytte dem til alle prosessen ressursene på den angitte (vanligvis eksterne) datamaskinen.</xref:System.Diagnostics.Process> Prosess-ressurser må finnes på den lokale datamaskinen fordi <xref:System.Diagnostics.Process.GetProcesses%2A>ikke opprette systemressurser, men heller knytter ressurser programgenererte <xref:System.Diagnostics.Process>komponenter.</xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.GetProcesses%2A> Denne matrisen er ikke tom fordi selve operativsystemet kjører bakgrunnsprosesser.       Hvis du ikke vil hente alle prosessene som kjører på datamaskinen, du kan begrense antall ved hjelp av den <xref:System.Diagnostics.Process.GetProcessById%2A>eller <xref:System.Diagnostics.Process.GetProcessesByName%2A>metode.</xref:System.Diagnostics.Process.GetProcessesByName%2A> </xref:System.Diagnostics.Process.GetProcessById%2A> <xref:System.Diagnostics.Process.GetProcessById%2A>oppretter en <xref:System.Diagnostics.Process>komponent som er forbundet med prosessen ble identifisert på systemet av prosess-IDen du overfører til metoden.</xref:System.Diagnostics.Process></xref:System.Diagnostics.Process.GetProcessById%2A> <xref:System.Diagnostics.Process.GetProcessesByName%2A>oppretter en matrise av <xref:System.Diagnostics.Process>komponenter som har tilknyttede prosessen ressurser dele den kjørbare filen sendes til metoden.</xref:System.Diagnostics.Process></xref:System.Diagnostics.Process.GetProcessesByName%2A>       Denne overbelastning av den <xref:System.Diagnostics.Process.GetProcesses%2A>metoden brukes vanligvis til å hente listen over prosessen ressurser som kjører på en ekstern datamaskin på nettverket, men du kan angi den lokale datamaskinen ved å sende &quot;.&quot;.</xref:System.Diagnostics.Process.GetProcesses%2A>      > [!NOTE] > Flere Windows-tjenester kan lastes inn i den samme forekomsten av Tjenestevertsprosessen (svchost.exe). GetProcesses identifisere ikke de individuelle tjenestene. Se <xref:System.ServiceProcess.ServiceController.GetServices%2A>.</xref:System.ServiceProcess.ServiceController.GetServices%2A> for som"
  example:
  - "The following example retrieves information of the current process, processes running on the local computer, all instances of Notepad running on the local computer, and a specific process on the local computer. It then retrieves information for the same processes on a remote computer.  \n  \n [!code-cpp[Process.GetProcesses_noexception#1](~/add/codesnippet/cpp/m-system.diagnostics.pro_11_1.cpp)]\n [!code-vb[Process.GetProcesses_noexception#1](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_11_1.vb)]\n [!code-cs[Process.GetProcesses_noexception#1](~/add/codesnippet/csharp/m-system.diagnostics.pro_11_1.cs)]"
  syntax:
    content: public static System.Diagnostics.Process[] GetProcesses (string machineName);
    parameters:
    - id: machineName
      type: System.String
      description: "Datamaskinen som kan lese listen over prosesser."
    return:
      type: System.Diagnostics.Process[]
      description: "En matrise av typen <xref href=&quot;System.Diagnostics.Process&quot;> </xref> som representerer alle prosessen ressurser kjører på den angitte datamaskinen."
  overload: System.Diagnostics.Process.GetProcesses*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Den <code> machineName </code> syntaksen for parameteren er ugyldig. Den kan ha lengden null (0)."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>machineName</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Plattformen operativsystemet støtter ikke denne operasjonen på eksterne datamaskiner."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Det er problemer med tilgang til ytelsestelleren API brukes til å hente informasjon om prosessen. Dette unntaket gjelder for Windows NT, Windows 2000 og Windows XP."
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Det oppstod et problem under tilgang til en underliggende systemet API."
  platform:
  - net462
- uid: System.Diagnostics.Process.GetProcessesByName(System.String)
  id: GetProcessesByName(System.String)
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: GetProcessesByName(String)
  nameWithType: Process.GetProcessesByName(String)
  fullName: System.Diagnostics.Process.GetProcessesByName(String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Oppretter en rekke nye <xref href=&quot;System.Diagnostics.Process&quot;> </xref> komponenter og tilordner dem til alle prosessen ressursene på den lokale datamaskinen som deler det angitte prosessnavnet."
  remarks: "Bruk denne metoden til å opprette en rekke nye <xref:System.Diagnostics.Process>komponenter og knytte dem til alle prosessen ressurser som kjører den samme kjørbare filen på den lokale datamaskinen.</xref:System.Diagnostics.Process> Prosess-ressurser må finnes på datamaskinen, fordi GetProcessesByName ikke opprette systemressurser, men heller knytter dem programgenererte <xref:System.Diagnostics.Process>komponenter.</xref:System.Diagnostics.Process> En `processName` kan angis for en kjørbar fil som ikke kjører på den lokale datamaskinen slik at tabellmatrisen metoden returnerer kan være tomt.       Prosessnavnet er et egendefinert navn for prosessen, for eksempel Outlook, som ikke inkluderer filtypen .exe eller banen. GetProcessesByName er nyttige for henting og manipulering av alle prosessene som er knyttet til samme kjørbar fil. Du kan for eksempel sende et navn på kjørbar fil som den `processName` parameteren for å avslutte alle forekomster av den kjørbare filen.       Selv om en prosess <xref:System.Diagnostics.Process.Id%2A>er unikt for en enkelt prosess ressurs på systemet, flere prosesser på den lokale datamaskinen kan kjøre programmet angitt av den `processName` parameteren.</xref:System.Diagnostics.Process.Id%2A> Derfor <xref:System.Diagnostics.Process.GetProcessById%2A>returnerer én prosess maksimalt, men GetProcessesByName returnerer en matrise som inneholder alle tilknyttede prosessene.</xref:System.Diagnostics.Process.GetProcessById%2A> Hvis du vil endre prosess med standard API-kall, kan du spørre hvert enkelt av disse prosessene i sin tur for utvalgets ID. Du får ikke tilgang til prosessen ressurser via prosessnavnet alene, men når du har hentet en matrise av <xref:System.Diagnostics.Process>komponenter som er tilknyttet med prosess-ressursene du kan starte, avsluttes, og endre ellers systemressurser.</xref:System.Diagnostics.Process>"
  example:
  - "The following example retrieves information of the current process, processes running on the local computer, all instances of Notepad running on the local computer, and a specific process on the local computer. It then retrieves information for the same processes on a remote computer.  \n  \n [!code-cpp[Process.GetProcesses_noexception#1](~/add/codesnippet/cpp/m-system.diagnostics.pro_6_1.cpp)]\n [!code-vb[Process.GetProcesses_noexception#1](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_6_1.vb)]\n [!code-cs[Process.GetProcesses_noexception#1](~/add/codesnippet/csharp/m-system.diagnostics.pro_6_1.cs)]"
  syntax:
    content: public static System.Diagnostics.Process[] GetProcessesByName (string processName);
    parameters:
    - id: processName
      type: System.String
      description: "Egendefinert navn for prosessen."
    return:
      type: System.Diagnostics.Process[]
      description: "En matrise av typen <xref href=&quot;System.Diagnostics.Process&quot;> </xref> som representerer ressursene som prosessen kjører den angitte applikasjonen eller filen."
  overload: System.Diagnostics.Process.GetProcessesByName*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Det er problemer med tilgang til ytelsestelleren API brukes til å hente informasjon om prosessen. Dette unntaket gjelder for Windows NT, Windows 2000 og Windows XP."
  platform:
  - net462
- uid: System.Diagnostics.Process.GetProcessesByName(System.String,System.String)
  id: GetProcessesByName(System.String,System.String)
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: GetProcessesByName(String,String)
  nameWithType: Process.GetProcessesByName(String,String)
  fullName: System.Diagnostics.Process.GetProcessesByName(String,String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Oppretter en rekke nye <xref href=&quot;System.Diagnostics.Process&quot;> </xref> komponenter og tilordner dem til alle prosessen ressursene på en ekstern datamaskin som har det angitte prosessnavnet."
  remarks: "Bruk denne metoden til å opprette en rekke nye <xref:System.Diagnostics.Process>komponenter og knytte dem til alle prosessen ressurser som kjører den samme kjørbare filen på den angitte datamaskinen.</xref:System.Diagnostics.Process> Prosess-ressurser må finnes på datamaskinen, fordi <xref:System.Diagnostics.Process.GetProcessesByName%2A>ikke opprette systemressurser, men heller knytter dem programgenererte <xref:System.Diagnostics.Process>komponenter.</xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.GetProcessesByName%2A> En `processName` kan angis for en kjørbar fil som ikke kjører på den lokale datamaskinen slik at tabellmatrisen metoden returnerer kan være tomt.       Prosessnavnet er et egendefinert navn for prosessen, for eksempel Outlook, som ikke inkluderer filtypen .exe eller banen. <xref:System.Diagnostics.Process.GetProcessesByName%2A>kan være nyttig for henting og manipulering av alle prosessene som er knyttet til samme kjørbar fil.</xref:System.Diagnostics.Process.GetProcessesByName%2A> Du kan for eksempel sende et navn på kjørbar fil som den `processName` parameteren for å avslutte alle forekomster av den kjørbare filen.       Selv om en prosess <xref:System.Diagnostics.Process.Id%2A>er unikt for en enkelt prosess ressurs på systemet, flere prosesser på den lokale datamaskinen kan kjøre programmet angitt av den `processName` parameteren.</xref:System.Diagnostics.Process.Id%2A> Derfor <xref:System.Diagnostics.Process.GetProcessById%2A>returnerer én prosess maksimalt, men <xref:System.Diagnostics.Process.GetProcessesByName%2A>returnerer en matrise som inneholder alle tilknyttede prosessene.</xref:System.Diagnostics.Process.GetProcessesByName%2A> </xref:System.Diagnostics.Process.GetProcessById%2A> Hvis du vil endre prosess med standard API-kall, kan du spørre hvert enkelt av disse prosessene i sin tur for utvalgets ID. Du får ikke tilgang til prosessen ressurser via prosessnavnet alene, men når du har hentet en matrise av <xref:System.Diagnostics.Process>komponenter som er tilknyttet med prosess-ressursene du kan starte, avsluttes, og endre ellers systemressurser.</xref:System.Diagnostics.Process>       Du kan bruke denne overlasten for å hente prosesser på den lokale datamaskinen og på en ekstern datamaskin. Bruk &quot;.&quot; til å angi den lokale datamaskinen. Det finnes en annen overlasting som bruker den lokale datamaskinen som standard.       Du har tilgang til prosesser på eksterne datamaskiner bare for å vise informasjon, for eksempel statistikk om prosessene. Du kan ikke lukke, avsluttes (ved hjelp av <xref:System.Diagnostics.Process.Kill%2A>), eller starte prosesser på eksterne datamaskiner.</xref:System.Diagnostics.Process.Kill%2A>"
  example:
  - "The following example retrieves information of the current process, processes running on the local computer, all instances of Notepad running on the local computer, and a specific process on the local computer. It then retrieves information for the same processes on a remote computer.  \n  \n [!code-cpp[Process.GetProcesses_noexception#1](~/add/codesnippet/cpp/m-system.diagnostics.pro_14_1.cpp)]\n [!code-vb[Process.GetProcesses_noexception#1](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_14_1.vb)]\n [!code-cs[Process.GetProcesses_noexception#1](~/add/codesnippet/csharp/m-system.diagnostics.pro_14_1.cs)]"
  syntax:
    content: public static System.Diagnostics.Process[] GetProcessesByName (string processName, string machineName);
    parameters:
    - id: processName
      type: System.String
      description: "Egendefinert navn for prosessen."
    - id: machineName
      type: System.String
      description: "Navnet på en datamaskin på nettverket."
    return:
      type: System.Diagnostics.Process[]
      description: "En matrise av typen <xref href=&quot;System.Diagnostics.Process&quot;> </xref> som representerer ressursene som prosessen kjører den angitte applikasjonen eller filen."
  overload: System.Diagnostics.Process.GetProcessesByName*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Den <code> machineName </code> syntaksen for parameteren er ugyldig. Den kan ha lengden null (0)."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>machineName</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Plattformen operativsystemet støtter ikke denne operasjonen på eksterne datamaskiner."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Det er problemer med tilgang til ytelsestelleren API brukes til å hente informasjon om prosessen. Dette unntaket gjelder for Windows NT, Windows 2000 og Windows XP."
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Det oppstod et problem under tilgang til en underliggende systemet API."
  platform:
  - net462
- uid: System.Diagnostics.Process.Handle
  id: Handle
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: Handle
  nameWithType: Process.Handle
  fullName: System.Diagnostics.Process.Handle
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Henter den opprinnelige referansen for den tilknyttede prosessen."
  remarks: "Et program kan få en referanse til en prosess som kan brukes som en parameter for mange funksjoner for prosess-informasjon og kontroll. Du kan bruke denne referansen til å initialisere en <xref:System.Threading.WaitHandle>eller for å kalle metoder plattform aktivere.</xref:System.Threading.WaitHandle>       Denne prosessen referansen er privat for en applikasjon--altså prosessen håndtak ikke kan deles. En prosess har også en prosess <xref:System.Diagnostics.Process.Id%2A>som, i motsetning til håndtaket er unikt, og derfor gyldige i systemet.</xref:System.Diagnostics.Process.Id%2A>       Bare prosesser startet via et kall til <xref:System.Diagnostics.Process.Start%2A>angi egenskapen håndtaket for den tilsvarende <xref:System.Diagnostics.Process>forekomster.</xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.Start%2A>"
  syntax:
    content: public IntPtr Handle { get; }
    return:
      type: System.IntPtr
      description: "Referansen som operativsystemet tilordnes til den tilknyttede prosessen når prosessen ble startet. Systemet bruker denne referansen til å holde oversikt over prosessen attributter."
  overload: System.Diagnostics.Process.Handle*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Prosessen startet ikke eller er avsluttet. Referanse-egenskapen kan ikke leses fordi det finnes ingen prosess som er knyttet til dette <xref href=&quot;System.Diagnostics.Process&quot;> </xref> forekomsten.       - eller - <xref href=&quot;System.Diagnostics.Process&quot;> </xref> forekomsten er knyttet til en prosess som kjører, men du har ikke de nødvendige tillatelsene til å få et håndtak med full tilgang."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Du prøver å få tilgang til egenskapen referansen for en prosess som kjører på en ekstern datamaskin. Denne egenskapen er bare tilgjengelig for prosessene som kjører på den lokale datamaskinen."
  platform:
  - net462
- uid: System.Diagnostics.Process.HandleCount
  id: HandleCount
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: HandleCount
  nameWithType: Process.HandleCount
  fullName: System.Diagnostics.Process.HandleCount
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Henter antall referanser åpnes av prosessen."
  remarks: "Håndtak gir mulighet for en prosess for å referere til objekter. En prosess kan få referanser til filer, ressurser, meldingskøer og mange andre operativsystemobjekter. Operativsystemet reclaims minnet som er knyttet til prosessen bare når antallet referansen er null."
  syntax:
    content: public int HandleCount { get; }
    return:
      type: System.Int32
      description: "Antall operativsystemet referanser prosessen har åpnet."
  overload: System.Diagnostics.Process.HandleCount*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Plattformen er Windows 98 eller installasjonen (Windows Me); Angi den &lt;xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName&gt; egenskapen <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> å få tilgang til denne egenskapen i Windows 98 og Windows."
  platform:
  - net462
- uid: System.Diagnostics.Process.HasExited
  id: HasExited
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: HasExited
  nameWithType: Process.HasExited
  fullName: System.Diagnostics.Process.HasExited
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Henter en verdi som angir om den tilknyttede prosessen er avsluttet."
  remarks: "Verdien `true` for HasExited indikerer at den tilknyttede prosessen, er avsluttet, vanligvis eller på unormal måte. Du kan be om eller tvinge den tilknyttede prosessen for å avslutte ved å kalle <xref:System.Diagnostics.Process.CloseMainWindow%2A>eller <xref:System.Diagnostics.Process.Kill%2A>.</xref:System.Diagnostics.Process.Kill%2A> </xref:System.Diagnostics.Process.CloseMainWindow%2A> Hvis et håndtak er åpen for prosessen, frigir operativsystemet av prosessminnet når prosessen ble avsluttet, men beholder administrative informasjon om prosessen, for eksempel referansen, avslutningskode og Avslutt nå. Hvis du trenger denne informasjonen, kan du bruke den <xref:System.Diagnostics.Process.ExitCode%2A>og <xref:System.Diagnostics.Process.ExitTime%2A>Egenskaper.</xref:System.Diagnostics.Process.ExitTime%2A> </xref:System.Diagnostics.Process.ExitCode%2A> Disse egenskapene er fylt ut automatisk for prosesser som ble startet i denne komponenten. Administrative informasjonen er utgitt når alle de <xref:System.Diagnostics.Process>komponenter som er knyttet til systemprosessen er ødelagt og inneholder flere referanser til exited prosessen.</xref:System.Diagnostics.Process>       En prosess kan avslutte uavhengig av koden. Hvis du har startet prosessen med denne komponenten, oppdateres verdien for HasExited automatisk, selv om den tilknyttede prosessen avslutter uavhengig.      > [!NOTE] > Når standard utdata er omadressert til asynkrone hendelsesbehandling, er det mulig at output-behandling ikke vil har fullført låse denne egenskapen `true`. For å sikre at asynkrone hendelseshåndtering er fullført, kan du kalle den <xref:System.Diagnostics.Process.WaitForExit>overbelastningen som tar ingen parameter før du kontrollerer HasExited.</xref:System.Diagnostics.Process.WaitForExit>"
  example:
  - "The following example starts an instance of Notepad. It then retrieves the physical memory usage of the associated process at 2 second intervals for a maximum of 10 seconds. The example detects whether the process exits before 10 seconds have elapsed. The example closes the process if it is still running after 10 seconds.  \n  \n [!code-cpp[process_refresh#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_33_1.cpp)]\n [!code-cs[process_refresh#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_33_1.cs)]\n [!code-vb[process_refresh#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_33_1.vb)]"
  syntax:
    content: public bool HasExited { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Hvis operativsystemet prosessen refererer til den <xref href=&quot;System.Diagnostics.Process&quot;> </xref> komponenten er avsluttet; ellers <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Diagnostics.Process.HasExited*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Det er ingen prosess som er knyttet til objektet."
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Kan ikke hente sluttkoden for prosessen."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Du prøver å få tilgang til egenskapen HasExited for en prosess som kjører på en ekstern datamaskin. Denne egenskapen er bare tilgjengelig for prosessene som kjører på den lokale datamaskinen."
  platform:
  - net462
- uid: System.Diagnostics.Process.Id
  id: Id
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: Id
  nameWithType: Process.Id
  fullName: System.Diagnostics.Process.Id
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Henter den unike identifikatoren for den tilknyttede prosessen."
  remarks: "Prosessen Id er ikke gyldig hvis den tilknyttede prosessen ikke kjører. Du må derfor kontrollere at prosessen kjører før du prøver å hente Id-egenskapen. Før du avslutter prosessen identifiserer prosess-IDen prosessen i hele systemet.       Du kan koble en prosess som kjører på en lokal eller ekstern datamaskin til en ny <xref:System.Diagnostics.Process>forekomsten ved å sende prosess-IDen til den <xref:System.Diagnostics.Process.GetProcessById%2A>metoden.</xref:System.Diagnostics.Process.GetProcessById%2A> </xref:System.Diagnostics.Process> <xref:System.Diagnostics.Process.GetProcessById%2A>er en `static` metode som oppretter en ny komponent og angir Id-egenskapen for den nye <xref:System.Diagnostics.Process>serverforekomsten automatisk.</xref:System.Diagnostics.Process></xref:System.Diagnostics.Process.GetProcessById%2A>       Prosessidentifikatorer kan brukes av systemet. Id-egenskapsverdien er unike bare når den tilknyttede prosessen kjører. Når prosessen er avsluttet, kan systemet gjenbruk Id egenskapsverdien for en Urelaterte prosess.       Fordi identifikatoren er unike på systemet, kan du sende den til andre tråder som et alternativ til å sende en <xref:System.Diagnostics.Process>forekomsten.</xref:System.Diagnostics.Process> Denne handlingen kan lagre systemressurser ennå garantere at prosessen er identifisert på riktig måte."
  example:
  - "The following example demonstrates how to obtain the Id for all running instances of an application. The code creates a new instance of Notepad, lists all the instances of Notepad, and then allows the user to enter the Id number to remove a specific instance.  \n  \n [!code-cs[System.Diagnostics.Process.Id#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_36_1.cs)]\n [!code-vb[System.Diagnostics.Process.Id#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_36_1.vb)]"
  syntax:
    content: public int Id { get; }
    return:
      type: System.Int32
      description: "Systemgenererte Unik identifikator for prosessen som refererer til dette <xref href=&quot;System.Diagnostics.Process&quot;> </xref> forekomsten."
  overload: System.Diagnostics.Process.Id*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Prosessens ID-egenskapen er ikke angitt.       - eller - det er ingen prosess som er knyttet til dette <xref href=&quot;System.Diagnostics.Process&quot;> </xref> objektet."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Plattformen er Windows 98 eller installasjonen (Windows Me); Angi den &lt;xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName&gt; egenskapen <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> å få tilgang til denne egenskapen i Windows 98 og Windows."
  platform:
  - net462
- uid: System.Diagnostics.Process.Kill
  id: Kill
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: Kill()
  nameWithType: Process.Kill()
  fullName: System.Diagnostics.Process.Kill()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Stopper umiddelbart den tilknyttede prosessen."
  remarks: "Kill tvinger en avslutning av prosessen, mens <xref:System.Diagnostics.Process.CloseMainWindow%2A>bare ber om en avslutning.</xref:System.Diagnostics.Process.CloseMainWindow%2A> Når en prosess med et grafisk grensesnitt kjøres, er den meldingen løkken i en ventende tilstand. Meldingen sløyfen utfører hver gang en Windows-melding er sendt til prosessen av operativsystemet. Kaller <xref:System.Diagnostics.Process.CloseMainWindow%2A>sender en forespørsel om å nær hovedvinduet som, i et velformet program, lukker underordnede windows og opphever alle kjørende meldingen løkker for applikasjonen.</xref:System.Diagnostics.Process.CloseMainWindow%2A> Forespørselen om å avslutte prosessen ved å kalle <xref:System.Diagnostics.Process.CloseMainWindow%2A>tvinger ikke programmet avsluttes.</xref:System.Diagnostics.Process.CloseMainWindow%2A> Programmet kan be om Brukerbekreftelse før du avslutter, eller den kan avslå for å avslutte. Hvis du vil tvinge programmet til å avslutte, kan du bruke Kill-metoden. Virkemåten for <xref:System.Diagnostics.Process.CloseMainWindow%2A>er identisk med en bruker lukker et program hovedvinduet med system-menyen.</xref:System.Diagnostics.Process.CloseMainWindow%2A> Forespørselen om å avslutte prosessen lukker hovedvinduet tvinger derfor ikke programmet avsluttes umiddelbart.      > [!NOTE] > For Kill metoden kjøres asynkront. Etter å Kill-metoden, kan du kalle den <xref:System.Diagnostics.Process.WaitForExit%2A>metoden man skal vente på prosessen for å avslutte, eller se i <xref:System.Diagnostics.Process.HasExited%2A>til å fastslå om prosessen ble avsluttet.</xref:System.Diagnostics.Process.HasExited%2A> </xref:System.Diagnostics.Process.WaitForExit%2A>       Data redigert prosessen eller ressurser tildelt prosessen kan gå tapt hvis du kaller Kill. Kill forårsaker en unormal avsluttet og kan brukes bare når det er nødvendig. <xref:System.Diagnostics.Process.CloseMainWindow%2A>aktiverer en vanlige avslutning av prosessen og lukker alle windows, så er det best for programmer med et grensesnitt.</xref:System.Diagnostics.Process.CloseMainWindow%2A> Hvis <xref:System.Diagnostics.Process.CloseMainWindow%2A>mislykkes, kan du bruke Kill til å avslutte prosessen.</xref:System.Diagnostics.Process.CloseMainWindow%2A> Kill er den eneste måten å avslutte prosessene som ikke har grafiske grensesnitt.       Du kan ringe Kill og <xref:System.Diagnostics.Process.CloseMainWindow%2A>bare for prosessene som kjører på den lokale datamaskinen.</xref:System.Diagnostics.Process.CloseMainWindow%2A> Du kan ikke føre til at prosesser på eksterne datamaskiner for å avslutte. Du kan bare vise informasjon om som kjører på eksterne datamaskiner.      > [!NOTE] > Hvis kallet til Kill-metoden utføres under prosessen avsluttes for øyeblikket, en <xref:System.ComponentModel.Win32Exception>er et for tilgang.</xref:System.ComponentModel.Win32Exception>"
  syntax:
    content: public void Kill ();
    parameters: []
  overload: System.Diagnostics.Process.Kill*
  exceptions:
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Den tilknyttede prosessen kan ikke avbrytes.       - eller - prosessen avslutter.       - eller - den tilknyttede prosessen er en Win16 kjørbar fil."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Du prøver å kalle Kill for en prosess som kjører på en ekstern datamaskin. Metoden er bare tilgjengelig for som kjører på den lokale datamaskinen."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Prosessen er allerede avsluttet.       - eller - det er ingen prosess som er knyttet til dette <xref href=&quot;System.Diagnostics.Process&quot;> </xref> objektet."
  platform:
  - net462
- uid: System.Diagnostics.Process.LeaveDebugMode
  id: LeaveDebugMode
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: LeaveDebugMode()
  nameWithType: Process.LeaveDebugMode()
  fullName: System.Diagnostics.Process.LeaveDebugMode()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Tar en <xref href=&quot;System.Diagnostics.Process&quot;> </xref> sekundkomponenten utenfor tilstand som tillater at den samhandle med operativsystemprosesser som kjøres i en spesiell modus."
  remarks: "Noen operativsystemet som kjører i en spesiell modus. Forsøk på å lese egenskapene for eller legge ved disse prosessene er ikke mulig med mindre du har ringt <xref:System.Diagnostics.Process.EnterDebugMode%2A>for komponenten.</xref:System.Diagnostics.Process.EnterDebugMode%2A> Kall LeaveDebugMode når du ikke lenger trenger tilgang til disse prosessene som kjører i spesielle modus."
  syntax:
    content: public static void LeaveDebugMode ();
    parameters: []
  overload: System.Diagnostics.Process.LeaveDebugMode*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.Process.MachineName
  id: MachineName
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: MachineName
  nameWithType: Process.MachineName
  fullName: System.Diagnostics.Process.MachineName
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Henter navnet på den tilknyttede prosessen kjører på datamaskinen."
  remarks: "Du kan vise statistiske data og behandle informasjon for som kjører på eksterne datamaskiner, men du kan ikke kalle <xref:System.Diagnostics.Process.Start%2A>, <xref:System.Diagnostics.Process.CloseMainWindow%2A>, eller <xref:System.Diagnostics.Process.Kill%2A>på eksterne datamaskiner.</xref:System.Diagnostics.Process.Kill%2A> </xref:System.Diagnostics.Process.CloseMainWindow%2A> </xref:System.Diagnostics.Process.Start%2A>      > [!NOTE] > Når den tilknyttede prosessen kjører på den lokale maskinen, denne egenskapen returnerer et punktum (&quot;.&quot;) for maskinnavnet på. Du må bruke den <xref:System.Environment.MachineName%2A?displayProperty=fullName>til å hente riktig maskinnavnet.</xref:System.Environment.MachineName%2A?displayProperty=fullName>"
  example:
  - "To use the following example you must first start at least one instance of Notepad on a remote computer. The example requests the name of the remote computer on which Notepad is running, and then displays the respective <xref:System.Diagnostics.Process.ProcessName%2A>, <xref:System.Diagnostics.Process.Id%2A>, and MachineName properties for each instance.  \n  \n [!code-cs[process_GetProcessesByName2_2#2](~/add/codesnippet/csharp/p-system.diagnostics.pro_26_1.cs)]\n [!code-cpp[process_GetProcessesByName2_2#2](~/add/codesnippet/cpp/p-system.diagnostics.pro_26_1.cpp)]\n [!code-vb[process_GetProcessesByName2_2#2](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_26_1.vb)]"
  syntax:
    content: public string MachineName { get; }
    return:
      type: System.String
      description: "Navnet på datamaskinen som kjører på den tilknyttede prosessen."
  overload: System.Diagnostics.Process.MachineName*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Det er ingen prosess som er knyttet til dette <xref href=&quot;System.Diagnostics.Process&quot;> </xref> objektet."
  platform:
  - net462
- uid: System.Diagnostics.Process.MainModule
  id: MainModule
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: MainModule
  nameWithType: Process.MainModule
  fullName: System.Diagnostics.Process.MainModule
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Henter den primære modulen for den tilknyttede prosessen."
  remarks: "En prosessmodul representerer a.dll eller .exe fil som er lastet inn i en bestemt prosess. Egenskapen MainModule kan du vise informasjon om den kjørbare filen som brukes til å starte prosessen, inkludert Modulnavn, filnavnet og modulen minne detaljer."
  syntax:
    content: public System.Diagnostics.ProcessModule MainModule { get; }
    return:
      type: System.Diagnostics.ProcessModule
      description: "Den <xref href=&quot;System.Diagnostics.ProcessModule&quot;> </xref> som ble brukt til å starte prosessen."
  overload: System.Diagnostics.Process.MainModule*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Du prøver å få tilgang til egenskapen MainModule for en prosess som kjører på en ekstern datamaskin. Denne egenskapen er bare tilgjengelig for prosessene som kjører på den lokale datamaskinen."
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "En 32-biters prosess prøver å få tilgang til moduler i en 64-biters prosess."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Plattformen er Windows 98 eller installasjonen (Windows Me); Angi &lt;xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName&gt; til <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> å få tilgang til denne egenskapen i Windows 98 og Windows."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Prosessen <xref:System.Diagnostics.Process.Id*>er ikke tilgjengelig.</xref:System.Diagnostics.Process.Id*>       - eller - prosessen ble avsluttet."
  platform:
  - net462
- uid: System.Diagnostics.Process.MainWindowHandle
  id: MainWindowHandle
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: MainWindowHandle
  nameWithType: Process.MainWindowHandle
  fullName: System.Diagnostics.Process.MainWindowHandle
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Henter vinduet behandlingen av hovedvinduet for den tilknyttede prosessen."
  remarks: "Hovedvinduet er vinduet som åpnes av prosessen som for øyeblikket har fokus (den <xref:System.Windows.Forms.Form.TopLevel%2A>skjemaet).</xref:System.Windows.Forms.Form.TopLevel%2A> Du må bruke den <xref:System.Diagnostics.Process.Refresh%2A>metode for å oppdatere den <xref:System.Diagnostics.Process>objekt for å hente gjeldende hovedvinduet håndtaket hvis den er endret.</xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.Refresh%2A> Generelt fordi vinduet håndtaket hurtigbufres, bruker <xref:System.Diagnostics.Process.Refresh%2A>på forhånd garantere at du vil hente gjeldende håndtaket.</xref:System.Diagnostics.Process.Refresh%2A>       Du kan få egenskapen MainWindowHandle bare for prosessene som kjører på den lokale datamaskinen. Egenskapen MainWindowHandle er en verdi som identifiserer vinduet som er knyttet til prosessen.       En prosess har en tilknyttet bare hvis prosessen har et grafisk grensesnitt hovedvinduet. Hvis den tilknyttede prosessen ikke har en hovedvinduet, er MainWindowHandle-verdien null. Verdien er også null for prosesser som har vært skjult, som er prosesser som ikke vises på oppgavelinjen. Dette kan være tilfellet for prosesser som vises som ikoner i systemstatusfeltet helt til høyre på oppgavelinjen.       Hvis du nettopp har startet en prosess og vil bruke hovedvinduet håndtaket, kan du vurdere å bruke den <xref:System.Diagnostics.Process.WaitForInputIdle%2A>metode for å tillate at prosessen ferdig med å starte, slik at hovedvinduet referansen er opprettet.</xref:System.Diagnostics.Process.WaitForInputIdle%2A> Hvis ikke, vil bli utløst et unntak."
  syntax:
    content: public IntPtr MainWindowHandle { get; }
    return:
      type: System.IntPtr
      description: "Systemgenererte vinduet behandlingen av hovedvinduet for den tilknyttede prosessen."
  overload: System.Diagnostics.Process.MainWindowHandle*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "MainWindowHandle er ikke definert fordi prosessen ble avsluttet."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Du prøver å få tilgang til egenskapen MainWindowHandle for en prosess som kjører på en ekstern datamaskin. Denne egenskapen er bare tilgjengelig for prosessene som kjører på den lokale datamaskinen."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Plattformen er Windows 98 eller installasjonen (Windows Me); Angi &lt;xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName&gt; til <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> å få tilgang til denne egenskapen i Windows 98 og Windows."
  platform:
  - net462
- uid: System.Diagnostics.Process.MainWindowTitle
  id: MainWindowTitle
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: MainWindowTitle
  nameWithType: Process.MainWindowTitle
  fullName: System.Diagnostics.Process.MainWindowTitle
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Henter teksten for hovedvinduet av prosessen."
  remarks: "En prosess har en tilknyttet bare hvis prosessen har et grafisk grensesnitt hovedvinduet. Hvis den tilknyttede prosessen ikke har en hovedvinduet (slik at <xref:System.Diagnostics.Process.MainWindowHandle%2A>er tom), MainWindowTitle er en tom streng (&quot;&quot;).</xref:System.Diagnostics.Process.MainWindowHandle%2A> Hvis du nettopp har startet en prosess og vil bruke hovedvinduet tittelen, kan du vurdere å bruke den <xref:System.Diagnostics.Process.WaitForInputIdle%2A>metode for å tillate at prosessen ferdig med å starte, slik at hovedvinduet referansen er opprettet.</xref:System.Diagnostics.Process.WaitForInputIdle%2A> Ellers oppstår systemet det et unntak.      > [!NOTE] > Hovedvinduet er vinduet som for øyeblikket har fokus; Vær oppmerksom på at dette er det primære vinduet for prosessen. Du må bruke den <xref:System.Diagnostics.Process.Refresh%2A>metode for å oppdatere den <xref:System.Diagnostics.Process>objekt for å hente gjeldende hovedvinduet håndtaket hvis den er endret.</xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.Refresh%2A>"
  example:
  - "The following example starts an instance of Notepad and retrieves the caption of the main window of the process.  \n  \n [!code-cpp[process_MainWindowTitle#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_45_1.cpp)]\n [!code-cs[process_MainWindowTitle#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_45_1.cs)]\n [!code-vb[process_MainWindowTitle#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_45_1.vb)]"
  syntax:
    content: public string MainWindowTitle { get; }
    return:
      type: System.String
      description: "Hovedvinduet tittelen av prosessen."
  overload: System.Diagnostics.Process.MainWindowTitle*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Egenskapen MainWindowTitle er ikke definert fordi prosessen ble avsluttet."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Du prøver å få tilgang til egenskapen MainWindowTitle for en prosess som kjører på en ekstern datamaskin. Denne egenskapen er bare tilgjengelig for prosessene som kjører på den lokale datamaskinen."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Plattformen er Windows 98 eller installasjonen (Windows Me); Angi &lt;xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName&gt; til <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> å få tilgang til denne egenskapen i Windows 98 og Windows."
  platform:
  - net462
- uid: System.Diagnostics.Process.MaxWorkingSet
  id: MaxWorkingSet
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: MaxWorkingSet
  nameWithType: Process.MaxWorkingSet
  fullName: System.Diagnostics.Process.MaxWorkingSet
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Henter eller angir den maksimale tillatte fungerer set størrelsen, i byte for den tilknyttede prosessen."
  remarks: "En prosess arbeidssett er settet med minnesider som er synlig for prosessen i minnet RAM. Disse sidene er faste og tilgjengelig for et program uten utløser en sidefeil.       Arbeidssett inkluderer både delt og private data. De delte dataene inneholder sider som inneholder alle instruksjonene som programmet kjører, inkludert sidene i DLL-filer og system.dll-filer. Når arbeidssett øker, øker minne behov.       En prosess har minimum og maksimum fungerer angitt størrelse. Hver gang en prosess-ressurs opprettes, reservere systemet en angitt mengde minne som er lik minimumsstørrelsen for prosessen. Transportbehandling for virtuelt minne prøver å beholde minst minimumsbeløpet minne faste når prosessen er aktiv, men den aldri beholder mer enn den maksimale størrelsen.       Systemet angir standard gjeldende sett størrelser. Du kan endre disse størrelsene ved hjelp av MaxWorkingSet og <xref:System.Diagnostics.Process.MinWorkingSet%2A>medlemmer.</xref:System.Diagnostics.Process.MinWorkingSet%2A> Imidlertid garanterer angi disse verdiene ikke at minnet blir reservert eller faste.      > [!NOTE] > Når du øker fungerer Sett størrelsen på en prosess, kan du utføre fysisk minne bort fra resten av systemet. Kontroller at du ikke be om et minimum eller maksimum fungerer størrelse som er for lang, fordi så kan redusere systemytelsen for."
  syntax:
    content: public IntPtr MaxWorkingSet { get; set; }
    return:
      type: System.IntPtr
      description: "Den maksimale arbeidssett størrelsen som er tillatt i minnet for prosessen, i byte."
  overload: System.Diagnostics.Process.MaxWorkingSet*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Maksimal størrelse på arbeidssett er ugyldig. Det må være større enn eller lik minimumsstørrelsen."
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Arbeider informasjon om ikke kan hentes fra tilknyttede prosessen-ressurs.       - eller - prosess-ID eller prosessen referansen er null fordi prosessen ikke startet."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Du prøver å få tilgang til egenskapen MaxWorkingSet for en prosess som kjører på en ekstern datamaskin. Denne egenskapen er bare tilgjengelig for prosessene som kjører på den lokale datamaskinen."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Prosessen <xref:System.Diagnostics.Process.Id*>er ikke tilgjengelig.</xref:System.Diagnostics.Process.Id*>       - eller - prosessen ble avsluttet."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Plattformen er Windows 98 eller installasjonen (Windows Me), som ikke støtter denne egenskapen."
  platform:
  - net462
- uid: System.Diagnostics.Process.MinWorkingSet
  id: MinWorkingSet
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: MinWorkingSet
  nameWithType: Process.MinWorkingSet
  fullName: System.Diagnostics.Process.MinWorkingSet
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Henter eller angir den minste tillatte fungerer set størrelsen, i byte for den tilknyttede prosessen."
  remarks: "En prosess arbeidssett er settet med minnesider som er synlig for prosessen i minnet RAM. Disse sidene er faste og tilgjengelig for et program uten utløser en sidefeil.       Arbeidssett inkluderer både delt og private data. De delte dataene inneholder sider som inneholder alle instruksjonene som programmet kjører, inkludert sidene i DLL-filer og system.dll-filer. Når arbeidssett øker, øker minne behov.       En prosess har minimum og maksimum fungerer angitt størrelse. Hver gang en prosess-ressurs opprettes, reservere systemet en angitt mengde minne som er lik minimumsstørrelsen for prosessen. Transportbehandling for virtuelt minne prøver å beholde minst minimumsbeløpet minne faste når prosessen er aktiv, men den aldri beholder mer enn den maksimale størrelsen.       Systemet angir standard gjeldende sett størrelser. Du kan endre disse størrelsene ved hjelp av den <xref:System.Diagnostics.Process.MaxWorkingSet%2A>og MinWorkingSet medlemmer.</xref:System.Diagnostics.Process.MaxWorkingSet%2A> Imidlertid garanterer angi disse verdiene ikke at minnet blir reservert eller faste.      > [!NOTE] > Når du øker fungerer Sett størrelsen på en prosess, kan du utføre fysisk minne bort fra resten av systemet. Kontroller at du ikke be om et minimum eller maksimum fungerer størrelse som er for lang, fordi så kan redusere systemytelsen for."
  syntax:
    content: public IntPtr MinWorkingSet { get; set; }
    return:
      type: System.IntPtr
      description: "Det minste arbeidssett som kreves i minnet for prosessen, i byte."
  overload: System.Diagnostics.Process.MinWorkingSet*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Minimumsstørrelsen er ugyldig. Det må være mindre enn eller lik maksimumsstørrelsen."
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Arbeider informasjon om ikke kan hentes fra tilknyttede prosessen-ressurs.       - eller - prosess-ID eller prosessen referansen er null fordi prosessen ikke startet."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Du prøver å få tilgang til egenskapen MinWorkingSet for en prosess som kjører på en ekstern datamaskin. Denne egenskapen er bare tilgjengelig for prosessene som kjører på den lokale datamaskinen."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Prosessen <xref:System.Diagnostics.Process.Id*>er ikke tilgjengelig.</xref:System.Diagnostics.Process.Id*>       - eller - prosessen ble avsluttet."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Plattformen er Windows 98 eller installasjonen (Windows Me), som ikke støtter denne egenskapen."
  platform:
  - net462
- uid: System.Diagnostics.Process.Modules
  id: Modules
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: Modules
  nameWithType: Process.Modules
  fullName: System.Diagnostics.Process.Modules
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Henter moduler som er lastet inn av den tilknyttede prosessen."
  remarks: "En prosessmodul representerer a.dll eller .exe fil som er lastet inn i en bestemt prosess. En <xref:System.Diagnostics.ProcessModule>forekomsten kan du vise informasjon om en modul, inkludert Modulnavn, filnavn og modulen minne detaljer.</xref:System.Diagnostics.ProcessModule>       En prosess kan laste inn flere moduler i minnet. For eksempel har .exe filer som lastes inn flere DLL-filer flere moduler.       Denne samlingen er tom når du starter prosessen før systemet har lastet prosessen. Hvis prosessen har en hovedvinduet, kan du kalle <xref:System.Diagnostics.Process.WaitForInputIdle%2A>før du henter egenskapen for å sikre at samlingen er tom når du får listen.</xref:System.Diagnostics.Process.WaitForInputIdle%2A>"
  syntax:
    content: public System.Diagnostics.ProcessModuleCollection Modules { get; }
    return:
      type: System.Diagnostics.ProcessModuleCollection
      description: "En matrise av typen <xref href=&quot;System.Diagnostics.ProcessModule&quot;> </xref> som representerer moduler som er lastet inn av den tilknyttede prosessen."
  overload: System.Diagnostics.Process.Modules*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Du prøver å få tilgang til egenskapen moduler for en prosess som kjører på en ekstern datamaskin. Denne egenskapen er bare tilgjengelig for prosessene som kjører på den lokale datamaskinen."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Prosessen <xref:System.Diagnostics.Process.Id*>er ikke tilgjengelig.</xref:System.Diagnostics.Process.Id*>"
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Plattformen er Windows 98 eller installasjonen (Windows Me); Angi &lt;xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName&gt; til <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> å få tilgang til denne egenskapen i Windows 98 og Windows."
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Du prøver å få tilgang til egenskapen moduler for systemprosessen eller inaktiv prosessen. Disse prosessene har ikke moduler."
  platform:
  - net462
- uid: System.Diagnostics.Process.NonpagedSystemMemorySize
  id: NonpagedSystemMemorySize
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: NonpagedSystemMemorySize
  nameWithType: Process.NonpagedSystemMemorySize
  fullName: System.Diagnostics.Process.NonpagedSystemMemorySize
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Henter systemminne ikke sidevekslet, i byte tildelt for den tilknyttede prosessen."
  syntax:
    content: public int NonpagedSystemMemorySize { get; }
    return:
      type: System.Int32
      description: "Hvor mye minne, i byte systemet har tildelt for den tilknyttede prosessen som ikke kan skrives til vil virtuelt minnefilen."
  overload: System.Diagnostics.Process.NonpagedSystemMemorySize*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Plattformen er Windows 98 eller installasjonen (Windows Me), som ikke støtter denne egenskapen."
  platform:
  - net462
- uid: System.Diagnostics.Process.NonpagedSystemMemorySize64
  id: NonpagedSystemMemorySize64
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: NonpagedSystemMemorySize64
  nameWithType: Process.NonpagedSystemMemorySize64
  fullName: System.Diagnostics.Process.NonpagedSystemMemorySize64
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Henter systemminne ikke sidevekslet, i byte tildelt for den tilknyttede prosessen."
  remarks: "Verdien som returneres av denne egenskapen representerer gjeldende størrelse på ikke-vekslebart minne brukes av prosessen, i byte. Systemminne er det fysiske minnet som brukes av operativsystemet på denne datamaskinen, og er delt inn i vekslet og ikke-vekslebart. Ikke-vekslebart minnetildelinger beholdes i minnet og er ikke sidevekslet til vil virtuelt minnefilen.       Denne egenskapen kan brukes til å overvåke minnebruk på datamaskiner med prosessorer 32-biters eller 64-biters prosessorer. Egenskapsverdien tilsvarer den **applikasjonsutvalget ikke sidevekslet byte** ytelsestelleren for prosessen."
  example:
  - "The following code example starts an instance of the Notepad application. The example then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays its exit code and peak memory statistics.  \n  \n [!code-cpp[Diag_Process_MemoryProperties64#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_28_1.cpp)]\n [!code-cs[Diag_Process_MemoryProperties64#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_28_1.cs)]\n [!code-vb[Diag_Process_MemoryProperties64#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_28_1.vb)]"
  syntax:
    content: public long NonpagedSystemMemorySize64 { get; }
    return:
      type: System.Int64
      description: "Mengden av systemminne, i byte tildelt for den tilknyttede prosessen som ikke kan skrives til vil virtuelt minnefilen."
  overload: System.Diagnostics.Process.NonpagedSystemMemorySize64*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Plattformen er Windows 98 eller installasjonen (Windows Me), som ikke støtter denne egenskapen."
  platform:
  - net462
- uid: System.Diagnostics.Process.OnExited
  id: OnExited
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: OnExited()
  nameWithType: Process.OnExited()
  fullName: System.Diagnostics.Process.OnExited()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Hever den <xref href=&quot;System.Diagnostics.Process.Exited&quot;> </xref> hendelsen."
  remarks: "OnExited er API-metoden opphøyer den <xref:System.Diagnostics.Process.Exited>hendelsen.</xref:System.Diagnostics.Process.Exited> Kaller OnExited årsaker den <xref:System.Diagnostics.Process.Exited>hendelsen oppstår og er den eneste måten å heve hendelsen ved hjelp av <xref:System.Diagnostics.Process>komponent.</xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.Exited> OnExited brukes hovedsakelig når det avledes klasser fra komponenten.       Du kan skrive dine egne hendelsesbehandlingen som et alternativ til OnExited. Du kan opprette din egen hendelsen behandlingsprogrammet representanten og hendelseshåndtering metoden.      > [!NOTE] > Hvis du bruker Visual Studio-miljøet, en hendelse behandlingsprogrammet representanten (AddOnExited) og en hendelseshåndtering metoden (Process1_Exited) er opprettet for deg når du drar en <xref:System.Diagnostics.Process>sekundkomponenten inn i et skjema og dobbeltklikk.</xref:System.Diagnostics.Process> Koden du oppretter for å kjøre når den <xref:System.Diagnostics.Process.Exited>inntreffer settes inn i prosedyren Process1_Exited.</xref:System.Diagnostics.Process.Exited> Du trenger ikke å opprette OnExited medlem, fordi den er implementert for deg.       Opprettet en hendelse aktiverer hendelsesbehandlingen via en representant. For en oversikt, kan du se [hendelser](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "The following example shows how to use the OnExited method in a derived class.  \n  \n [!code-cs[OnExitSample#1](~/add/codesnippet/csharp/m-system.diagnostics.pro_9_1.cs)]\n [!code-vb[OnExitSample#1](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_9_1.vb)]"
  syntax:
    content: protected void OnExited ();
    parameters: []
  overload: System.Diagnostics.Process.OnExited*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.Process.OutputDataReceived
  id: OutputDataReceived
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: OutputDataReceived
  nameWithType: Process.OutputDataReceived
  fullName: System.Diagnostics.Process.OutputDataReceived
  type: Event
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Forekommer i hver gang en applikasjon skriver en linje til den omadresserte <xref:System.Diagnostics.Process.StandardOutput*>dataflyten.</xref:System.Diagnostics.Process.StandardOutput*>"
  remarks: "Hendelsen OutputDataReceived indikerer at det tilknyttede <xref:System.Diagnostics.Process>har skrevet en linje, avslutter med tegnet, til den omadresserte <xref:System.Diagnostics.Process.StandardOutput%2A>dataflyten.</xref:System.Diagnostics.Process.StandardOutput%2A> </xref:System.Diagnostics.Process>       Hendelsen er aktivert under Asynkrone leseoperasjoner <xref:System.Diagnostics.Process.StandardOutput%2A>.</xref:System.Diagnostics.Process.StandardOutput%2A> Hvis du vil starte Asynkrone leseoperasjoner, må du omadressere <xref:System.Diagnostics.Process.StandardOutput%2A>dataflyten for et <xref:System.Diagnostics.Process>, Legg til hendelsesbehandlingen til OutputDataReceived-hendelse, og kall <xref:System.Diagnostics.Process.BeginOutputReadLine%2A>.</xref:System.Diagnostics.Process.BeginOutputReadLine%2A> </xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.StandardOutput%2A> Deretter OutputDataReceived hendelsen signaler hver gang prosessen skriver en linje til omdirigerte <xref:System.Diagnostics.Process.StandardOutput%2A>dataflyten før prosessen avslutter eller samtaler <xref:System.Diagnostics.Process.CancelOutputRead%2A>.</xref:System.Diagnostics.Process.CancelOutputRead%2A> </xref:System.Diagnostics.Process.StandardOutput%2A>      > [!NOTE] > Programmet som behandler asynkrone utdataene kalle den <xref:System.Diagnostics.Process.WaitForExit%2A>metode for å sikre at utdatabufferen har blitt tømt.</xref:System.Diagnostics.Process.WaitForExit%2A>"
  example:
  - "The following example illustrates how to perform asynchronous read operations on the redirected <xref:System.Diagnostics.Process.StandardOutput%2A> stream of the `ipconfig` command.  \n  \n The example creates an event delegate for the `OutputHandler` event handler and associates it with the OutputDataReceived event. The event handler receives text lines from the redirected <xref:System.Diagnostics.Process.StandardOutput%2A> stream, formats the text, and saves it in an output string that’s later shown in the example’s console window.  \n  \n [!code-cpp[Process_AsyncStreams#4](~/add/codesnippet/cpp/e-system.diagnostics.pro_2_1.cpp)]\n [!code-cs[Process_AsyncStreams#4](~/add/codesnippet/csharp/e-system.diagnostics.pro_2_1.cs)]\n [!code-vb[Process_AsyncStreams#4](~/add/codesnippet/visualbasic/e-system.diagnostics.pro_2_1.vb)]"
  syntax:
    content: public event System.Diagnostics.DataReceivedEventHandler OutputDataReceived;
    return:
      type: System.Diagnostics.DataReceivedEventHandler
      description: "Som skal legges til."
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.Process.PagedMemorySize
  id: PagedMemorySize
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: PagedMemorySize
  nameWithType: Process.PagedMemorySize
  fullName: System.Diagnostics.Process.PagedMemorySize
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Henter mengden sidevekslet minne, i byte tildelt for den tilknyttede prosessen."
  syntax:
    content: public int PagedMemorySize { get; }
    return:
      type: System.Int32
      description: "Hvor mye minne, i byte tildelt av den tilknyttede prosessen kan skrives til vil virtuelt minnefilen."
  overload: System.Diagnostics.Process.PagedMemorySize*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Plattformen er Windows 98 eller installasjonen (Windows Me), som ikke støtter denne egenskapen."
  platform:
  - net462
- uid: System.Diagnostics.Process.PagedMemorySize64
  id: PagedMemorySize64
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: PagedMemorySize64
  nameWithType: Process.PagedMemorySize64
  fullName: System.Diagnostics.Process.PagedMemorySize64
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Henter mengden sidevekslet minne, i byte tildelt for den tilknyttede prosessen."
  remarks: "Verdien som returneres av denne egenskapen representerer gjeldende størrelse på minne i virtuelt minne Bla filen som brukes av prosessen, i byte. Operativsystemet på denne datamaskinen bruker virtuelt minne Bla filen sammen med fysisk minne til å administrere virtuelt adresseområde for hver prosess. Når vekslebart minne ikke er i bruk, kan det bli overført til virtuelt minne Bla filen på disken. For å få størrelsen på minnet som brukes av operativsystemet for prosessen, kan du bruke den <xref:System.Diagnostics.Process.PagedSystemMemorySize64%2A>egenskapen.</xref:System.Diagnostics.Process.PagedSystemMemorySize64%2A>       Denne egenskapen kan brukes til å overvåke minnebruk på datamaskiner med prosessorer 32-biters eller 64-biters prosessorer. Egenskapsverdien tilsvarer den **siden filen byte** ytelsesteller for prosessen."
  example:
  - "The following code example starts an instance of the Notepad application, and then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays its exit code and peak memory statistics.  \n  \n [!code-cpp[Diag_Process_MemoryProperties64#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_12_1.cpp)]\n [!code-cs[Diag_Process_MemoryProperties64#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_12_1.cs)]\n [!code-vb[Diag_Process_MemoryProperties64#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_12_1.vb)]"
  syntax:
    content: public long PagedMemorySize64 { get; }
    return:
      type: System.Int64
      description: "Hvor mye minne, i byte tildelt i filen virtuelt minne Bla for den tilknyttede prosessen."
  overload: System.Diagnostics.Process.PagedMemorySize64*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Plattformen er Windows 98 eller installasjonen (Windows Me), som ikke støtter denne egenskapen."
  platform:
  - net462
- uid: System.Diagnostics.Process.PagedSystemMemorySize
  id: PagedSystemMemorySize
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: PagedSystemMemorySize
  nameWithType: Process.PagedSystemMemorySize
  fullName: System.Diagnostics.Process.PagedSystemMemorySize
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Henter mengden vekslebart minne, i byte tildelt for den tilknyttede prosessen."
  syntax:
    content: public int PagedSystemMemorySize { get; }
    return:
      type: System.Int32
      description: "Hvor mye minne, i byte systemet har tildelt for den tilknyttede prosessen kan skrives til vil virtuelt minnefilen."
  overload: System.Diagnostics.Process.PagedSystemMemorySize*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Plattformen er Windows 98 eller installasjonen (Windows Me), som ikke støtter denne egenskapen."
  platform:
  - net462
- uid: System.Diagnostics.Process.PagedSystemMemorySize64
  id: PagedSystemMemorySize64
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: PagedSystemMemorySize64
  nameWithType: Process.PagedSystemMemorySize64
  fullName: System.Diagnostics.Process.PagedSystemMemorySize64
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Henter mengden vekslebart minne, i byte tildelt for den tilknyttede prosessen."
  remarks: "Verdien som returneres av denne egenskapsverdien representerer gjeldende størrelse på vekslebart systemminne som brukes av prosessen, i byte. Systemminne er det fysiske minnet som brukes av operativsystemet på denne datamaskinen, og er delt inn i vekslet og ikke-vekslebart. Når vekslebart minne ikke er i bruk, kan det bli overført til virtuelt minne Bla filen på disken. For å få størrelsen på programmet minnet som brukes av prosessen, kan du bruke den <xref:System.Diagnostics.Process.PagedMemorySize64%2A>egenskapen.</xref:System.Diagnostics.Process.PagedMemorySize64%2A>       Denne egenskapen kan brukes til å overvåke minnebruk på datamaskiner med prosessorer 32-biters eller 64-biters prosessorer. Egenskapsverdien tilsvarer den **applikasjonsutvalget sidevekslet byte** ytelsestelleren for prosessen."
  example:
  - "The following code example starts an instance of the Notepad application. The example then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays its exit code and peak memory statistics.  \n  \n [!code-cpp[Diag_Process_MemoryProperties64#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_18_1.cpp)]\n [!code-cs[Diag_Process_MemoryProperties64#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_18_1.cs)]\n [!code-vb[Diag_Process_MemoryProperties64#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_18_1.vb)]"
  syntax:
    content: public long PagedSystemMemorySize64 { get; }
    return:
      type: System.Int64
      description: "Mengden av systemminne, i byte tildelt for den tilknyttede prosessen kan skrives til vil virtuelt minnefilen."
  overload: System.Diagnostics.Process.PagedSystemMemorySize64*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Plattformen er Windows 98 eller installasjonen (Windows Me), som ikke støtter denne egenskapen."
  platform:
  - net462
- uid: System.Diagnostics.Process.PeakPagedMemorySize
  id: PeakPagedMemorySize
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: PeakPagedMemorySize
  nameWithType: Process.PeakPagedMemorySize
  fullName: System.Diagnostics.Process.PeakPagedMemorySize
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Henter den maksimale mengden minne i virtuelt minne Bla-fil, i byte som brukes av den tilknyttede prosessen."
  syntax:
    content: public int PeakPagedMemorySize { get; }
    return:
      type: System.Int32
      description: "Maksimum minne, i byte tildelt av den tilknyttede prosessen kan skrive til vil virtuelt minnefilen."
  overload: System.Diagnostics.Process.PeakPagedMemorySize*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Plattformen er Windows 98 eller installasjonen (Windows Me), som ikke støtter denne egenskapen."
  platform:
  - net462
- uid: System.Diagnostics.Process.PeakPagedMemorySize64
  id: PeakPagedMemorySize64
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: PeakPagedMemorySize64
  nameWithType: Process.PeakPagedMemorySize64
  fullName: System.Diagnostics.Process.PeakPagedMemorySize64
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Henter den maksimale mengden minne i virtuelt minne Bla-fil, i byte som brukes av den tilknyttede prosessen."
  remarks: "Verdien som returneres av denne egenskapsverdien representerer den maksimale størrelsen på minne i filen for virtuelt minne Bla brukes av prosessen siden den har startet, i byte. Operativsystemet på denne datamaskinen bruker virtuelt minne Bla filen sammen med fysisk minne til å administrere virtuelt adresseområde for hver prosess. Når vekslebart minne ikke er i bruk, kan det bli overført til virtuelt minne Bla filen på disken.       Denne egenskapen kan brukes til å overvåke minnebruk på datamaskiner med prosessorer 32-biters eller 64-biters prosessorer. Egenskapsverdien tilsvarer den **siden høyeste antall byte i filen** ytelsesteller for prosessen."
  example:
  - "The following code example starts an instance of the Notepad application. The example then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays its exit code and peak memory statistics.  \n  \n [!code-cpp[Diag_Process_MemoryProperties64#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_24_1.cpp)]\n [!code-cs[Diag_Process_MemoryProperties64#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_24_1.cs)]\n [!code-vb[Diag_Process_MemoryProperties64#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_24_1.vb)]"
  syntax:
    content: public long PeakPagedMemorySize64 { get; }
    return:
      type: System.Int64
      description: "Maksimum minne, i byte tildelt i filen virtuelt minne Bla for den tilknyttede prosessen siden den ble startet."
  overload: System.Diagnostics.Process.PeakPagedMemorySize64*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Plattformen er Windows 98 eller installasjonen (Windows Me), som ikke støtter denne egenskapen."
  platform:
  - net462
- uid: System.Diagnostics.Process.PeakVirtualMemorySize
  id: PeakVirtualMemorySize
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: PeakVirtualMemorySize
  nameWithType: Process.PeakVirtualMemorySize
  fullName: System.Diagnostics.Process.PeakVirtualMemorySize
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Henter maksimal mengde virtuelt minne, i byte som brukes av den tilknyttede prosessen."
  syntax:
    content: public int PeakVirtualMemorySize { get; }
    return:
      type: System.Int32
      description: "Maksimal mengde virtuelt minne, i byte, som den tilknyttede prosessen har bedt om."
  overload: System.Diagnostics.Process.PeakVirtualMemorySize*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Plattformen er Windows 98 eller installasjonen (Windows Me), som ikke støtter denne egenskapen."
  platform:
  - net462
- uid: System.Diagnostics.Process.PeakVirtualMemorySize64
  id: PeakVirtualMemorySize64
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: PeakVirtualMemorySize64
  nameWithType: Process.PeakVirtualMemorySize64
  fullName: System.Diagnostics.Process.PeakVirtualMemorySize64
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Henter maksimal mengde virtuelt minne, i byte som brukes av den tilknyttede prosessen."
  remarks: "Verdien som returneres av denne egenskapen representerer den maksimale størrelsen på det virtuelle minnet som brukes av prosessen siden den har startet, i byte. Operativsystemet tilordner virtuelt adresseområde for hver prosess enten til sider lastes inn i minnet, eller til sider som er lagret i virtuelt minne Bla filen på disken.       Denne egenskapen kan brukes til å overvåke minnebruk på datamaskiner med prosessorer 32-biters eller 64-biters prosessorer. Egenskapsverdien tilsvarer den **virtuelle byte travel** ytelsesteller for prosessen."
  example:
  - "The following code example starts an instance of the Notepad application. The example then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays its exit code and peak memory statistics.  \n  \n [!code-cpp[Diag_Process_MemoryProperties64#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_23_1.cpp)]\n [!code-cs[Diag_Process_MemoryProperties64#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_23_1.cs)]\n [!code-vb[Diag_Process_MemoryProperties64#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_23_1.vb)]"
  syntax:
    content: public long PeakVirtualMemorySize64 { get; }
    return:
      type: System.Int64
      description: "Maksimal mengde virtuelt minne, i byte brukt for den tilknyttede prosessen siden den ble startet."
  overload: System.Diagnostics.Process.PeakVirtualMemorySize64*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Plattformen er Windows 98 eller installasjonen (Windows Me), som ikke støtter denne egenskapen."
  platform:
  - net462
- uid: System.Diagnostics.Process.PeakWorkingSet
  id: PeakWorkingSet
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: PeakWorkingSet
  nameWithType: Process.PeakWorkingSet
  fullName: System.Diagnostics.Process.PeakWorkingSet
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Henter maksimal størrelse for den tilknyttede prosessen på arbeidssett i byte."
  remarks: "En prosess arbeidssett er settet med minnesider som er synlig for prosessen i minnet RAM. Disse sidene er faste og tilgjengelig for et program uten utløser en sidefeil.       Arbeidssett inkluderer både delt og private data. De delte dataene inneholder sider som inneholder alle instruksjonene som prosessen utfører, inkludert prosessen moduler og system-biblioteker."
  syntax:
    content: public int PeakWorkingSet { get; }
    return:
      type: System.Int32
      description: "Maksimum fysisk minne tilknyttede prosessen har bedt om samtidig, i byte."
  overload: System.Diagnostics.Process.PeakWorkingSet*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Plattformen er Windows 98 eller installasjonen (Windows Me), som ikke støtter denne egenskapen."
  platform:
  - net462
- uid: System.Diagnostics.Process.PeakWorkingSet64
  id: PeakWorkingSet64
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: PeakWorkingSet64
  nameWithType: Process.PeakWorkingSet64
  fullName: System.Diagnostics.Process.PeakWorkingSet64
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Henter maksimal mengde fysisk minne, i byte som brukes av den tilknyttede prosessen."
  remarks: "Verdien som returneres av denne egenskapen representerer den maksimale størrelsen på arbeid Sett minnet som brukes av prosessen siden den har startet, i byte. En prosess arbeidssett er settet med minnesider som er synlig for prosessen i minnet RAM. Disse sidene er faste og tilgjengelig for et program uten utløser en sidefeil.       Arbeidssett inkluderer både delt og private data. De delte dataene inneholder sider som inneholder alle instruksjonene som prosessen utfører, inkludert instruksjoner fra prosessen modulene og system-biblioteker.       Denne egenskapen kan brukes til å overvåke minnebruk på datamaskiner med prosessorer 32-biters eller 64-biters prosessorer. Egenskapsverdien tilsvarer den **fungerer angi mest aktive** ytelsestelleren for prosessen."
  example:
  - "The following code example starts an instance of the Notepad application. The example then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays its exit code and peak memory statistics.  \n  \n [!code-cpp[Diag_Process_MemoryProperties64#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_34_1.cpp)]\n [!code-cs[Diag_Process_MemoryProperties64#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_34_1.cs)]\n [!code-vb[Diag_Process_MemoryProperties64#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_34_1.vb)]"
  syntax:
    content: public long PeakWorkingSet64 { get; }
    return:
      type: System.Int64
      description: "Maksimum fysisk minne, i byte brukt for den tilknyttede prosessen siden den ble startet."
  overload: System.Diagnostics.Process.PeakWorkingSet64*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Plattformen er Windows 98 eller installasjonen (Windows Me), som ikke støtter denne egenskapen."
  platform:
  - net462
- uid: System.Diagnostics.Process.PriorityBoostEnabled
  id: PriorityBoostEnabled
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: PriorityBoostEnabled
  nameWithType: Process.PriorityBoostEnabled
  fullName: System.Diagnostics.Process.PriorityBoostEnabled
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Henter eller angir en verdi som angir om den tilknyttede prosess prioriteten skal midlertidig være boosted av operativsystemet når hovedvinduet har fokus."
  remarks: "Når en tråd kjører i en prosess som prioritetsklassen har dynamiske prioritet opplisting verdier (<xref:System.Diagnostics.ProcessPriorityClass>, <xref:System.Diagnostics.ProcessPriorityClass>, eller <xref:System.Diagnostics.ProcessPriorityClass>), at systemet øker midlertidig trådens prioritet når den er i bruk av en ventende tilstand.</xref:System.Diagnostics.ProcessPriorityClass> </xref:System.Diagnostics.ProcessPriorityClass> </xref:System.Diagnostics.ProcessPriorityClass> Denne handlingen hindrer at andre prosesser å avbryte behandlingen av gjeldende tråd. PriorityBoostEnabled påvirkes alle eksisterende tråder og tråder senere opprettes av prosessen. Hvis du vil gjenopprette normal virkemåte, WantDestinationQueue egenskapen PriorityBoostEnabled `false`.      > [!NOTE] > Øke prioriteten for høy kan tømme ressurser fra viktige operativsystem og nettverk fungerer, forårsaker problemer med andre oppgaver for operativsystemet."
  syntax:
    content: public bool PriorityBoostEnabled { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Hvis dynamiske øke av prosessen prioriteten skal utføres for en prosess når den er i bruk av ventende tilstand; Ellers <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>. Standard <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Diagnostics.Process.PriorityBoostEnabled*
  exceptions:
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Kan ikke hente prioritet øke informasjon fra tilknyttede prosessen ressursen."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Plattformen er Windows 98 eller installasjonen (Windows Me), som ikke støtter denne egenskapen.       - eller - prosess-ID eller prosessen referansen er null. (Prosessen startet ikke.)"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Du prøver å få tilgang til egenskapen PriorityBoostEnabled for en prosess som kjører på en ekstern datamaskin. Denne egenskapen er bare tilgjengelig for prosessene som kjører på den lokale datamaskinen."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Prosessen <xref:System.Diagnostics.Process.Id*>er ikke tilgjengelig.</xref:System.Diagnostics.Process.Id*>"
  platform:
  - net462
- uid: System.Diagnostics.Process.PriorityClass
  id: PriorityClass
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: PriorityClass
  nameWithType: Process.PriorityClass
  fullName: System.Diagnostics.Process.PriorityClass
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Henter eller angir kategorien for den totale prioritet for den tilknyttede prosessen."
  remarks: "En prosess prioritetsklasse omfatter en rekke tråd prioritetsnivåer. Tråder med ulike egenskaper som kjører i prosessen står i forhold til prioritetsklassen av prosessen. Win32 bruker fire prioritet klasser med sju basisprioriteten nivåer per klasse. Disse prosessen prioritet klassene, finnes i den <xref:System.Diagnostics.ProcessPriorityClass>opplisting som lar deg angi prosessen prioriteten <xref:System.Diagnostics.ProcessPriorityClass>, <xref:System.Diagnostics.ProcessPriorityClass>, <xref:System.Diagnostics.ProcessPriorityClass>, <xref:System.Diagnostics.ProcessPriorityClass>, <xref:System.Diagnostics.ProcessPriorityClass>, eller <xref:System.Diagnostics.ProcessPriorityClass>.</xref:System.Diagnostics.ProcessPriorityClass> </xref:System.Diagnostics.ProcessPriorityClass> </xref:System.Diagnostics.ProcessPriorityClass> </xref:System.Diagnostics.ProcessPriorityClass> </xref:System.Diagnostics.ProcessPriorityClass> </xref:System.Diagnostics.ProcessPriorityClass> </xref:System.Diagnostics.ProcessPriorityClass> Basert på tidspunktet forløpt eller andre øker, basisprioriteten nivået kan endres av operativsystemet når en prosess må settes lengre enn andre for å få tilgang til prosessoren. I tillegg kan du angi den <xref:System.Diagnostics.Process.PriorityBoostEnabled%2A>å øke midlertidig prioriteringsnivå med tråder som er utført av ventende tilstand.</xref:System.Diagnostics.Process.PriorityBoostEnabled%2A> Prioriteten er tilbakestilt når prosessen returnerer til ventende tilstand.       Den <xref:System.Diagnostics.Process.BasePriority%2A>egenskapen kan du vise Start prioriteten som er tilordnet til en prosess.</xref:System.Diagnostics.Process.BasePriority%2A> Fordi den er skrivebeskyttet, kan du imidlertid bruke den <xref:System.Diagnostics.Process.BasePriority%2A>til å angi prioritet for en prosess.</xref:System.Diagnostics.Process.BasePriority%2A> Hvis du vil endre prioriteten, bruker du egenskapen PriorityClass, som henter eller angir kategorien for den totale prioritet for prosessen.       Prioritetsklassen kan ikke vises i System Monitor. Tabellen nedenfor viser relasjonen mellom de <xref:System.Diagnostics.Process.BasePriority%2A>og PriorityClass verdier.</xref:System.Diagnostics.Process.BasePriority%2A>      | BasePriority | PriorityClass |   |------------------|-------------------|   |&4; | <xref:System.Diagnostics.ProcessPriorityClass>|   |&8; | <xref:System.Diagnostics.ProcessPriorityClass>|   |&13; | <xref:System.Diagnostics.ProcessPriorityClass>|   |&24; | <xref:System.Diagnostics.ProcessPriorityClass>|</xref:System.Diagnostics.ProcessPriorityClass></xref:System.Diagnostics.ProcessPriorityClass></xref:System.Diagnostics.ProcessPriorityClass></xref:System.Diagnostics.ProcessPriorityClass>"
  example:
  - "The following example starts an instance of Notepad. The example then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays the process's exit code.  \n  \n [!code-cpp[Diag_Process_MemoryProperties64#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_29_1.cpp)]\n [!code-cs[Diag_Process_MemoryProperties64#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_29_1.cs)]\n [!code-vb[Diag_Process_MemoryProperties64#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_29_1.vb)]"
  syntax:
    content: public System.Diagnostics.ProcessPriorityClass PriorityClass { get; set; }
    return:
      type: System.Diagnostics.ProcessPriorityClass
      description: "Kategorien prioritet for den tilknyttede prosessen som den <xref:System.Diagnostics.Process.BasePriority*>av prosessen beregnes.</xref:System.Diagnostics.Process.BasePriority*>"
  overload: System.Diagnostics.Process.PriorityClass*
  exceptions:
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Kan ikke angi eller hentet fra den tilknyttede prosess ressursen prosessen prioritetsinformasjon.       - eller - prosess-ID eller prosessen referansen er null. (Prosessen startet ikke.)"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Du prøver å få tilgang til PriorityClass-egenskapen for en prosess som kjører på en ekstern datamaskin. Denne egenskapen er bare tilgjengelig for prosessene som kjører på den lokale datamaskinen."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Prosessen <xref:System.Diagnostics.Process.Id*>er ikke tilgjengelig.</xref:System.Diagnostics.Process.Id*>"
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Du har angitt PriorityClass <xref uid=&quot;langword_csharp_AboveNormal&quot; name=&quot;AboveNormal&quot; href=&quot;&quot;> </xref> eller <xref uid=&quot;langword_csharp_BelowNormal&quot; name=&quot;BelowNormal&quot; href=&quot;&quot;> </xref> ved bruk av Windows 98 eller installasjonen (Windows Me). Disse plattformene støtter ikke verdiene for prioritetsklassen."
  - type: System.ComponentModel.InvalidEnumArgumentException
    commentId: T:System.ComponentModel.InvalidEnumArgumentException
    description: "Prioritetsklasse kan ikke angis fordi den ikke bruker en gyldig verdi som er definert i den <xref href=&quot;System.Diagnostics.ProcessPriorityClass&quot;> </xref> opplisting."
  platform:
  - net462
- uid: System.Diagnostics.Process.PrivateMemorySize
  id: PrivateMemorySize
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: PrivateMemorySize
  nameWithType: Process.PrivateMemorySize
  fullName: System.Diagnostics.Process.PrivateMemorySize
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Henter mengde privatminne, i byte tildelt for den tilknyttede prosessen."
  syntax:
    content: public int PrivateMemorySize { get; }
    return:
      type: System.Int32
      description: "Antall byte som er tildelt av den tilknyttede prosessen som ikke kan deles med andre prosesser."
  overload: System.Diagnostics.Process.PrivateMemorySize*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Plattformen er Windows 98 eller installasjonen (Windows Me), som ikke støtter denne egenskapen."
  platform:
  - net462
- uid: System.Diagnostics.Process.PrivateMemorySize64
  id: PrivateMemorySize64
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: PrivateMemorySize64
  nameWithType: Process.PrivateMemorySize64
  fullName: System.Diagnostics.Process.PrivateMemorySize64
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Henter mengde privatminne, i byte tildelt for den tilknyttede prosessen."
  remarks: "Verdien som returneres av denne egenskapen representerer gjeldende størrelse på minnet som brukes av prosessen, i byte, som ikke kan deles med andre prosesser.       Denne egenskapen kan brukes til å overvåke minnebruk på datamaskiner med prosessorer 32-biters eller 64-biters prosessorer. Egenskapsverdien tilsvarer den **Private byte** ytelsesteller for prosessen."
  example:
  - "The following code example starts an instance of the Notepad application. The example then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays its exit code and peak memory statistics.  \n  \n [!code-cpp[Diag_Process_MemoryProperties64#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_17_1.cpp)]\n [!code-cs[Diag_Process_MemoryProperties64#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_17_1.cs)]\n [!code-vb[Diag_Process_MemoryProperties64#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_17_1.vb)]"
  syntax:
    content: public long PrivateMemorySize64 { get; }
    return:
      type: System.Int64
      description: "Hvor mye minne, i byte tildelt for den tilknyttede prosessen som ikke kan deles med andre prosesser."
  overload: System.Diagnostics.Process.PrivateMemorySize64*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Plattformen er Windows 98 eller installasjonen (Windows Me), som ikke støtter denne egenskapen."
  platform:
  - net462
- uid: System.Diagnostics.Process.PrivilegedProcessorTime
  id: PrivilegedProcessorTime
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: PrivilegedProcessorTime
  nameWithType: Process.PrivilegedProcessorTime
  fullName: System.Diagnostics.Process.PrivilegedProcessorTime
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Henter den privilegerte prosessortiden for denne prosessen."
  remarks: ''
  example:
  - "The following example starts an instance of Notepad. The example then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays the process's exit code.  \n  \n [!code-cpp[Diag_Process_MemoryProperties64#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_37_1.cpp)]\n [!code-cs[Diag_Process_MemoryProperties64#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_37_1.cs)]\n [!code-vb[Diag_Process_MemoryProperties64#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_37_1.vb)]"
  syntax:
    content: public TimeSpan PrivilegedProcessorTime { get; }
    return:
      type: System.TimeSpan
      description: "En <xref:System.TimeSpan>som angir hvor lang tid at prosessen har brukt kjører kode i operativsystemet-kjerner.</xref:System.TimeSpan>"
  overload: System.Diagnostics.Process.PrivilegedProcessorTime*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Plattformen er Windows 98 eller installasjonen (Windows Me), som ikke støtter denne egenskapen."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Du prøver å få tilgang til egenskapen PrivilegedProcessorTime for en prosess som kjører på en ekstern datamaskin. Denne egenskapen er bare tilgjengelig for prosessene som kjører på den lokale datamaskinen."
  platform:
  - net462
- uid: System.Diagnostics.Process.ProcessName
  id: ProcessName
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: ProcessName
  nameWithType: Process.ProcessName
  fullName: System.Diagnostics.Process.ProcessName
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Henter navnet på prosessen."
  remarks: "Egenskapen Prosessnavn inneholder en kjørbar fil-navnet, for eksempel Outlook, som ikke inkluderer filtypen .exe eller banen. Det er nyttig for henting og manipulering av alle prosessene som er knyttet til samme kjørbar fil.      > [!NOTE] > På [!INCLUDE[Win2kFamily](~/add/includes/win2kfamily-md.md)] operativsystemer, ProcessName-egenskapen kan avkortes 15 tegn hvis ikke kan hente informasjon for prosess-modul.       Du kan ringe <xref:System.Diagnostics.Process.GetProcessesByName%2A>, sendes en kjørbar fil-navn, for å hente en matrise som inneholder alle forekomsten som kjøres på den angitte datamaskinen.</xref:System.Diagnostics.Process.GetProcessesByName%2A> Du kan bruke denne matrisen, for eksempel for å avslutte alle forekomster av den kjørbare filen."
  syntax:
    content: public string ProcessName { get; }
    return:
      type: System.String
      description: "Navnet på systemet bruker til å identifisere prosessen for brukeren."
  overload: System.Diagnostics.Process.ProcessName*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Prosessen har ikke en identifikator, eller ingen prosess er knyttet til den <xref href=&quot;System.Diagnostics.Process&quot;> </xref>.       - eller - den tilknyttede prosessen ble avsluttet."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Plattformen er Windows 98 eller installasjonen (Windows Me); Angi &lt;xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName&gt; til <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> å få tilgang til denne egenskapen i Windows 98 og Windows."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Prosessen er ikke på denne datamaskinen."
  platform:
  - net462
- uid: System.Diagnostics.Process.ProcessorAffinity
  id: ProcessorAffinity
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: ProcessorAffinity
  nameWithType: Process.ProcessorAffinity
  fullName: System.Diagnostics.Process.ProcessorAffinity
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Henter eller angir prosessorer som tråder i denne prosessen kan planlegges."
  remarks: "I Windows 2000 eller senere, kan en tråd i en prosess migrere fra prosessor til prosessor med hver overføring laste prosessor-bufferen. Under tungt system laster kan angi hvilken prosessor skal kjøre en bestemt tråd forbedre ytelsen ved å redusere antall ganger hurtigbufferen prosessor lastes inn på nytt. Tilknytning mellom en prosessor og en tråd kalles i prosessoraffinitet.       Hver prosessor representeres som litt. Bit 0 er prosessor én bit 1 er prosessor to og så videre. Hvis du setter litt til verdien 1, velges tilsvarende prosessoren for tråd tildeling. Når du angir ProcessorAffinity-verdien til null, angitt for operativsystemet planlegging algoritmer trådens affinitet. Når ProcessorAffinity-verdien er satt til en annen verdi, tolkes verdien som en bitmaske som angir disse prosessorer som er kvalifisert for valg.       Tabellen nedenfor viser et utvalg av ProcessorAffinity verdier for et&8;-prosessor-system.      | Bitmaske | Binærverdi | Kvalifisert prosessorer |   |-------------|------------------|-------------------------|   | 0x0001 | 00000000 00000001 | 1 |   | 0x0003 | 00000000 00000011 | 1 og 2 |   | 0x0007 | 00000000 00000111 | 1, 2 og 3 |   | 0x0009 | 00000000 00001001 | 1 og 4 |   | 0x007F | 00000000 01111111 | 1, 2, 3, 4, 5, 6 og 7 |"
  syntax:
    content: public IntPtr ProcessorAffinity { get; set; }
    return:
      type: System.IntPtr
      description: "En bitmaske som representerer prosessorer som tråder i den tilknyttede prosessen kan kjøre på. Standard, avhengig av antallet prosessorer på datamaskinen. Standardverdien er 2 <sup>n</sup> -1, der n er antall prosessorer."
  overload: System.Diagnostics.Process.ProcessorAffinity*
  exceptions:
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Kan ikke angi eller hentet fra den tilknyttede prosess ressursen ProcessorAffinity informasjon.       - eller - prosess-ID eller prosessen referansen er null. (Prosessen startet ikke.)"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Du prøver å få tilgang til egenskapen ProcessorAffinity for en prosess som kjører på en ekstern datamaskin. Denne egenskapen er bare tilgjengelig for prosessene som kjører på den lokale datamaskinen."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Prosessen <xref:System.Diagnostics.Process.Id*>var ikke tilgjengelig.</xref:System.Diagnostics.Process.Id*>       - eller - prosessen ble avsluttet."
  platform:
  - net462
- uid: System.Diagnostics.Process.Refresh
  id: Refresh
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: Refresh()
  nameWithType: Process.Refresh()
  fullName: System.Diagnostics.Process.Refresh()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Informasjon om den tilknyttede prosessen som er bufret i prosesskomponenten, forkastes."
  remarks: "Etter at oppdatering kalles, gjør forespørselen for informasjon om hver egenskap prosesskomponenten til å hente en ny verdi i den tilknyttede prosessen.       Når en <xref:System.Diagnostics.Process>komponent som er knyttet til en prosess-ressurs, egenskapsverdiene for den <xref:System.Diagnostics.Process>umiddelbart er fylt ut i henhold til statusen for den tilknyttede prosessen.</xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process> Hvis informasjonen om tilknyttede prosessen endres senere, endringene gjenspeiles ikke i den <xref:System.Diagnostics.Process>komponentens bufret verdier.</xref:System.Diagnostics.Process> Den <xref:System.Diagnostics.Process>komponenten er et øyeblikksbilde av prosessen ressursen når de er tilknyttet.</xref:System.Diagnostics.Process> For å vise gjeldende verdier for den tilknyttede prosessen, kan du kalle metoden oppdatering."
  example:
  - "The following example starts an instance of Notepad. It then retrieves the physical memory usage of the associated process at 2 second intervals for a maximum of 10 seconds. The example detects whether the process exits before 10 seconds have elapsed. The example closes the process if it is still running after 10 seconds.  \n  \n [!code-cpp[process_refresh#1](~/add/codesnippet/cpp/m-system.diagnostics.pro_1_1.cpp)]\n [!code-cs[process_refresh#1](~/add/codesnippet/csharp/m-system.diagnostics.pro_1_1.cs)]\n [!code-vb[process_refresh#1](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_1_1.vb)]"
  syntax:
    content: public void Refresh ();
    parameters: []
  overload: System.Diagnostics.Process.Refresh*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.Process.Responding
  id: Responding
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: Responding
  nameWithType: Process.Responding
  fullName: System.Diagnostics.Process.Responding
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Henter en verdi som angir om svarer brukergrensesnittet for prosessen."
  remarks: "Hvis en prosess har et brukergrensesnitt, kontakter egenskapen Responding brukergrensesnittet for å finne ut om prosessen svarer på brukerinndata. Hvis grensesnittet ikke svarer umiddelbart, returnerer de Responding `false`. Bruk denne egenskapen til å fastslå om grensesnittet for den tilknyttede prosessen ikke svarer.       Hvis du ikke har en <xref:System.Diagnostics.Process.MainWindowHandle%2A>, denne egenskapen returnerer `true`.</xref:System.Diagnostics.Process.MainWindowHandle%2A>"
  example:
  - "The following example starts an instance of Notepad. The example then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays the process's exit code.  \n  \n [!code-cpp[Diag_Process_MemoryProperties64#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_39_1.cpp)]\n [!code-cs[Diag_Process_MemoryProperties64#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_39_1.cs)]\n [!code-vb[Diag_Process_MemoryProperties64#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_39_1.vb)]"
  syntax:
    content: public bool Responding { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Hvis brukergrensesnittet for den tilknyttede prosessen svarer på systemet. Ellers <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Diagnostics.Process.Responding*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Plattformen er Windows 98 eller installasjonen (Windows Me); Angi &lt;xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName&gt; til <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> å få tilgang til denne egenskapen i Windows 98 og Windows."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Det er ingen prosess som er knyttet til dette <xref href=&quot;System.Diagnostics.Process&quot;> </xref> objektet."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Du prøver å få tilgang til egenskapen Responding for en prosess som kjører på en ekstern datamaskin. Denne egenskapen er bare tilgjengelig for prosessene som kjører på den lokale datamaskinen."
  platform:
  - net462
- uid: System.Diagnostics.Process.SafeHandle
  id: SafeHandle
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: SafeHandle
  nameWithType: Process.SafeHandle
  fullName: System.Diagnostics.Process.SafeHandle
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Henter den opprinnelige referansen til denne prosessen."
  remarks: "Referansen er bare tilgjengelig hvis kall komponent startet prosessen."
  syntax:
    content: public Microsoft.Win32.SafeHandles.SafeProcessHandle SafeHandle { get; }
    return:
      type: Microsoft.Win32.SafeHandles.SafeProcessHandle
      description: "Den opprinnelige referansen til denne prosessen."
  overload: System.Diagnostics.Process.SafeHandle*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.Process.SessionId
  id: SessionId
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: SessionId
  nameWithType: Process.SessionId
  fullName: System.Diagnostics.Process.SessionId
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Henter den Terminal Services-økt-IDen for den tilknyttede prosessen."
  remarks: "SessionId-egenskapen angir økten der programmet kjører."
  syntax:
    content: public int SessionId { get; }
    return:
      type: System.Int32
      description: "Terminal Services-økten identifikatoren for den tilknyttede prosessen."
  overload: System.Diagnostics.Process.SessionId*
  exceptions:
  - type: System.NullReferenceException
    commentId: T:System.NullReferenceException
    description: "Det finnes ingen økt som er forbundet med denne prosessen."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Det er ingen prosess som er forbundet med denne identifikatoren for økten.       - eller - den tilknyttede prosessen finnes ikke på denne maskinen."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "SessionId-egenskapen støttes ikke på Windows 98."
  platform:
  - net462
- uid: System.Diagnostics.Process.StandardError
  id: StandardError
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: StandardError
  nameWithType: Process.StandardError
  fullName: System.Diagnostics.Process.StandardError
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Henter en dataflyt som brukes til å lese feil resultatet av programmet."
  remarks: "Når en <xref:System.Diagnostics.Process>skriver tekst til den standard feilflyt teksten vises vanligvis i konsollen.</xref:System.Diagnostics.Process> Du kan endre eller undertrykke feil resultatet av en prosess ved å omdirigere StandardError dataflyten. Du kan for eksempel filtrere teksten, formaterer det på en annen måte, eller skrive utdataene både konsollen og en angitt loggfil.      > [!NOTE] > For å bruke StandardError, må du angi <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName>til `false`, og du må angi <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardError%2A?displayProperty=fullName>til `true`.</xref:System.Diagnostics.ProcessStartInfo.RedirectStandardError%2A?displayProperty=fullName> </xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName> Ellers oppstår lesing fra StandardError dataflyten det et unntak.       Kan kopiere dataflyten omdirigerte StandardError synkron eller asynkron. Metoder som <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, og <xref:System.IO.StreamReader.ReadToEnd%2A>utføre synkron leseoperasjoner i utdata feilflyt av prosessen.</xref:System.IO.StreamReader.ReadToEnd%2A> </xref:System.IO.StreamReader.ReadLine%2A> </xref:System.IO.StreamReader.Read%2A> Disse synkron lese operasjoner ikke fyller ut før den tilknyttede <xref:System.Diagnostics.Process>skriver til den StandardError dataflyten eller lukker dataflyten.</xref:System.Diagnostics.Process>       I motsetning <xref:System.Diagnostics.Process.BeginErrorReadLine%2A>starter Asynkrone leseoperasjoner i StandardError-dataflyt.</xref:System.Diagnostics.Process.BeginErrorReadLine%2A> Denne metoden gjør det mulig for en angitt hendelsesbehandling for dataflyten-utdata, og returnerer umiddelbart til oppkalleren, som kan utføre andre arbeid mens utdataene dataflyten er rettet mot hendelsesbehandlingen.       Synkron leseoperasjoner introduserer en avhengighet mellom oppkalleren lesing fra StandardError dataflyten og underordnede prosessen skriving til denne dataflyten. Disse avhengighetene kan føre til vranglås betingelser. Når oppkalleren leser fra omadresserte dataflyten for en underordnet prosess, er det avhengige barnet. Oppkalleren venter på leseoperasjonen til barnet skriver til dataflyten eller lukker dataflyten. Når den underordnede prosessen skriver nok data til å fylle den omadresserte dataflyten, er det avhengige av overordnet. Den underordnede prosessen venter på neste Skriveoperasjonen til overordnet leser fra fullstendig dataflyten eller lukker dataflyten. Vranglås betingelsen resultater når oppkalleren og underordnet prosess vente på å fullføre en operasjon, og ingen kan fortsette. Du kan unngå vranglås ved evaluering av avhengigheter mellom oppkaller og underordnet prosess.       Følgende C# kode, for eksempel viser hvordan du lese fra en omadressert dataflyt og venter til den underordnede prosessen å avslutte.      ```   // Start the child process.    Process p = new Process();    // Redirect the error stream of the child process.    p.StartInfo.UseShellExecute = false;    p.StartInfo.RedirectStandardError = true;    p.StartInfo.FileName = &quot;Write500Lines.exe&quot;;    p.Start();    // Do not wait for the child process to exit before    // reading to the end of its redirected error stream.    // p.WaitForExit();    // Read the error stream first and then wait.    string error = p.StandardError.ReadToEnd();    p.WaitForExit();   ```Kodeeksemplet unngår en vranglås betingelse ved å kalle `p.StandardError.ReadToEnd` før `p.WaitForExit`. En vranglås betingelse kan skje hvis overordnet behandle kall `p.WaitForExit` før `p.StandardError.ReadToEnd` og underordnet prosess skriver nok tekst for å fylle omdirigerte dataflyten. Den overordnede prosessen vil vente på ubestemt tid for den underordnede prosessen å avslutte. Den underordnede prosessen vil vente på ubestemt tid for overordnet å lese fra fullstendig StandardError dataflyten.       Det er et lignende problem når du lese alle text fra standard utdata og standard feil dataflyter. Følgende C# kode utfører for eksempel en leseoperasjon på begge dataflyter.      ```   // Do not perform a synchronous read to the end of both    // redirected streams.   // string output = p.StandardOutput.ReadToEnd();   // string error = p.StandardError.ReadToEnd();   // p.WaitForExit();   // Use asynchronous read operations on at least one of the streams.   p.BeginOutputReadLine();   string error = p.StandardError.ReadToEnd();   p.WaitForExit();   ```Kodeeksemplet unngår betingelsen vranglås ved å utføre Asynkrone leseoperasjoner på den <xref:System.Diagnostics.Process.StandardOutput%2A>dataflyten.</xref:System.Diagnostics.Process.StandardOutput%2A> En vranglås betingelse resultat hvis overordnet behandle kall `p.StandardOutput.ReadToEnd` etterfulgt av `p.StandardError.ReadToEnd` og underordnet prosess skriver nok tekst slik at det fyller feilflyt. Den overordnede prosessen vil vente på ubestemt tid underordnet prosess å lukke den <xref:System.Diagnostics.Process.StandardOutput%2A>dataflyten.</xref:System.Diagnostics.Process.StandardOutput%2A> Den underordnede prosessen vil vente på ubestemt tid for overordnet å lese fra fullstendig StandardError dataflyten.       Du kan bruke Asynkrone leseoperasjoner unngå disse avhengigheter og deres potensielle vranglås. Du kan eventuelt unngå betingelsen vranglås ved oppretting av to tråder og lese utdataene til hver dataflyt i en egen tråd.      > [!NOTE] > Du kan ikke blande asynkrone og Synkrone leseoperasjoner på en omadressert dataflyt. Når omdirigerte dataflyten for en <xref:System.Diagnostics.Process>er åpnet i asynkron eller synkron modus, mer leser alle operasjoner i denne dataflyten må være i samme modus.</xref:System.Diagnostics.Process> For eksempel ikke følger <xref:System.Diagnostics.Process.BeginErrorReadLine%2A>med et kall til <xref:System.IO.StreamReader.ReadLine%2A>for StandardError dataflyten, eller omvendt.</xref:System.IO.StreamReader.ReadLine%2A> </xref:System.Diagnostics.Process.BeginErrorReadLine%2A> Du kan imidlertid lese to ulike dataflyter i forskjellige modi. Du kan for eksempel kalle <xref:System.Diagnostics.Process.BeginOutputReadLine%2A>og kaller <xref:System.IO.StreamReader.ReadLine%2A>for StandardError dataflyten.</xref:System.IO.StreamReader.ReadLine%2A> </xref:System.Diagnostics.Process.BeginOutputReadLine%2A>"
  example:
  - "The following example uses the `net use` command together with a user supplied argument to map a network resource. It then reads the standard error stream of the net command and writes it to console.  \n  \n [!code-cs[Process_StandardError#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_41_1.cs)]\n [!code-cpp[Process_StandardError#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_41_1.cpp)]\n [!code-vb[Process_StandardError#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_41_1.vb)]"
  syntax:
    content: public System.IO.StreamReader StandardError { get; }
    return:
      type: System.IO.StreamReader
      description: "En <xref:System.IO.StreamReader>som kan brukes til å lese i standard feilflyt for applikasjonen.</xref:System.IO.StreamReader>"
  overload: System.Diagnostics.Process.StandardError*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "The StandardError stream has not been defined for redirection; ensure &lt;xref:System.Diagnostics.ProcessStartInfo.RedirectStandardError%2A?displayProperty=fullName&gt; is set to <xref uid=\"langword_csharp_true\" name=\"true\" href=\"\"></xref> and &lt;xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName&gt; is set to <xref uid=\"langword_csharp_false\" name=\"false\" href=\"\"></xref>.  \n  \n \\- or -  \n  \n The StandardError stream has been opened for asynchronous read operations with <xref:System.Diagnostics.Process.BeginErrorReadLine*>."
  platform:
  - net462
- uid: System.Diagnostics.Process.StandardInput
  id: StandardInput
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: StandardInput
  nameWithType: Process.StandardInput
  fullName: System.Diagnostics.Process.StandardInput
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Henter en dataflyt som brukes til å skrive inn programmet."
  remarks: "En <xref:System.Diagnostics.Process>kan lese inndatateksten fra den standard inndatastrømmen, vanligvis tastaturet.</xref:System.Diagnostics.Process> Du kan angi inndataene programmatisk ved å omdirigere StandardInput dataflyten. For eksempel i stedet for bruker inndata fra tastaturet, kan du lage tekst fra innholdet i en angitt fil eller utdata fra et annet program.      > [!NOTE] > For å bruke StandardInput, må du angi <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName>til `false`, og du må angi <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardInput%2A?displayProperty=fullName>til `true`.</xref:System.Diagnostics.ProcessStartInfo.RedirectStandardInput%2A?displayProperty=fullName> </xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName> Hvis ikke oppstår skriving til StandardInput dataflyten det et unntak."
  example:
  - "The following example illustrates how to redirect the StandardInput stream of a process. The example starts the `sort` command with redirected input. It then prompts the user for text, and passes that to the `sort` process by means of the redirected StandardInput stream. The `sort` results are displayed to the user on the console.  \n  \n [!code-cs[Process_StandardInput#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_0_1.cs)]\n [!code-cpp[Process_StandardInput#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_0_1.cpp)]\n [!code-vb[Process_StandardInput#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_0_1.vb)]"
  syntax:
    content: public System.IO.StreamWriter StandardInput { get; }
    return:
      type: System.IO.StreamWriter
      description: "En <xref:System.IO.StreamWriter>som kan brukes til å skrive standard inndataflyten for applikasjonen.</xref:System.IO.StreamWriter>"
  overload: System.Diagnostics.Process.StandardInput*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "StandardInput-dataflyten er ikke definert fordi &lt;xref:System.Diagnostics.ProcessStartInfo.RedirectStandardInput%2A?displayProperty=fullName&gt; er satt til <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  platform:
  - net462
- uid: System.Diagnostics.Process.StandardOutput
  id: StandardOutput
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: StandardOutput
  nameWithType: Process.StandardOutput
  fullName: System.Diagnostics.Process.StandardOutput
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Henter en dataflyt som brukes til å lese tekstbaserte resultatet av programmet."
  remarks: "Når en <xref:System.Diagnostics.Process>skriver tekst til den standard dataflyten teksten vises vanligvis i konsollen.</xref:System.Diagnostics.Process> Du kan endre eller undertrykke resultatet av en prosess ved å omdirigere StandardOutput-dataflyt. Du kan for eksempel filtrere teksten, formaterer det på en annen måte, eller skrive utdataene både konsollen og en angitt loggfil.      > [!NOTE] > For å bruke StandardOutput, må du angi <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName>til `false`, og du må angi <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput%2A?displayProperty=fullName>til `true`.</xref:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput%2A?displayProperty=fullName> </xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName> Ellers oppstår lesing fra StandardOutput dataflyten det et unntak.       Kan kopiere dataflyten omdirigerte StandardOutput synkron eller asynkron. Metoder som <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, og <xref:System.IO.StreamReader.ReadToEnd%2A>utføre synkron leseoperasjoner i output-dataflyt av prosessen.</xref:System.IO.StreamReader.ReadToEnd%2A> </xref:System.IO.StreamReader.ReadLine%2A> </xref:System.IO.StreamReader.Read%2A> Disse synkron lese operasjoner ikke fyller ut før den tilknyttede <xref:System.Diagnostics.Process>skriver til StandardOutput-dataflyt eller lukker dataflyten.</xref:System.Diagnostics.Process>       I motsetning <xref:System.Diagnostics.Process.BeginOutputReadLine%2A>starter Asynkrone leseoperasjoner i StandardOutput-dataflyt.</xref:System.Diagnostics.Process.BeginOutputReadLine%2A> Denne metoden gjør det mulig for en angitt hendelsesbehandling for dataflyten-utdata, og returnerer umiddelbart til oppkalleren, som kan utføre andre arbeid mens utdataene dataflyten er rettet mot hendelsesbehandlingen.       Synkron leseoperasjoner introduserer en avhengighet mellom oppkalleren lesing fra StandardOutput-dataflyt og underordnede prosessen skriving til denne dataflyten. Disse avhengighetene kan føre til vranglås betingelser. Når oppkalleren leser fra omadresserte dataflyten for en underordnet prosess, er det avhengige barnet. Oppkalleren venter på leseoperasjonen til barnet skriver til dataflyten eller lukker dataflyten. Når den underordnede prosessen skriver nok data til å fylle den omadresserte dataflyten, er det avhengige av overordnet. Den underordnede prosessen venter på neste Skriveoperasjonen til overordnet leser fra fullstendig dataflyten eller lukker dataflyten. Vranglås betingelsen resultater når oppkalleren og underordnet prosess vente på å fullføre en operasjon, og ingen kan fortsette. Du kan unngå vranglås ved evaluering av avhengigheter mellom oppkaller og underordnet prosess.       Følgende C# kode, for eksempel viser hvordan du lese fra en omadressert dataflyt og venter til den underordnede prosessen å avslutte.      ```   Process p = new Process();   p.StartInfo.UseShellExecute = false;   p.StartInfo.RedirectStandardOutput = true;   p.StartInfo.FileName = &quot;Write500Lines.exe&quot;;   p.Start();      // To avoid deadlocks, always read the output stream first and then wait.   string output = p.StandardOutput.ReadToEnd();   p.WaitForExit();   ```Kodeeksemplet unngår en vranglås betingelse ved å kalle `p.StandardOutput.ReadToEnd` før `p.WaitForExit`. En vranglås betingelse kan skje hvis overordnet behandle kall `p.WaitForExit` før `p.StandardOutput.ReadToEnd` og underordnet prosess skriver nok tekst for å fylle omdirigerte dataflyten. Den overordnede prosessen vil vente på ubestemt tid for den underordnede prosessen å avslutte. Den underordnede prosessen vil vente på ubestemt tid for overordnet å lese fra fullstendig StandardOutput dataflyten.       Det er et lignende problem når du lese alle text fra standard utdata og standard feil dataflyter. Følgende C# kode utfører for eksempel en leseoperasjon på begge dataflyter.      ```   // To avoid deadlocks, use asynchronous read operations on at least one of the streams.   // Do not perform a synchronous read to the end of both redirected streams.   p.BeginOutputReadLine();   string error = p.StandardError.ReadToEnd();   p.WaitForExit();   ```Kodeeksemplet unngår betingelsen vranglås ved å utføre Asynkrone leseoperasjoner på StandardOutput-dataflyt. En vranglås betingelse resultat hvis overordnet behandle kall `p.StandardOutput.ReadToEnd` etterfulgt av `p.StandardError.ReadToEnd` og underordnet prosess skriver nok tekst slik at det fyller feilflyt. Den overordnede prosessen vil vente på ubestemt tid til underordnede prosessen å lukke StandardOutput-dataflyt. Den underordnede prosessen vil vente på ubestemt tid for overordnet å lese fra fullstendige <xref:System.Diagnostics.Process.StandardError%2A>dataflyten.</xref:System.Diagnostics.Process.StandardError%2A>       Du kan bruke Asynkrone leseoperasjoner unngå disse avhengigheter og deres potensielle vranglås. Du kan eventuelt unngå betingelsen vranglås ved oppretting av to tråder og lese utdataene til hver dataflyt i en egen tråd.      > [!NOTE] > Du kan ikke blande asynkrone og Synkrone leseoperasjoner på en omadressert dataflyt. Når omdirigerte dataflyten for en <xref:System.Diagnostics.Process>er åpnet i asynkron eller synkron modus, mer leser alle operasjoner i denne dataflyten må være i samme modus.</xref:System.Diagnostics.Process> For eksempel ikke følger <xref:System.Diagnostics.Process.BeginOutputReadLine%2A>med et kall til <xref:System.IO.StreamReader.ReadLine%2A>for StandardOutput dataflyten, eller omvendt.</xref:System.IO.StreamReader.ReadLine%2A> </xref:System.Diagnostics.Process.BeginOutputReadLine%2A> Du kan imidlertid lese to ulike dataflyter i forskjellige modi. Du kan for eksempel kalle <xref:System.Diagnostics.Process.BeginOutputReadLine%2A>og kaller <xref:System.IO.StreamReader.ReadLine%2A>for den <xref:System.Diagnostics.Process.StandardError%2A>dataflyten.</xref:System.Diagnostics.Process.StandardError%2A> </xref:System.IO.StreamReader.ReadLine%2A> </xref:System.Diagnostics.Process.BeginOutputReadLine%2A>"
  example:
  - "The following example runs the ipconfig.exe command and redirects its standard output to the example’s console window.  \n  \n [!code-vb[Process_StandardOutput#2](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_11_1.vb)]\n [!code-cs[Process_StandardOutput#2](~/add/codesnippet/csharp/p-system.diagnostics.pro_11_1.cs)]\n [!code-cpp[Process_StandardOutput#2](~/add/codesnippet/cpp/p-system.diagnostics.pro_11_1.cpp)]"
  syntax:
    content: public System.IO.StreamReader StandardOutput { get; }
    return:
      type: System.IO.StreamReader
      description: "En <xref:System.IO.StreamReader>som kan brukes til å lese standard utdata-strømmen for applikasjonen.</xref:System.IO.StreamReader>"
  overload: System.Diagnostics.Process.StandardOutput*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "The StandardOutput stream has not been defined for redirection; ensure &lt;xref:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput%2A?displayProperty=fullName&gt; is set to <xref uid=\"langword_csharp_true\" name=\"true\" href=\"\"></xref> and &lt;xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName&gt; is set to <xref uid=\"langword_csharp_false\" name=\"false\" href=\"\"></xref>.  \n  \n \\- or -  \n  \n The StandardOutput stream has been opened for asynchronous read operations with <xref:System.Diagnostics.Process.BeginOutputReadLine*>."
  platform:
  - net462
- uid: System.Diagnostics.Process.Start
  id: Start
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: Start()
  nameWithType: Process.Start()
  fullName: System.Diagnostics.Process.Start()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Starter (eller blir brukt) prosessen ressursen som er angitt av den <xref:System.Diagnostics.Process.StartInfo*>for dette <xref href=&quot;System.Diagnostics.Process&quot;> </xref> komponent knyttes til komponenten.</xref:System.Diagnostics.Process.StartInfo*>"
  remarks: "Use this overload to start a process resource and associate it with the current <xref:System.Diagnostics.Process> component. The return value `true` indicates that a new process resource was started. If the process resource specified by the <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> member of the <xref:System.Diagnostics.Process.StartInfo%2A> property is already running on the computer, no additional process resource is started. Instead, the running process resource is reused and `false` is returned.  \n  \n You can start a ClickOnce application by specifying the location (for example, a Web address) from which you originally installed the application. Do not start a ClickOnce application by specifying its installed location on your hard drive.  \n  \n> [!NOTE]\n>  If you are using Visual Studio, this overload of the Start method is the one that you insert into your code after you drag a <xref:System.Diagnostics.Process> component onto the designer. Use the `Properties` window to expand the `StartInfo` category and write the appropriate value into the `FileName` property. Your changes will appear in the form's `InitializeComponent` procedure.  \n  \n This overload of Start is not a `static` method. You must call it from an instance of the <xref:System.Diagnostics.Process> class. Before calling Start, you must first specify <xref:System.Diagnostics.Process.StartInfo%2A> property information for this <xref:System.Diagnostics.Process> instance, because that information is used to determine the process resource to start.  \n  \n The other overloads of the Start method are `static` members. You do not need to create an instance of the <xref:System.Diagnostics.Process> component before you call those overloads of the method. Instead, you can call Start for the <xref:System.Diagnostics.Process> class itself, and a new <xref:System.Diagnostics.Process> component is created if the process was started. Or, `null` is returned if a process was reused. The process resource is automatically associated with the new <xref:System.Diagnostics.Process> component that is returned by the Start method.  \n  \n The <xref:System.Diagnostics.Process.StartInfo%2A> members can be used to duplicate the functionality of the `Run` dialog box of the Windows `Start` menu. Anything that can be typed into a command line can be started by setting the appropriate values in the <xref:System.Diagnostics.Process.StartInfo%2A> property. The only <xref:System.Diagnostics.Process.StartInfo%2A> property that must be set is the <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> property. The <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> property does not have to be an executable file. It can be of any file type for which the extension has been associated with an application that is installed on the system. For example, the <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> property can have a .txt extension if you have associated text files with an editor, such as Notepad, or it can have a .doc extension if you have associated.doc files with a word processing tool, such as Microsoft Word.  \n  \n In the command line, you can specify actions to take for certain types of files. For example, you can print documents or edit text files. Specify these actions using the <xref:System.Diagnostics.ProcessStartInfo.Verb%2A> member of the <xref:System.Diagnostics.Process.StartInfo%2A> property. For other types of files, you can specify command-line arguments when you start the file from the `Run` dialog box. For example, you can pass a URL as an argument if you specify your browser as the <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>. These arguments can be specified in the <xref:System.Diagnostics.Process.StartInfo%2A> property's <xref:System.Diagnostics.ProcessStartInfo.Arguments%2A> member.  \n  \n If you have a path variable declared in your system using quotes, you must fully qualify that path when starting any process found in that location. Otherwise, the system will not find the path. For example, if `c:\\mypath` is not in your path, and you add it using quotation marks: `path = %path%;\"c:\\mypath\"`, you must fully qualify any process in `c:\\mypath` when starting it.  \n  \n> [!NOTE]\n>  ASP.NET Web page and server control code executes in the context of the ASP.NET worker process on the Web server.  If you use the <xref:System.Diagnostics.Process.Start%2A> method in an ASP.NET Web page or server control, the new process executes on the Web server with restricted permissions. The process does not start in the same context as the client browser, and does not have access to the user desktop.  \n  \n Whenever you use Start to start a process, you might need to close it or you risk losing system resources. Close processes using <xref:System.Diagnostics.Process.CloseMainWindow%2A> or <xref:System.Diagnostics.Process.Kill%2A>. You can check whether a process has already been closed by using its <xref:System.Diagnostics.Process.HasExited%2A> property.  \n  \n A note about apartment states in managed threads is necessary here. When <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> is `true` on the process component's <xref:System.Diagnostics.Process.StartInfo%2A> property, make sure you have set a threading model on your application by setting the attribute `[STAThread]` on the `main()` method. Otherwise, a managed thread can be in an `unknown` state or put in the `MTA` state, the latter of which conflicts with <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> being `true`. Some methods require that the apartment state not be `unknown`. If the state is not explicitly set, when the application encounters such a method, it defaults to `MTA`, and once set, the apartment state cannot be changed. However, `MTA` causes an exception to be thrown when the operating system shell is managing the thread."
  example:
  - "The following example uses an instance of the <xref:System.Diagnostics.Process> class to start a process.  \n  \n [!code-cpp[Process.Start_instance#1](~/add/codesnippet/cpp/m-system.diagnostics.pro_16_1.cpp)]\n [!code-vb[Process.Start_instance#1](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_16_1.vb)]\n [!code-cs[Process.Start_instance#1](~/add/codesnippet/csharp/m-system.diagnostics.pro_16_1.cs)]"
  syntax:
    content: public bool Start ();
    parameters: []
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Hvis en prosess ressurs startes; <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> Hvis ingen nye prosessen ressurs startes (for eksempel hvis en eksisterende prosess brukes på nytt)."
  overload: System.Diagnostics.Process.Start*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Ingen filnavn er angitt i den <xref href=&quot;System.Diagnostics.Process&quot;> </xref> komponentens <> </> *>.       - eller - &lt;xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName&gt; medlem av den <> </> *> egenskapen <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref> mens &lt;xref:System.Diagnostics.ProcessStartInfo.RedirectStandardInput%2A?displayProperty=fullName&gt;, &lt;xref:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput%2A?displayProperty=fullName&gt;, eller &lt;xref:System.Diagnostics.ProcessStartInfo.RedirectStandardError%2A?displayProperty=fullName&gt; er <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>."
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Det oppstod en feil under åpning av den tilknyttede filen."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Process-objektet har allerede blitt fjernet."
  platform:
  - net462
- uid: System.Diagnostics.Process.Start(System.Diagnostics.ProcessStartInfo)
  id: Start(System.Diagnostics.ProcessStartInfo)
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: Start(ProcessStartInfo)
  nameWithType: Process.Start(ProcessStartInfo)
  fullName: System.Diagnostics.Process.Start(ProcessStartInfo)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Starter prosessen ressursen som er angitt i parameteren prosessen start informasjon (for eksempel navnet på prosessen med å starte) og knytter ressursen med en ny <xref href=&quot;System.Diagnostics.Process&quot;> </xref> komponent."
  remarks: "Use this overload to start a process resource by specifying a <xref:System.Diagnostics.ProcessStartInfo> instance. The overload associates the resource with a new <xref:System.Diagnostics.Process> object.  \n  \n> [!NOTE]\n>  If the address of the executable file to start is a URL, the process is not started and `null` is returned.  \n  \n This overload lets you start a process without first creating a new <xref:System.Diagnostics.Process> instance. Using this overload with a <xref:System.Diagnostics.ProcessStartInfo> parameter is an alternative to the explicit steps of creating a new <xref:System.Diagnostics.Process> instance, setting its <xref:System.Diagnostics.Process.StartInfo%2A> properties, and calling <xref:System.Diagnostics.Process.Start%2A> for the <xref:System.Diagnostics.Process> instance.  \n  \n Using a <xref:System.Diagnostics.ProcessStartInfo> instance as the parameter lets you call <xref:System.Diagnostics.Process.Start%2A> with the most control over what is passed into the call to start the process. If you need to pass only a file name or a file name and arguments, it is not necessary to create a new <xref:System.Diagnostics.ProcessStartInfo> instance, although that is an option. The only <xref:System.Diagnostics.Process.StartInfo%2A> property that must be set is the <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> property. The <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> property does not need to represent an executable file. It can be of any file type for which the extension has been associated with an application that is installed on the system. For example, the <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> property can have a .txt extension if you have associated text files with an editor, such as Notepad, or it can have a .doc extension if you have associated.doc files with a word processing tool, such as Microsoft Word.  \n  \n You can start a ClickOnce application by specifying the location (for example, a Web address) from which you originally installed the application. Do not start a ClickOnce application by specifying its installed location on your hard drive.  \n  \n If the <xref:System.Diagnostics.ProcessStartInfo.UserName%2A> and <xref:System.Diagnostics.ProcessStartInfo.Password%2A> properties of the <xref:System.Diagnostics.Process.StartInfo%2A> instance are set, the unmanaged `CreateProcessWithLogonW` function is called, which starts the process in a new window even if the <xref:System.Diagnostics.ProcessStartInfo.CreateNoWindow%2A> property value is `true` or the <xref:System.Diagnostics.ProcessStartInfo.WindowStyle%2A> property value is <xref:System.Diagnostics.ProcessWindowStyle>.  \n  \n Unlike the other overloads, the overload of <xref:System.Diagnostics.Process.Start%2A> that has no parameters is not a `static` member. Use that overload when you have already created a <xref:System.Diagnostics.Process> instance, specified start information (including the file name), and want to start a process resource and associate it with the existing <xref:System.Diagnostics.Process> instance. Use one of the `static` overloads when you want to create a new <xref:System.Diagnostics.Process> component rather than start a process for an existing component. Both this overload and the overload that has no parameters allow you to specify the start information for the process resource by using a <xref:System.Diagnostics.ProcessStartInfo> instance.  \n  \n If you have a path variable declared in your system using quotes, you must fully qualify that path when starting any process found in that location. Otherwise, the system will not find the path. For example, if `c:\\mypath` is not in your path, and you add it using quotation marks: `path = %path%;\"c:\\mypath\"`, you must fully qualify any process in `c:\\mypath` when starting it.  \n  \n> [!NOTE]\n>  ASP.NET Web page and server control code executes in the context of the ASP.NET worker process on the Web server.  If you use the <xref:System.Diagnostics.Process.Start%2A> method in an ASP.NET Web page or server control, the new process executes on the Web server with restricted permissions. The process does not start in the same context as the client browser, and does not have access to the user desktop.  \n  \n Whenever you use <xref:System.Diagnostics.Process.Start%2A> to start a process, you might need to close it or you risk losing system resources. Close processes using <xref:System.Diagnostics.Process.CloseMainWindow%2A> or <xref:System.Diagnostics.Process.Kill%2A>. You can check whether a process has already been closed by using its <xref:System.Diagnostics.Process.HasExited%2A> property.  \n  \n A note about apartment states in managed threads is necessary here. When <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> is `true` on the `startInfo` parameter, make sure you have set a threading model on your application by setting the attribute `[STAThread]` on the `main()` method. Otherwise, a managed thread can be in an `unknown` state or put in the `MTA` state, the latter of which conflicts with <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> being `true`. Some methods require that the apartment state not be `unknown`. If the state is not explicitly set, when the application encounters such a method, it defaults to `MTA`, and once set, the apartment state cannot be changed. However, `MTA` causes an exception to be thrown when the operating system shell is managing the thread."
  example:
  - "The following example first spawns an instance of Internet Explorer and displays the contents of the Favorites folder in the browser. It then starts some other instances of Internet Explorer and displays some specific pages or sites. Finally it starts Internet Explorer with the window being minimized while navigating to a specific site.  \n  \n For additional examples of other uses of this method, refer to the individual properties of the <xref:System.Diagnostics.ProcessStartInfo> class.  \n  \n [!code-vb[Process.Start_static#1](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_17_1.vb)]\n [!code-cs[Process.Start_static#1](~/add/codesnippet/csharp/m-system.diagnostics.pro_17_1.cs)]\n [!code-cpp[Process.Start_static#1](~/add/codesnippet/cpp/m-system.diagnostics.pro_17_1.cpp)]"
  syntax:
    content: public static System.Diagnostics.Process Start (System.Diagnostics.ProcessStartInfo startInfo);
    parameters:
    - id: startInfo
      type: System.Diagnostics.ProcessStartInfo
      description: "Den <xref href=&quot;System.Diagnostics.ProcessStartInfo&quot;> </xref> som inneholder informasjon som brukes til å starte prosessen, inkludert filnavnet og noen kommandolinjeargumenter."
    return:
      type: System.Diagnostics.Process
      description: "En ny <xref href=&quot;System.Diagnostics.Process&quot;> </xref> som er knyttet til prosess-ressursen eller <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> Hvis ingen ressurser i prosessen er startet. Legg merke til at en ny prosess startes ved siden av forekomster av den samme prosessen kjører allerede blir uavhengig fra de andre. Start kan i tillegg returnere en ikke-null-prosess med den <xref:System.Diagnostics.Process.HasExited*>egenskapen allerede er satt til <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>.</xref:System.Diagnostics.Process.HasExited*> I dette tilfellet kan startet prosessen har aktivert en eksisterende forekomst av seg selv og deretter avsluttet."
  overload: System.Diagnostics.Process.Start*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Ingen filnavn er angitt i den <code> startInfo </code> parameteren <> </> *> egenskapen.       -or-       The <>*> property of the <code>startInfo</code> parameter is <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref> and the <>*>, <>*>, or <>*> property is also <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>.       - eller - <> </> *>-egenskapen for den <code> startInfo </code> parameteren er <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref> og <> </> *> egenskapen er ikke <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> eller tom eller <> </> *> egenskapen er ikke <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>startInfo</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Process-objektet har allerede blitt fjernet."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "Den angitte filen i den <code> startInfo </code> parameteren <xref:System.Diagnostics.ProcessStartInfo.FileName*>Finner ikke egenskapen.</xref:System.Diagnostics.ProcessStartInfo.FileName*>"
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Det oppstod en feil under åpning av den tilknyttede filen.       - eller - summen av argumentene, og den fullstendige banen til prosessen overstiger 2080. Feilmeldingen som er knyttet til dette unntaket kan være én av følgende: &quot;dataområdet som sendes til en systemfeil er for liten.&quot; eller &quot;Ingen tilgang.&quot;"
  platform:
  - net462
- uid: System.Diagnostics.Process.Start(System.String)
  id: Start(System.String)
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: Start(String)
  nameWithType: Process.Start(String)
  fullName: System.Diagnostics.Process.Start(String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Starter en ressurs for prosessen ved å angi navnet på et dokument eller program filen og knytter ressursen med en ny <xref href=&quot;System.Diagnostics.Process&quot;> </xref> komponent."
  remarks: "Use this overload to start a process resource by specifying its file name. The overload associates the resource with a new <xref:System.Diagnostics.Process> object.  \n  \n> [!NOTE]\n>  If the address of the executable file to start is a URL, the process is not started and `null` is returned.  \n  \n This overload lets you start a process without first creating a new <xref:System.Diagnostics.Process> instance. The overload is an alternative to the explicit steps of creating a new <xref:System.Diagnostics.Process> instance, setting the <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> member of the <xref:System.Diagnostics.Process.StartInfo%2A> property, and calling <xref:System.Diagnostics.Process.Start%2A> for the <xref:System.Diagnostics.Process> instance.  \n  \n You can start a ClickOnce application by setting the `fileName` parameter to the location (for example, a Web address) from which you originally installed the application. Do not start a ClickOnce application by specifying its installed location on your hard drive.  \n  \n Starting a process by specifying its file name is similar to typing the information in the `Run` dialog box of the Windows `Start` menu. Therefore, the file name does not need to represent an executable file. It can be of any file type for which the extension has been associated with an application installed on the system. For example the file name can have a .txt extension if you have associated text files with an editor, such as Notepad, or it can have a .doc if you have associated.doc files with a word processing tool, such as Microsoft Word. Similarly, in the same way that the `Run` dialog box can accept an executable file name with or without the .exe extension, the .exe extension is optional in the `fileName` parameter. For example, you can set the `fileName` parameter to either \"Notepad.exe\" or \"Notepad\".  \n  \n This overload does not allow command-line arguments for the process. If you need to specify one or more command-line arguments for the process, use the <xref:System.Diagnostics.Process.Start%28System.Diagnostics.ProcessStartInfo%29?displayProperty=fullName> or <xref:System.Diagnostics.Process.Start%28System.String%2CSystem.String%29?displayProperty=fullName> overloads.  \n  \n Unlike the other overloads, the overload of <xref:System.Diagnostics.Process.Start%2A> that has no parameters is not a `static` member. Use that overload when you have already created a <xref:System.Diagnostics.Process> instance, specified start information (including the file name), and want to start a process resource and associate it with the existing <xref:System.Diagnostics.Process> instance. Use one of the `static` overloads when you want to create a new <xref:System.Diagnostics.Process> component rather than start a process for an existing component. Both this overload and the overload that has no parameters allow you to specify the file name of the process resource to start.  \n  \n If you have a path variable declared in your system using quotes, you must fully qualify that path when starting any process found in that location. Otherwise, the system will not find the path. For example, if `c:\\mypath` is not in your path, and you add it using quotation marks: `path = %path%;\"c:\\mypath\"`, you must fully qualify any process in `c:\\mypath` when starting it.  \n  \n> [!NOTE]\n>  ASP.NET Web page and server control code executes in the context of the ASP.NET worker process on the Web server.  If you use the <xref:System.Diagnostics.Process.Start%2A> method in an ASP.NET Web page or server control, the new process executes on the Web server with restricted permissions. The process does not start in the same context as the client browser, and does not have access to the user desktop.  \n  \n Whenever you use <xref:System.Diagnostics.Process.Start%2A> to start a process, you might need to close it or you risk losing system resources. Close processes using <xref:System.Diagnostics.Process.CloseMainWindow%2A> or <xref:System.Diagnostics.Process.Kill%2A>. You can check whether a process has already been closed by using its <xref:System.Diagnostics.Process.HasExited%2A> property.  \n  \n A note about apartment states in managed threads is necessary here. When <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> is `true` on the process component's <xref:System.Diagnostics.Process.StartInfo%2A> property, make sure you have set a threading model on your application by setting the attribute `[STAThread]` on the `main()` method. Otherwise, a managed thread can be in an `unknown` state or put in the `MTA` state, the latter of which conflicts with <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> being `true`. Some methods require that the apartment state not be `unknown`. If the state is not explicitly set, when the application encounters such a method, it defaults to `MTA`, and once set, the apartment state cannot be changed. However, `MTA` causes an exception to be thrown when the operating system shell is managing the thread."
  example:
  - "The following example first spawns an instance of Internet Explorer and displays the contents of the Favorites folder in the browser. It then starts some other instances of Internet Explorer and displays some specific pages or sites. Finally it starts Internet Explorer with the window being minimized while navigating to a specific site.  \n  \n [!code-vb[Process.Start_static#1](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_2_1.vb)]\n [!code-cs[Process.Start_static#1](~/add/codesnippet/csharp/m-system.diagnostics.pro_2_1.cs)]\n [!code-cpp[Process.Start_static#1](~/add/codesnippet/cpp/m-system.diagnostics.pro_2_1.cpp)]"
  syntax:
    content: public static System.Diagnostics.Process Start (string fileName);
    parameters:
    - id: fileName
      type: System.String
      description: "Navnet på et dokument eller programmet til å kjøre i prosessen."
    return:
      type: System.Diagnostics.Process
      description: "En ny <xref href=&quot;System.Diagnostics.Process&quot;> </xref> som er knyttet til prosess-ressursen eller <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> Hvis ingen ressurser i prosessen er startet. Legg merke til at en ny prosess startes ved siden av forekomster av den samme prosessen kjører allerede blir uavhengig fra de andre. Start kan i tillegg returnere en ikke-null-prosess med den <xref:System.Diagnostics.Process.HasExited*>egenskapen allerede er satt til <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>.</xref:System.Diagnostics.Process.HasExited*> I dette tilfellet kan startet prosessen har aktivert en eksisterende forekomst av seg selv og deretter avsluttet."
  overload: System.Diagnostics.Process.Start*
  exceptions:
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Det oppstod en feil under åpning av den tilknyttede filen."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Process-objektet har allerede blitt fjernet."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "Miljøvariabelen PATH har en streng som inneholder anførselstegn."
  platform:
  - net462
- uid: System.Diagnostics.Process.Start(System.String,System.String)
  id: Start(System.String,System.String)
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: Start(String,String)
  nameWithType: Process.Start(String,String)
  fullName: System.Diagnostics.Process.Start(String,String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Starter en ressurs for prosessen ved å angi navnet på et program og et sett med kommandolinjeargumenter og knytter ressursen med en ny <xref href=&quot;System.Diagnostics.Process&quot;> </xref> komponent."
  remarks: "Use this overload to start a process resource by specifying its file name and command-line arguments. The overload associates the resource with a new <xref:System.Diagnostics.Process> object.  \n  \n> [!NOTE]\n>  If the address of the executable file to start is a URL, the process is not started and `null` is returned.  \n  \n This overload lets you start a process without first creating a new <xref:System.Diagnostics.Process> instance. The overload is an alternative to the explicit steps of creating a new <xref:System.Diagnostics.Process> instance, setting the <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> and <xref:System.Diagnostics.ProcessStartInfo.Arguments%2A> members of the <xref:System.Diagnostics.Process.StartInfo%2A> property, and calling <xref:System.Diagnostics.Process.Start%2A> for the <xref:System.Diagnostics.Process> instance.  \n  \n Starting a process by specifying its file name and arguments is similar to typing the file name and command-line arguments in the `Run` dialog box of the Windows `Start` menu. Therefore, the file name does not need to represent an executable file. It can be of any file type for which the extension has been associated with an application installed on the system. For example the file name can have a .txt extension if you have associated text files with an editor, such as Notepad, or it can have a .doc if you have associated.doc files with a word processing tool, such as Microsoft Word. Similarly, in the same way that the `Run` dialog box can accept an executable file name with or without the .exe extension, the .exe extension is optional in the `fileName` parameter. For example, you can set the `fileName` parameter to either \"Notepad.exe\" or \"Notepad\". If the `fileName` parameter represents an executable file, the `arguments` parameter might represent a file to act upon, such as the text file in `Notepad.exe myfile.txt`. If the `fileName` parameter represents a command (.cmd) file, the `arguments` parameter must include either a \"`/c`\" or \"`/k`\" argument to specify whether the command window exits or remains after completion.  \n  \n Unlike the other overloads, the overload of <xref:System.Diagnostics.Process.Start%2A> that has no parameters is not a `static` member. Use that overload when you have already created a <xref:System.Diagnostics.Process> instance, specified start information (including the file name), and want to start a process resource and associate it with the existing <xref:System.Diagnostics.Process> instance. Use one of the `static` overloads when you want to create a new <xref:System.Diagnostics.Process> component rather than start a process for an existing component. Both this overload and the overload that has no parameters allow you to specify the file name of the process resource to start and command-line arguments to pass.  \n  \n If you have a path variable declared in your system using quotes, you must fully qualify that path when starting any process found in that location. Otherwise, the system will not find the path. For example, if `c:\\mypath` is not in your path, and you add it using quotation marks: `path = %path%;\"c:\\mypath\"`, you must fully qualify any process in `c:\\mypath` when starting it.  \n  \n> [!NOTE]\n>  ASP.NET Web page and server control code executes in the context of the ASP.NET worker process on the Web server.  If you use the <xref:System.Diagnostics.Process.Start%2A> method in an ASP.NET Web page or server control, the new process executes on the Web server with restricted permissions. The process does not start in the same context as the client browser, and does not have access to the user desktop.  \n  \n Whenever you use <xref:System.Diagnostics.Process.Start%2A> to start a process, you might need to close it or you risk losing system resources. Close processes using <xref:System.Diagnostics.Process.CloseMainWindow%2A> or <xref:System.Diagnostics.Process.Kill%2A>. You can check whether a process has already been closed by using its <xref:System.Diagnostics.Process.HasExited%2A> property..  \n  \n A note about apartment states in managed threads is necessary here. When <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> is `true` on the process component's <xref:System.Diagnostics.Process.StartInfo%2A> property, make sure you have set a threading model on your application by setting the attribute `[STAThread]` on the `main()` method. Otherwise, a managed thread can be in an `unknown` state or put in the `MTA` state, the latter of which conflicts with <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> being `true`. Some methods require that the apartment state not be `unknown`. If the state is not explicitly set, when the application encounters such a method, it defaults to `MTA`, and once set, the apartment state cannot be changed. However, `MTA` causes an exception to be thrown when the operating system shell is managing the thread."
  example:
  - "The following example first spawns an instance of Internet Explorer and displays the contents of the Favorites folder in the browser. It then starts some other instances of Internet Explorer and displays some specific pages or sites. Finally it starts Internet Explorer with the window being minimized while navigating to a specific site.  \n  \n [!code-vb[Process.Start_static#1](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_20_1.vb)]\n [!code-cs[Process.Start_static#1](~/add/codesnippet/csharp/m-system.diagnostics.pro_20_1.cs)]\n [!code-cpp[Process.Start_static#1](~/add/codesnippet/cpp/m-system.diagnostics.pro_20_1.cpp)]"
  syntax:
    content: public static System.Diagnostics.Process Start (string fileName, string arguments);
    parameters:
    - id: fileName
      type: System.String
      description: "Navnet på en fil til å kjøre i prosessen."
    - id: arguments
      type: System.String
      description: "Kommandolinjeargumenter skal sendes når du starter prosessen."
    return:
      type: System.Diagnostics.Process
      description: "En ny <xref href=&quot;System.Diagnostics.Process&quot;> </xref> som er knyttet til prosess-ressursen eller <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> Hvis ingen ressurser i prosessen er startet. Legg merke til at en ny prosess startes ved siden av forekomster av den samme prosessen kjører allerede blir uavhengig fra de andre. Start kan i tillegg returnere en ikke-null-prosess med den <xref:System.Diagnostics.Process.HasExited*>egenskapen allerede er satt til <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>.</xref:System.Diagnostics.Process.HasExited*> I dette tilfellet kan startet prosessen har aktivert en eksisterende forekomst av seg selv og deretter avsluttet."
  overload: System.Diagnostics.Process.Start*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "The <code>fileName</code> or <code>arguments</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Det oppstod en feil under åpning av den tilknyttede filen.       - eller - summen av argumentene, og den fullstendige banen til prosessen overstiger 2080. Feilmeldingen som er knyttet til dette unntaket kan være én av følgende: &quot;dataområdet som sendes til en systemfeil er for liten.&quot; eller &quot;Ingen tilgang.&quot;"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Process-objektet har allerede blitt fjernet."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "Miljøvariabelen PATH har en streng som inneholder anførselstegn."
  platform:
  - net462
- uid: System.Diagnostics.Process.Start(System.String,System.String,System.Security.SecureString,System.String)
  id: Start(System.String,System.String,System.Security.SecureString,System.String)
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: Start(String,String,SecureString,String)
  nameWithType: Process.Start(String,String,SecureString,String)
  fullName: System.Diagnostics.Process.Start(String,String,SecureString,String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Starter en ressurs for prosessen ved å angi navnet på et program, et brukernavn, passord og domene og knytter ressursen med en ny <xref href=&quot;System.Diagnostics.Process&quot;> </xref> komponent."
  remarks: "Bruk denne overlasten til å opprette en ny prosess og primære tråder ved å angi den filnavn, brukernavn, passord og domene. Den nye prosessen deretter kjører den angitte kjørbare filen i sikkerhetskonteksten for den angitte legitimasjonen (brukeren, domenet og passordet).      > [!NOTE] > Når den kjørbare filen er plassert på en ekstern stasjon, må du identifisere nettverksressursen ved hjelp av en URIEN uniform resource identifier (), ikke en koblede stasjonsbokstav.      > [!NOTE] > Hvis adressen til den kjørbare filen for å starte en URL-adresse, prosessen er ikke startet og `null` returneres.       Denne overlasten kan du starte en prosess uten først å lage en ny <xref:System.Diagnostics.Process>forekomsten.</xref:System.Diagnostics.Process> Overlasten er et alternativ til eksplisitte trinnene for å opprette en ny <xref:System.Diagnostics.Process>forekomsten innstillingen av <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>, <xref:System.Diagnostics.ProcessStartInfo.UserName%2A>, <xref:System.Diagnostics.ProcessStartInfo.Password%2A>, og <xref:System.Diagnostics.ProcessStartInfo.Domain%2A>egenskapene for den <xref:System.Diagnostics.Process.StartInfo%2A>egenskapen og kaller <xref:System.Diagnostics.Process.Start%2A>for den <xref:System.Diagnostics.Process>forekomsten.</xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.Start%2A> </xref:System.Diagnostics.Process.StartInfo%2A> </xref:System.Diagnostics.ProcessStartInfo.Domain%2A> </xref:System.Diagnostics.ProcessStartInfo.Password%2A> </xref:System.Diagnostics.ProcessStartInfo.UserName%2A> </xref:System.Diagnostics.ProcessStartInfo.FileName%2A> </xref:System.Diagnostics.Process>       På samme måte i samme måter som den **kjøre** dialogboksen godtar navnet på en kjørbar fil med eller uten filtypen .exe, filtypen .exe er valgfrie i den `fileName` parameteren. Du kan for eksempel ikke angi den `fileName` &quot;Notepad.exe&quot; eller &quot;Notisblokk&quot;-parameter. Hvis den `fileName` parameteren representerer en kjørbar fil, i `arguments` parameteren kan representere en fil som skal brukes, for eksempel tekstfilen i `Notepad.exe myfile.txt`.      > [!NOTE] > Filnavnet må representere en kjørbar fil i den <xref:System.Diagnostics.Process.Start%2A>overlastingene som har `userName`, `password`, og `domain` parametere.</xref:System.Diagnostics.Process.Start%2A>       Når du bruker <xref:System.Diagnostics.Process.Start%2A>for å starte en, kan du må lukke den eller risikerer du å miste systemressurser.</xref:System.Diagnostics.Process.Start%2A> Lukk prosesser bruker <xref:System.Diagnostics.Process.CloseMainWindow%2A>eller <xref:System.Diagnostics.Process.Kill%2A>.</xref:System.Diagnostics.Process.Kill%2A> </xref:System.Diagnostics.Process.CloseMainWindow%2A> Du kan kontrollere om en prosess allerede er lukket ved hjelp av den <xref:System.Diagnostics.Process.HasExited%2A>egenskapen.</xref:System.Diagnostics.Process.HasExited%2A>"
  example:
  - "The following code example shows the use of this overload to start an executable file and also demonstrates the throwing of a <xref:System.ComponentModel.Win32Exception> when an attempt is made to start an application associated with a nonexecutable file.  \n  \n [!code-cs[System.Diagnostics.Process.Start#1](~/add/codesnippet/csharp/fff1e658-5eee-484b-80e5-_1.cs)]\n [!code-vb[System.Diagnostics.Process.Start#1](~/add/codesnippet/visualbasic/fff1e658-5eee-484b-80e5-_1.vb)]"
  syntax:
    content: public static System.Diagnostics.Process Start (string fileName, string userName, System.Security.SecureString password, string domain);
    parameters:
    - id: fileName
      type: System.String
      description: "Navnet på en fil til å kjøre i prosessen."
    - id: userName
      type: System.String
      description: "Brukernavnet som skal brukes for å starte prosessen."
    - id: password
      type: System.Security.SecureString
      description: "En <xref href=&quot;System.Security.SecureString&quot;> </xref> som inneholder passordet som skal brukes når du starter prosessen."
    - id: domain
      type: System.String
      description: "Domenet som skal brukes for å starte prosessen."
    return:
      type: System.Diagnostics.Process
      description: "En ny <xref href=&quot;System.Diagnostics.Process&quot;> </xref> som er knyttet til prosess-ressursen eller <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> Hvis ingen ressurser i prosessen er startet. Legg merke til at en ny prosess startes ved siden av forekomster av den samme prosessen kjører allerede blir uavhengig fra de andre. Start kan i tillegg returnere en ikke-null-prosess med den <xref:System.Diagnostics.Process.HasExited*>egenskapen allerede er satt til <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>.</xref:System.Diagnostics.Process.HasExited*> I dette tilfellet kan startet prosessen har aktivert en eksisterende forekomst av seg selv og deretter avsluttet."
  overload: System.Diagnostics.Process.Start*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Ingen filnavn er angitt."
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Det oppstod en feil under åpning av den tilknyttede filen."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Process-objektet har allerede blitt fjernet."
  platform:
  - net462
- uid: System.Diagnostics.Process.Start(System.String,System.String,System.String,System.Security.SecureString,System.String)
  id: Start(System.String,System.String,System.String,System.Security.SecureString,System.String)
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: Start(String,String,String,SecureString,String)
  nameWithType: Process.Start(String,String,String,SecureString,String)
  fullName: System.Diagnostics.Process.Start(String,String,String,SecureString,String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Starter en ressurs for prosessen ved å angi navnet på et program, et sett med kommandolinjeargumenter, et brukernavn, passord og domene og knytter ressursen med en ny <xref href=&quot;System.Diagnostics.Process&quot;> </xref> komponent."
  remarks: "Bruk denne overlasten til å opprette en ny prosess og primære tråder ved å angi den filnavn kommandolinjeargumenter, brukernavn, passord og domene. Den nye prosessen deretter kjører den angitte kjørbare filen i sikkerhetskonteksten for den angitte legitimasjonen (brukeren, domenet og passordet).      > [!NOTE] > Når den kjørbare filen er plassert på en ekstern stasjon, må du identifisere nettverksressursen ved hjelp av en URIEN uniform resource identifier (), ikke en koblede stasjonsbokstav.      > [!NOTE] > Hvis adressen til den kjørbare filen for å starte en URL-adresse, prosessen er ikke startet og `null` returneres.       Denne overlasten kan du starte en prosess uten først å lage en ny <xref:System.Diagnostics.Process>forekomsten.</xref:System.Diagnostics.Process> Overlasten er et alternativ til eksplisitte trinnene for å opprette en ny <xref:System.Diagnostics.Process>forekomsten innstillingen av <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>, <xref:System.Diagnostics.ProcessStartInfo.Arguments%2A>, <xref:System.Diagnostics.ProcessStartInfo.UserName%2A>, <xref:System.Diagnostics.ProcessStartInfo.Password%2A>, og <xref:System.Diagnostics.ProcessStartInfo.Domain%2A>egenskapene for den <xref:System.Diagnostics.Process.StartInfo%2A>egenskapen og kaller <xref:System.Diagnostics.Process.Start%2A>for den <xref:System.Diagnostics.Process>forekomsten.</xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.Start%2A> </xref:System.Diagnostics.Process.StartInfo%2A> </xref:System.Diagnostics.ProcessStartInfo.Domain%2A> </xref:System.Diagnostics.ProcessStartInfo.Password%2A> </xref:System.Diagnostics.ProcessStartInfo.UserName%2A> </xref:System.Diagnostics.ProcessStartInfo.Arguments%2A> </xref:System.Diagnostics.ProcessStartInfo.FileName%2A> </xref:System.Diagnostics.Process>       På samme måte i samme måter som den **kjøre** dialogboksen godtar navnet på en kjørbar fil med eller uten filtypen .exe, filtypen .exe er valgfrie i den `fileName` parameteren. Du kan for eksempel ikke angi den `fileName` &quot;Notepad.exe&quot; eller &quot;Notisblokk&quot;-parameter. Hvis den `fileName` parameteren representerer en kjørbar fil, i `arguments` parameteren kan representere en fil som skal brukes, for eksempel tekstfilen i `Notepad.exe myfile.txt`.      > [!NOTE] > Filnavnet må representere en kjørbar fil i den <xref:System.Diagnostics.Process.Start%2A>overlastingene som har `userName`, `password`, og `domain` parametere.</xref:System.Diagnostics.Process.Start%2A>       Når du bruker <xref:System.Diagnostics.Process.Start%2A>for å starte en, kan du må lukke den eller risikerer du å miste systemressurser.</xref:System.Diagnostics.Process.Start%2A> Lukk prosesser bruker <xref:System.Diagnostics.Process.CloseMainWindow%2A>eller <xref:System.Diagnostics.Process.Kill%2A>.</xref:System.Diagnostics.Process.Kill%2A> </xref:System.Diagnostics.Process.CloseMainWindow%2A> Du kan kontrollere om en prosess allerede er lukket ved hjelp av den <xref:System.Diagnostics.Process.HasExited%2A>egenskapen.</xref:System.Diagnostics.Process.HasExited%2A>"
  syntax:
    content: public static System.Diagnostics.Process Start (string fileName, string arguments, string userName, System.Security.SecureString password, string domain);
    parameters:
    - id: fileName
      type: System.String
      description: "Navnet på en fil til å kjøre i prosessen."
    - id: arguments
      type: System.String
      description: "Kommandolinjeargumenter skal sendes når du starter prosessen."
    - id: userName
      type: System.String
      description: "Brukernavnet som skal brukes for å starte prosessen."
    - id: password
      type: System.Security.SecureString
      description: "En <xref href=&quot;System.Security.SecureString&quot;> </xref> som inneholder passordet som skal brukes når du starter prosessen."
    - id: domain
      type: System.String
      description: "Domenet som skal brukes for å starte prosessen."
    return:
      type: System.Diagnostics.Process
      description: "En ny <xref href=&quot;System.Diagnostics.Process&quot;> </xref> som er knyttet til prosess-ressursen eller <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> Hvis ingen ressurser i prosessen er startet. Legg merke til at en ny prosess startes ved siden av forekomster av den samme prosessen kjører allerede blir uavhengig fra de andre. Start kan i tillegg returnere en ikke-null-prosess med den <xref:System.Diagnostics.Process.HasExited*>egenskapen allerede er satt til <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>.</xref:System.Diagnostics.Process.HasExited*> I dette tilfellet kan startet prosessen har aktivert en eksisterende forekomst av seg selv og deretter avsluttet."
  overload: System.Diagnostics.Process.Start*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Ingen filnavn er angitt."
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Det oppstod en feil under åpning av den tilknyttede filen.       - eller - summen av argumentene, og den fullstendige banen til den tilknyttede filen overstiger 2080. Feilmeldingen som er knyttet til dette unntaket kan være én av følgende: &quot;dataområdet som sendes til en systemfeil er for liten.&quot; eller &quot;Ingen tilgang.&quot;"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Process-objektet har allerede blitt fjernet."
  platform:
  - net462
- uid: System.Diagnostics.Process.StartInfo
  id: StartInfo
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: StartInfo
  nameWithType: Process.StartInfo
  fullName: System.Diagnostics.Process.StartInfo
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Henter eller angir egenskapene som skal sendes til den <xref:System.Diagnostics.Process.Start*>metoden for den <xref href=&quot;System.Diagnostics.Process&quot;> </xref>.</xref:System.Diagnostics.Process.Start*>"
  remarks: "StartInfo representerer settet med parametere som brukes til å opprette en prosess. Når <xref:System.Diagnostics.Process.Start%2A>er kalt, StartInfo brukes til å angi prosessen med å starte.</xref:System.Diagnostics.Process.Start%2A> Er bare nødvendige StartInfo-medlemmet ikke angi den <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>egenskapen.</xref:System.Diagnostics.ProcessStartInfo.FileName%2A> Starter en prosess ved å angi den <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>egenskapen ligner på å skrive inn informasjonen i den **kjøre** dialogboksen av **Start** menyen.</xref:System.Diagnostics.ProcessStartInfo.FileName%2A> Derfor den <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>egenskapen trenger ikke å representere en kjørbar fil.</xref:System.Diagnostics.ProcessStartInfo.FileName%2A> Det kan ha en filtype som filtypen er tilknyttet med et program som er installert på systemet. For eksempel den <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>kan ha ender Hvis du har knyttet tekstfiler et tekstredigeringsprogram, for eksempel Notisblokk, eller den kan ha en DOC Hvis du har associated.doc filer med en Tekstbehandling-verktøyet, for eksempel Microsoft Word.</xref:System.Diagnostics.ProcessStartInfo.FileName%2A> På samme måte i samme måter som den **kjøre** dialogboksen godtar navnet på en kjørbar fil med eller uten filtypen .exe, filtypen .exe er valgfrie i den <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>medlem.</xref:System.Diagnostics.ProcessStartInfo.FileName%2A> Du kan for eksempel ikke angi den <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>egenskapen &quot;Notepad.exe&quot; eller &quot;Notisblokk&quot;.</xref:System.Diagnostics.ProcessStartInfo.FileName%2A>       Du kan starte ClickOnce-programmet ved å angi den <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>egenskapen dit (for eksempel en webadresse) som du installerte programmet.</xref:System.Diagnostics.ProcessStartInfo.FileName%2A> Start ikke ClickOnce-programmet ved å angi plasseringen installert på harddisken.       Hvis filnavnet inkluderer en ikke-kjørbar fil, for eksempel en fil med DOC, kan du inkludere et verb som angir hvilken handling som skal utføres på filen. Du kan for eksempel ikke angi den <xref:System.Diagnostics.ProcessStartInfo.Verb%2A>til &quot;Print&quot; om en fil i DOC-filtypen.</xref:System.Diagnostics.ProcessStartInfo.Verb%2A> Angitt filnavn i den <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>egenskapen trenger ikke å ha en filtype Hvis du angir en verdi for manuelt i <xref:System.Diagnostics.ProcessStartInfo.Verb%2A>egenskapen.</xref:System.Diagnostics.ProcessStartInfo.Verb%2A> </xref:System.Diagnostics.ProcessStartInfo.FileName%2A> Men hvis du bruker den <xref:System.Diagnostics.ProcessStartInfo.Verbs%2A>til å fastslå hvilke verb som er tilgjengelige, må du ta med filtypen.</xref:System.Diagnostics.ProcessStartInfo.Verbs%2A>       Du kan endre parameterne som er angitt i egenskapen StartInfo opptil tidspunktet når du kaller den <xref:System.Diagnostics.Process.Start%2A>-metoden på prosessen.</xref:System.Diagnostics.Process.Start%2A> Når du har startet prosessen, endring av StartInfo verdiene ikke påvirke eller starte den tilknyttede prosessen. Hvis du kaller den <xref:System.Diagnostics.Process.Start%28System.Diagnostics.ProcessStartInfo%29>metoden med den <xref:System.Diagnostics.ProcessStartInfo.UserName%2A?displayProperty=fullName>og <xref:System.Diagnostics.ProcessStartInfo.Password%2A?displayProperty=fullName>angitt egenskaper, den uforvaltede `CreateProcessWithLogonW` funksjonen kalles, som starter prosessen i et nytt vindu selv om den <xref:System.Diagnostics.ProcessStartInfo.CreateNoWindow%2A>egenskapsverdi `true` eller <xref:System.Diagnostics.ProcessStartInfo.WindowStyle%2A>egenskapsverdien er <xref:System.Diagnostics.ProcessWindowStyle>.</xref:System.Diagnostics.ProcessWindowStyle> </xref:System.Diagnostics.ProcessStartInfo.WindowStyle%2A> </xref:System.Diagnostics.ProcessStartInfo.CreateNoWindow%2A> </xref:System.Diagnostics.ProcessStartInfo.Password%2A?displayProperty=fullName> </xref:System.Diagnostics.ProcessStartInfo.UserName%2A?displayProperty=fullName> </xref:System.Diagnostics.Process.Start%28System.Diagnostics.ProcessStartInfo%29>       Hvis du ikke brukte den <xref:System.Diagnostics.Process.Start%2A>metode for å starte prosessen egenskapen StartInfo gjenspeiler ikke parametere som brukes til å starte prosessen.</xref:System.Diagnostics.Process.Start%2A> Hvis du bruker for eksempel <xref:System.Diagnostics.Process.GetProcesses%2A>å hente en matrise av prosessene som kjører på datamaskinen, egenskapen StartInfo for hver <xref:System.Diagnostics.Process>inneholder ikke originale filnavnet eller argumenter som brukes til å starte prosessen.</xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.GetProcesses%2A>       Når prosessen er startet, filnavnet er filen fyller ut den (skrivebeskyttet) <xref:System.Diagnostics.Process.MainModule%2A>egenskapen.</xref:System.Diagnostics.Process.MainModule%2A> Hvis du vil hente den kjørbare filen som er knyttet til prosessen når prosessen er startet, kan du bruke den <xref:System.Diagnostics.Process.MainModule%2A>egenskapen.</xref:System.Diagnostics.Process.MainModule%2A> Hvis du vil angi den kjørbare filen for en <xref:System.Diagnostics.Process>serverforekomsten for som en tilknyttet prosess har ikke blitt startet ved å bruke egenskapen StartInfo <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>medlem.</xref:System.Diagnostics.ProcessStartInfo.FileName%2A> </xref:System.Diagnostics.Process> Fordi medlemmene i egenskapen StartInfo argumenter som sendes til den <xref:System.Diagnostics.Process.Start%2A>metoden for en prosess, endring av <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>egenskapen etter den tilknyttede prosessen har startet ikke tilbakestiller den <xref:System.Diagnostics.Process.MainModule%2A>egenskapen.</xref:System.Diagnostics.Process.MainModule%2A> </xref:System.Diagnostics.ProcessStartInfo.FileName%2A> </xref:System.Diagnostics.Process.Start%2A> Disse egenskapene brukes bare til å initialisere den tilknyttede prosessen."
  example:
  - "The following example populates a StartInfo with the file to execute, the action performed on it and whether it should displays a user interface. For additional examples, refer to the reference pages for properties of the <xref:System.Diagnostics.ProcessStartInfo> class.  \n  \n [!code-cpp[Process.Start_instance#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_10_1.cpp)]\n [!code-vb[Process.Start_instance#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_10_1.vb)]\n [!code-cs[Process.Start_instance#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_10_1.cs)]"
  syntax:
    content: public System.Diagnostics.ProcessStartInfo StartInfo { get; set; }
    return:
      type: System.Diagnostics.ProcessStartInfo
      description: "Den <xref href=&quot;System.Diagnostics.ProcessStartInfo&quot;> </xref> som representerer data som skal starte prosessen med. Disse argumentene inkluderer navnet på den kjørbare filen eller dokumentet brukes til å starte prosessen."
  overload: System.Diagnostics.Process.StartInfo*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "Verdien som angir StartInfo <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  platform:
  - net462
- uid: System.Diagnostics.Process.StartTime
  id: StartTime
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: StartTime
  nameWithType: Process.StartTime
  fullName: System.Diagnostics.Process.StartTime
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Henter klokkeslettet da den tilknyttede prosessen ble startet."
  syntax:
    content: public DateTime StartTime { get; }
    return:
      type: System.DateTime
      description: "Et objekt som angir når prosessen er startet. Et unntak hvis prosessen ikke kjører."
  overload: System.Diagnostics.Process.StartTime*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Plattformen er Windows 98 eller installasjonen (Windows Me), som ikke støtter denne egenskapen."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Du prøver å åpne starttid-egenskapen for en prosess som kjører på en ekstern datamaskin. Denne egenskapen er bare tilgjengelig for prosessene som kjører på den lokale datamaskinen."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Prosessen ble avsluttet.       - eller - prosessen har ikke blitt startet."
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Det oppstod en feil i kallet til funksjonen Windows."
  platform:
  - net462
- uid: System.Diagnostics.Process.SynchronizingObject
  id: SynchronizingObject
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: SynchronizingObject
  nameWithType: Process.SynchronizingObject
  fullName: System.Diagnostics.Process.SynchronizingObject
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Henter eller angir objektet som ble brukt til å formidle kall til hendelsesbehandling som er utstedt som et resultat av en prosess avsluttes hendelse."
  remarks: "Når <xref:System.Diagnostics.EventLog.SynchronizingObject%2A>er `null`, metoder som behandler den <xref:System.Diagnostics.Process.Exited>hendelsen kalles på en tråd fra systemet thread pool.</xref:System.Diagnostics.Process.Exited> </xref:System.Diagnostics.EventLog.SynchronizingObject%2A> Hvis du vil ha mer informasjon om system tråd applikasjonsutvalg, kan du se <xref:System.Threading.ThreadPool>.</xref:System.Threading.ThreadPool>       Når den <xref:System.Diagnostics.Process.Exited>hendelsen behandles av en visual Windows Forms-komponent, for eksempel en <xref:System.Windows.Forms.Button>, tilgang til komponenten via system thread pool fungerer kanskje ikke eller kan resultere i et unntak.</xref:System.Windows.Forms.Button> </xref:System.Diagnostics.Process.Exited> Unngå dette ved å sette SynchronizingObject til en Windows Forms-komponent, som fører til at metodene behandling av <xref:System.Diagnostics.Process.Exited>hendelsen skal kalles på samme tråd som komponenten ble opprettet.</xref:System.Diagnostics.Process.Exited>       Hvis den <xref:System.Diagnostics.Process>brukes i [!INCLUDE[vsprvslong](~/add/includes/ajax-current-ext-md.md)] Windows Forms-utforming SynchronizingObject er automatisk satt til kontrollen som inneholder <xref:System.Diagnostics.Process>.</xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process> Hvis du setter for eksempel en <xref:System.Diagnostics.Process>på en utformer for `Form1` (som arver fra <xref:System.Windows.Forms.Form>) SynchronizingObject-egenskapen for <xref:System.Diagnostics.Process>er satt til forekomsten av `Form1`: [!code-cpp [Process_SynchronizingObject&2;](~/add/codesnippet/cpp/p-system.diagnostics.pro_35_1.cpp)][!code-cs[Process_SynchronizingObject&2;](~/add/codesnippet/csharp/p-system.diagnostics.pro_35_1.cs)][!code-vb[Process_SynchronizingObject&2;](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_35_1.vb) ] vanligvis denne egenskapen er angitt når komponenten er plassert inne i en kontroll eller skjemaet, fordi komponentene som er bundet til en bestemt tråd.    </xref:System.Diagnostics.Process> </xref:System.Windows.Forms.Form> </xref:System.Diagnostics.Process>"
  example:
  - >-
    [!code-vb[Process_SynchronizingObject#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_35_2.vb)]
     [!code-cpp[Process_SynchronizingObject#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_35_2.cpp)]
     [!code-cs[Process_SynchronizingObject#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_35_2.cs)]
  syntax:
    content: public System.ComponentModel.ISynchronizeInvoke SynchronizingObject { get; set; }
    return:
      type: System.ComponentModel.ISynchronizeInvoke
      description: "Den <xref href=&quot;System.ComponentModel.ISynchronizeInvoke&quot;> </xref> brukt til å formidle kall til hendelsesbehandling som er utstedt som et resultat av en <xref href=&quot;System.Diagnostics.Process.Exited&quot;> </xref> hendelse på prosessen."
  overload: System.Diagnostics.Process.SynchronizingObject*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.Process.Threads
  id: Threads
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: Threads
  nameWithType: Process.Threads
  fullName: System.Diagnostics.Process.Threads
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Henter antall tråder som kjører i den tilknyttede prosessen."
  remarks: "En tråd utfører kode i en prosess. Hver prosess er startet med én tråd, primære tråder. En tråd kan opprette flere tråder. Tråder i en prosess deler adresseområde av prosessen.       Bruk <xref:System.Diagnostics.ProcessThread>å hente alle tråder som er knyttet til gjeldende prosessen.</xref:System.Diagnostics.ProcessThread> Den primære tråden er ikke nødvendigvis ved indeks null i matrisen."
  syntax:
    content: public System.Diagnostics.ProcessThreadCollection Threads { get; }
    return:
      type: System.Diagnostics.ProcessThreadCollection
      description: "En matrise av typen <xref href=&quot;System.Diagnostics.ProcessThread&quot;> </xref> som representerer operativsystemet tråder for øyeblikket kjører i den tilknyttede prosessen."
  overload: System.Diagnostics.Process.Threads*
  exceptions:
  - type: System.SystemException
    commentId: T:System.SystemException
    description: "Prosessen har ikke en <xref:System.Diagnostics.Process.Id*>, eller ingen prosess er knyttet til den <xref href=&quot;System.Diagnostics.Process&quot;> </xref> forekomsten.</xref:System.Diagnostics.Process.Id*>       - eller - den tilknyttede prosessen ble avsluttet."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Plattformen er Windows 98 eller installasjonen (Windows Me); Angi &lt;xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName&gt; til <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> å få tilgang til denne egenskapen i Windows 98 og Windows."
  platform:
  - net462
- uid: System.Diagnostics.Process.ToString
  id: ToString
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: ToString()
  nameWithType: Process.ToString()
  fullName: System.Diagnostics.Process.ToString()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Formaterer det prosessnavnet som en streng, kombinert med Komponenttype overordnede om nødvendig."
  remarks: ''
  example:
  - "The following example starts an instance of Notepad. The example then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays the process's exit code.  \n  \n [!code-cpp[Diag_Process_MemoryProperties64#1](~/add/codesnippet/cpp/m-system.diagnostics.pro_12_1.cpp)]\n [!code-cs[Diag_Process_MemoryProperties64#1](~/add/codesnippet/csharp/m-system.diagnostics.pro_12_1.cs)]\n [!code-vb[Diag_Process_MemoryProperties64#1](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_12_1.vb)]"
  syntax:
    content: public override string ToString ();
    parameters: []
    return:
      type: System.String
      description: "Den <> </> *>, kombinert med grunntallet komponentens <> </> *> returverdi."
  overload: System.Diagnostics.Process.ToString*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "ToString støttes ikke på Windows 98."
  platform:
  - net462
- uid: System.Diagnostics.Process.TotalProcessorTime
  id: TotalProcessorTime
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: TotalProcessorTime
  nameWithType: Process.TotalProcessorTime
  fullName: System.Diagnostics.Process.TotalProcessorTime
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Henter den totale tiden for prosessoren for denne prosessen."
  remarks: ''
  example:
  - "The following example starts an instance of Notepad. The example then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays the process's exit code.  \n  \n [!code-cpp[Diag_Process_MemoryProperties64#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_15_1.cpp)]\n [!code-cs[Diag_Process_MemoryProperties64#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_15_1.cs)]\n [!code-vb[Diag_Process_MemoryProperties64#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_15_1.vb)]"
  syntax:
    content: public TimeSpan TotalProcessorTime { get; }
    return:
      type: System.TimeSpan
      description: "En <xref:System.TimeSpan>som angir hvor lang tid at den tilknyttede prosessen har brukt bruk av CPU.</xref:System.TimeSpan> Denne verdien er summen av den <> </> *> og <> </> *>."
  overload: System.Diagnostics.Process.TotalProcessorTime*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Plattformen er Windows 98 eller installasjonen (Windows Me), som ikke støtter denne egenskapen."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Du prøver å få tilgang til egenskapen TotalProcessorTime for en prosess som kjører på en ekstern datamaskin. Denne egenskapen er bare tilgjengelig for prosessene som kjører på den lokale datamaskinen."
  platform:
  - net462
- uid: System.Diagnostics.Process.UserProcessorTime
  id: UserProcessorTime
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: UserProcessorTime
  nameWithType: Process.UserProcessorTime
  fullName: System.Diagnostics.Process.UserProcessorTime
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Henter bruker prosessortid for denne prosessen."
  remarks: ''
  example:
  - "The following example starts an instance of Notepad. The example then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays the process's exit code.  \n  \n [!code-cpp[Diag_Process_MemoryProperties64#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_21_1.cpp)]\n [!code-cs[Diag_Process_MemoryProperties64#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_21_1.cs)]\n [!code-vb[Diag_Process_MemoryProperties64#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_21_1.vb)]"
  syntax:
    content: public TimeSpan UserProcessorTime { get; }
    return:
      type: System.TimeSpan
      description: "En <xref:System.TimeSpan>som angir hvor lang tid at den tilknyttede prosessen har brukt kjører koden i programmet del av prosessen (ikke i operativsystemet core).</xref:System.TimeSpan>"
  overload: System.Diagnostics.Process.UserProcessorTime*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Plattformen er Windows 98 eller installasjonen (Windows Me), som ikke støtter denne egenskapen."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Du prøver å få tilgang til egenskapen UserProcessorTime for en prosess som kjører på en ekstern datamaskin. Denne egenskapen er bare tilgjengelig for prosessene som kjører på den lokale datamaskinen."
  platform:
  - net462
- uid: System.Diagnostics.Process.VirtualMemorySize
  id: VirtualMemorySize
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: VirtualMemorySize
  nameWithType: Process.VirtualMemorySize
  fullName: System.Diagnostics.Process.VirtualMemorySize
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Henter størrelsen på prosessens virtuelt minne, i byte."
  syntax:
    content: public int VirtualMemorySize { get; }
    return:
      type: System.Int32
      description: "Mengden av virtuelt minne, i byte, som er forespurt for den tilknyttede prosessen."
  overload: System.Diagnostics.Process.VirtualMemorySize*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Plattformen er Windows 98 eller installasjonen (Windows Me), som ikke støtter denne egenskapen."
  platform:
  - net462
- uid: System.Diagnostics.Process.VirtualMemorySize64
  id: VirtualMemorySize64
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: VirtualMemorySize64
  nameWithType: Process.VirtualMemorySize64
  fullName: System.Diagnostics.Process.VirtualMemorySize64
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Henter mengde virtuelt minne, i byte tildelt for den tilknyttede prosessen."
  remarks: "Verdien som returneres av denne egenskapen representerer gjeldende størrelse på det virtuelle minnet som brukes av prosessen, i byte. Operativsystemet tilordner virtuelt adresseområde for hver prosess enten til sider lastes inn i minnet, eller til sider som er lagret i virtuelt minne Bla filen på disken.       Denne egenskapen kan brukes til å overvåke minnebruk på datamaskiner med prosessorer 32-biters eller 64-biters prosessorer. Egenskapsverdien tilsvarer den **virtuelle byte** ytelsesteller for prosessen."
  example:
  - "The following code example starts an instance of the Notepad application. The example then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays its exit code and peak memory statistics.  \n  \n [!code-cpp[Diag_Process_MemoryProperties64#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_13_1.cpp)]\n [!code-cs[Diag_Process_MemoryProperties64#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_13_1.cs)]\n [!code-vb[Diag_Process_MemoryProperties64#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_13_1.vb)]"
  syntax:
    content: public long VirtualMemorySize64 { get; }
    return:
      type: System.Int64
      description: "Mengden av virtuelt minne, i byte tildelt for den tilknyttede prosessen."
  overload: System.Diagnostics.Process.VirtualMemorySize64*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Plattformen er Windows 98 eller installasjonen (Windows Me), som ikke støtter denne egenskapen."
  platform:
  - net462
- uid: System.Diagnostics.Process.WaitForExit
  id: WaitForExit
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: WaitForExit()
  nameWithType: Process.WaitForExit()
  fullName: System.Diagnostics.Process.WaitForExit()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Angir at det <xref href=&quot;System.Diagnostics.Process&quot;> </xref> komponent som skal vente på ubestemt tid for den tilknyttede prosessen å avslutte."
  remarks: "WaitForExit gjør gjeldende tråd vente til den tilknyttede prosessen avslutter.  Det må kalles etter alle andre metoder kalles på prosessen. Du kan unngå blokkerer gjeldende tråd ved bruk av <xref:System.Diagnostics.Process.Exited>hendelsen.</xref:System.Diagnostics.Process.Exited>       Denne metoden instruerer den <xref:System.Diagnostics.Process>komponenten Vent en uendelig tid for prosessen og hendelsen referanser å avslutte.</xref:System.Diagnostics.Process> Dette kan føre til en applikasjon som ikke svarer. Hvis du kaller for eksempel <xref:System.Diagnostics.Process.CloseMainWindow%2A>for en prosess som har et brukergrensesnitt forespørselen til operativsystemet tilknyttede prosessen må avsluttes kan ikke behandles hvis prosessen er skrevet inn aldri den meldingen sløyfen.</xref:System.Diagnostics.Process.CloseMainWindow%2A>      > [!NOTE] > I den [!INCLUDE[net_v35_long](~/add/includes/ajax-current-ext-md.md)] og tidligere versjoner WaitForExit overlasten ventet <xref:System.Int32.MaxValue>millisekunder (ca. 24 dager) ikke på ubestemt tid.</xref:System.Int32.MaxValue> Også tidligere versjoner venter ikke hendelsesbehandlingen til å avslutte hvis hele <xref:System.Int32.MaxValue>tid er nådd.</xref:System.Int32.MaxValue>       Denne overlasten sikrer at alle behandling er ferdig, inkludert behandling av asynkron hendelser for omadresserte standard utdata. Du må bruke denne overlasten etter et kall til den <xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29>overbelaste når standard utdata er omadressert til asynkrone hendelsesbehandling.</xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29>       Når en tilknyttede prosessen avslutter (det vil si når den er avsluttet av operativsystem gjennom en vanlig eller unormal avslutning), lagrer administrative informasjon om prosessen i systemet, og returnerer til komponenten som hadde kalles WaitForExit. Den <xref:System.Diagnostics.Process>komponent får da tilgang informasjonen, som inneholder den <xref:System.Diagnostics.Process.ExitTime%2A>, ved hjelp av den <xref:System.Diagnostics.Process.Handle%2A>for exited prosessen.</xref:System.Diagnostics.Process.Handle%2A> </xref:System.Diagnostics.Process.ExitTime%2A> </xref:System.Diagnostics.Process>       Fordi den tilknyttede prosessen ble avsluttet, den <xref:System.Diagnostics.Process.Handle%2A>egenskap for komponenten lenger peker til en eksisterende prosess-ressurs.</xref:System.Diagnostics.Process.Handle%2A> I stedet kan håndtaket brukes bare for å få tilgang til den operativsystemet informasjon om ressursen prosessen. Systemet er klar over referanser til avsluttet prosesser som ikke er utgitt av <xref:System.Diagnostics.Process>komponenter, slik at den beholder den <xref:System.Diagnostics.Process.ExitTime%2A>og <xref:System.Diagnostics.Process.Handle%2A>informasjonen i minnet før den <xref:System.Diagnostics.Process>komponent spesielt frigjør ressursene.</xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.Handle%2A> </xref:System.Diagnostics.Process.ExitTime%2A> </xref:System.Diagnostics.Process> Derfor hver gang du kaller <xref:System.Diagnostics.Process.Start%2A>for en <xref:System.Diagnostics.Process>forekomst, <xref:System.Diagnostics.Process.Close%2A>når den tilknyttede prosessen ble avsluttet, og du ikke lenger trenger administrative informasjon om det.</xref:System.Diagnostics.Process.Close%2A> </xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.Start%2A> <xref:System.Diagnostics.Process.Close%2A>Frigjør minnet tilordnet exited prosessen.</xref:System.Diagnostics.Process.Close%2A>"
  example:
  - See the Remarks section of the <xref:System.Diagnostics.Process.StandardError%2A> property reference page.
  syntax:
    content: public void WaitForExit ();
    parameters: []
  overload: System.Diagnostics.Process.WaitForExit*
  exceptions:
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Vent innstillingen kan ikke åpnes."
  - type: System.SystemException
    commentId: T:System.SystemException
    description: "Ingen prosess <> </> *> er angitt, og en <> </> *> som den <xref:System.Diagnostics.Process.Id*>egenskapen fastslås ikke finnes.</xref:System.Diagnostics.Process.Id*>       - eller - det er ingen prosess som er knyttet til dette <xref href=&quot;System.Diagnostics.Process&quot;> </xref> objektet.       - eller - du prøver å kalle WaitForExit for en prosess som kjører på en ekstern datamaskin. Denne metoden er bare tilgjengelig for prosessene som kjører på den lokale datamaskinen."
  platform:
  - net462
- uid: System.Diagnostics.Process.WaitForExit(System.Int32)
  id: WaitForExit(System.Int32)
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: WaitForExit(Int32)
  nameWithType: Process.WaitForExit(Int32)
  fullName: System.Diagnostics.Process.WaitForExit(Int32)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Angir at det <xref href=&quot;System.Diagnostics.Process&quot;> </xref> komponent vente det angitte antallet millisekunder for den tilknyttede prosessen å avslutte."
  remarks: "WaitForExit gjør gjeldende tråd vente til den tilknyttede prosessen avslutter. Det må kalles etter alle andre metoder kalles på prosessen. Du kan unngå blokkerer gjeldende tråd ved bruk av <xref:System.Diagnostics.Process.Exited>hendelsen.</xref:System.Diagnostics.Process.Exited>       Denne metoden instruerer den <xref:System.Diagnostics.Process>komponent vente et begrenset tidsrom å avslutte prosessen.</xref:System.Diagnostics.Process> Hvis den tilknyttede prosessen ikke finnes i løpet av intervallet fordi forespørsel om å avslutte avslås, `false` returneres til kalle prosedyren. Du kan angi et negativt tall (<xref:System.Threading.Timeout.Infinite>) for `milliseconds`, og WaitForExit fungerer det samme som den <xref:System.Diagnostics.Process.WaitForExit>overbelaste.</xref:System.Diagnostics.Process.WaitForExit> </xref:System.Threading.Timeout.Infinite> Hvis du sender 0 (null) metoden, returneres `true` Hvis prosessen er allerede avsluttet; ellers umiddelbart returneres `false`.      > [!NOTE] > I den [!INCLUDE[net_v35_long](~/add/includes/ajax-current-ext-md.md)] og tidligere versjoner Hvis `milliseconds` er -1, WaitForExit overbelastning ventet for <xref:System.Int32.MaxValue>millisekunder (ca. 24 dager) ikke på ubestemt tid.</xref:System.Int32.MaxValue>       Når standard utdata er omadressert til asynkrone hendelsesbehandling, er det mulig at output-behandling ikke vil har fullført låse denne metoden. For å sikre at asynkrone hendelseshåndtering er fullført, kan du kalle den <xref:System.Diagnostics.Process.WaitForExit>overbelastningen som tar ingen parameter etter mottak en `true` fra denne overlasten.</xref:System.Diagnostics.Process.WaitForExit> For å sikre at den <xref:System.Diagnostics.Process.Exited>hendelsen behandles på riktig måte i Windows Forms-programmer, angitt i <xref:System.Diagnostics.Process.SynchronizingObject%2A>egenskapen.</xref:System.Diagnostics.Process.SynchronizingObject%2A> </xref:System.Diagnostics.Process.Exited>       Når en tilknyttede prosessen avslutter (avsluttes av operativsystemet gjennom en vanlig eller unormal avslutning), systemet lagrer administrative informasjon om prosessen, og returnerer til komponenten som hadde kalles WaitForExit. Den <xref:System.Diagnostics.Process>komponent får da tilgang informasjonen, som inneholder den <xref:System.Diagnostics.Process.ExitTime%2A>, ved hjelp av den <xref:System.Diagnostics.Process.Handle%2A>for exited prosessen.</xref:System.Diagnostics.Process.Handle%2A> </xref:System.Diagnostics.Process.ExitTime%2A> </xref:System.Diagnostics.Process>       Fordi den tilknyttede prosessen ble avsluttet, den <xref:System.Diagnostics.Process.Handle%2A>egenskap for komponenten lenger peker til en eksisterende prosess-ressurs.</xref:System.Diagnostics.Process.Handle%2A> I stedet kan håndtaket brukes bare for å få tilgang til den operativsystemet informasjon om ressursen prosessen. Systemet er klar over referanser til avsluttet prosesser som ikke er utgitt av <xref:System.Diagnostics.Process>komponenter, slik at den beholder den <xref:System.Diagnostics.Process.ExitTime%2A>og <xref:System.Diagnostics.Process.Handle%2A>informasjonen i minnet før den <xref:System.Diagnostics.Process>komponent spesielt frigjør ressursene.</xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.Handle%2A> </xref:System.Diagnostics.Process.ExitTime%2A> </xref:System.Diagnostics.Process> Derfor hver gang du kaller <xref:System.Diagnostics.Process.Start%2A>for en <xref:System.Diagnostics.Process>forekomst, <xref:System.Diagnostics.Process.Close%2A>når den tilknyttede prosessen ble avsluttet, og du ikke lenger trenger administrative informasjon om det.</xref:System.Diagnostics.Process.Close%2A> </xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.Start%2A> <xref:System.Diagnostics.Process.Close%2A>Frigjør minnet tilordnet exited prosessen.</xref:System.Diagnostics.Process.Close%2A>"
  example:
  - See the code example for the <xref:System.Diagnostics.Process.ExitCode%2A> property.
  syntax:
    content: public bool WaitForExit (int milliseconds);
    parameters:
    - id: milliseconds
      type: System.Int32
      description: "Hvor lang tid i millisekunder ventetid for den tilknyttede prosessen å avslutte. Maksimal er den største tillatte verdien av et 32-biters heltall som representerer uendelig for operativsystemet."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Hvis den tilknyttede prosessen ble avsluttet; Ellers <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Diagnostics.Process.WaitForExit*
  exceptions:
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Vent innstillingen kan ikke åpnes."
  - type: System.SystemException
    commentId: T:System.SystemException
    description: "Ingen prosess <> </> *> er angitt, og en <> </> *> som den <xref:System.Diagnostics.Process.Id*>egenskapen fastslås ikke finnes.</xref:System.Diagnostics.Process.Id*>       - eller - det er ingen prosess som er knyttet til dette <xref href=&quot;System.Diagnostics.Process&quot;> </xref> objektet.       - eller - du prøver å kalle WaitForExit for en prosess som kjører på en ekstern datamaskin. Denne metoden er bare tilgjengelig for prosessene som kjører på den lokale datamaskinen."
  platform:
  - net462
- uid: System.Diagnostics.Process.WaitForInputIdle
  id: WaitForInputIdle
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: WaitForInputIdle()
  nameWithType: Process.WaitForInputIdle()
  fullName: System.Diagnostics.Process.WaitForInputIdle()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Gjør den <xref href=&quot;System.Diagnostics.Process&quot;> </xref> komponent som skal vente på ubestemt tid for den tilknyttede prosessen til å angi en inaktiv tilstand. Denne overlasten gjelder bare for prosesser med et brukergrensesnitt, og derfor en sløyfe i meldingen."
  remarks: "Bruk WaitForInputIdle tvinge behandlingen av programmet vente til meldingen sløyfen har returnert til en inaktiv tilstand. Når en prosess med et brukergrensesnitt kjøres, kjører den meldingen sløyfen hver gang en Windows-melding er sendt til prosessen av operativsystemet. Prosessen returnerer til sløyfen meldingen. En prosess sies å være inaktiv når venter meldinger inne i en sløyfe i meldingen. Denne statusen er nyttig, for eksempel når programmet må vente et Start prosessen ferdig med å opprette hovedvinduet før programmet kommuniserer med det vinduet.       Hvis en prosess ikke har en sløyfe i meldingen, oppstår WaitForInputIdle en <xref:System.InvalidOperationException>.</xref:System.InvalidOperationException>       WaitForInputIdle overlasten instruerer den <xref:System.Diagnostics.Process>komponent som skal vente på ubestemt tid til prosessen skal bli inaktiv i meldingen sløyfen.</xref:System.Diagnostics.Process> Denne instruksjon kan føre til en applikasjon som ikke svarer. For eksempel hvis prosessen skrives til alltid avslutte den meldingen sløyfen umiddelbart, som i koden fragmentet `while(true)`."
  syntax:
    content: public bool WaitForInputIdle ();
    parameters: []
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Hvis den tilknyttede prosessen har nådd en inaktiv tilstand."
  overload: System.Diagnostics.Process.WaitForInputIdle*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Prosessen har ikke et grafisk grensesnitt.       - eller - det oppstod en ukjent feil. Prosessen kan ikke angi en inaktiv tilstand.       - eller - prosessen allerede er avsluttet.       - eller - ingen prosess er knyttet til dette <xref href=&quot;System.Diagnostics.Process&quot;> </xref> objektet."
  platform:
  - net462
- uid: System.Diagnostics.Process.WaitForInputIdle(System.Int32)
  id: WaitForInputIdle(System.Int32)
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: WaitForInputIdle(Int32)
  nameWithType: Process.WaitForInputIdle(Int32)
  fullName: System.Diagnostics.Process.WaitForInputIdle(Int32)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Gjør den <xref href=&quot;System.Diagnostics.Process&quot;> </xref> komponent vente det angitte antallet millisekunder for den tilknyttede prosessen til å angi en inaktiv tilstand. Denne overlasten gjelder bare for prosesser med et brukergrensesnitt, og derfor en sløyfe i meldingen."
  remarks: "Bruk WaitForInputIdle tvinge behandlingen av programmet vente til meldingen sløyfen har returnert til en inaktiv tilstand. Når en prosess med et brukergrensesnitt kjøres, kjører den meldingen sløyfen hver gang en Windows-melding er sendt til prosessen av operativsystemet. Prosessen returnerer til sløyfen meldingen. En prosess sies å være inaktiv når venter meldinger inne i en sløyfe i meldingen. Denne statusen er nyttig, for eksempel når programmet må vente et Start prosessen ferdig med å opprette hovedvinduet før programmet kommuniserer med det vinduet.       Hvis en prosess ikke har en sløyfe i meldingen, oppstår WaitForInputIdle en <xref:System.InvalidOperationException>.</xref:System.InvalidOperationException>       WaitForInputIdle overlasten instruerer den <xref:System.Diagnostics.Process>komponent vente et begrenset tidsrom for prosessen skal bli inaktiv i meldingen sløyfen.</xref:System.Diagnostics.Process> Hvis den tilknyttede prosessen ikke har blir inaktiv i løpet av intervallet fordi sløyfen fortsatt behandler meldinger, `false` returneres til kalle prosedyren.       Du finner mer informasjon om behandling av hendelser [hendelser](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public bool WaitForInputIdle (int milliseconds);
    parameters:
    - id: milliseconds
      type: System.Int32
      description: "En verdi på 1 <xref:System.Int32>som angir hvor lang tid, i millisekunder ventetid for den tilknyttede prosessen blir inaktive.</xref:System.Int32> Verdien 0 angir en umiddelbar retur, og verdien -1 angir en uendelig ventetid."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Hvis den tilknyttede prosessen har nådd inaktiv; Ellers <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Diagnostics.Process.WaitForInputIdle*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Prosessen har ikke et grafisk grensesnitt.       - eller - det oppstod en ukjent feil. Prosessen kan ikke angi en inaktiv tilstand.       - eller - prosessen allerede er avsluttet.       - eller - ingen prosess er knyttet til dette <xref href=&quot;System.Diagnostics.Process&quot;> </xref> objektet."
  platform:
  - net462
- uid: System.Diagnostics.Process.WorkingSet
  id: WorkingSet
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: WorkingSet
  nameWithType: Process.WorkingSet
  fullName: System.Diagnostics.Process.WorkingSet
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Henter den tilknyttede prosessen fysisk minnebruk, i byte."
  remarks: "Verdien som returneres av denne egenskapen representerer gjeldende størrelse på arbeid Sett minnet som brukes av prosessen, i byte. En prosess arbeidssett er settet med minnesider som er synlig for prosessen i minnet RAM. Disse sidene er faste og tilgjengelig for et program uten utløser en sidefeil.       Arbeidssett inkluderer både delt og private data. De delte dataene inneholder sider som inneholder alle instruksjonene som prosessen utfører, inkludert prosess-moduler og system-biblioteker."
  example:
  - "The following example starts an instance of Notepad. The example then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays the process' exit code.  \n  \n [!code-vb[process_sample#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_40_1.vb)]\n [!code-cpp[process_sample#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_40_1.cpp)]\n [!code-cs[process_sample#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_40_1.cs)]"
  syntax:
    content: public int WorkingSet { get; }
    return:
      type: System.Int32
      description: "Den totale mengden fysisk minne tilknyttede prosessen bruker, i byte."
  overload: System.Diagnostics.Process.WorkingSet*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Plattformen er Windows 98 eller installasjonen (Windows Me), som ikke støtter denne egenskapen."
  platform:
  - net462
- uid: System.Diagnostics.Process.WorkingSet64
  id: WorkingSet64
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: WorkingSet64
  nameWithType: Process.WorkingSet64
  fullName: System.Diagnostics.Process.WorkingSet64
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Henter mengden fysisk minne, i byte tildelt for den tilknyttede prosessen."
  remarks: "Verdien som returneres av denne egenskapen representerer gjeldende størrelse på arbeid Sett minnet som brukes av prosessen, i byte. En prosess arbeidssett er settet med minnesider som er synlig for prosessen i minnet RAM. Disse sidene er faste og tilgjengelig for et program uten utløser en sidefeil.       Arbeidssett inkluderer både delt og private data. De delte dataene inneholder sider som inneholder alle instruksjonene som prosessen utfører, inkludert instruksjoner i prosess-moduler og system-biblioteker.       Denne egenskapen kan brukes til å overvåke minnebruk på datamaskiner med prosessorer 32-biters eller 64-biters prosessorer. Egenskapsverdien tilsvarer den **arbeidssett** ytelsesteller for prosessen."
  example:
  - "The following code example starts an instance of the Notepad application. The example then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays its exit code and peak memory statistics.  \n  \n [!code-cpp[Diag_Process_MemoryProperties64#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_32_1.cpp)]\n [!code-cs[Diag_Process_MemoryProperties64#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_32_1.cs)]\n [!code-vb[Diag_Process_MemoryProperties64#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_32_1.vb)]"
  syntax:
    content: public long WorkingSet64 { get; }
    return:
      type: System.Int64
      description: "Mengden av fysisk minne, i byte tildelt for den tilknyttede prosessen."
  overload: System.Diagnostics.Process.WorkingSet64*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Plattformen er Windows 98 eller installasjonen (Windows Me), som ikke støtter denne egenskapen."
  platform:
  - net462
references:
- uid: System.ComponentModel.Component
  isExternal: false
  name: System.ComponentModel.Component
- uid: System.PlatformNotSupportedException
  isExternal: true
  name: System.PlatformNotSupportedException
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.NotSupportedException
  isExternal: true
  name: System.NotSupportedException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.ComponentModel.Win32Exception
  parent: System.ComponentModel
  isExternal: false
  name: Win32Exception
  nameWithType: Win32Exception
  fullName: System.ComponentModel.Win32Exception
- uid: System.ComponentModel.InvalidEnumArgumentException
  parent: System.ComponentModel
  isExternal: false
  name: InvalidEnumArgumentException
  nameWithType: InvalidEnumArgumentException
  fullName: System.ComponentModel.InvalidEnumArgumentException
- uid: System.NullReferenceException
  isExternal: true
  name: System.NullReferenceException
- uid: System.ObjectDisposedException
  isExternal: true
  name: System.ObjectDisposedException
- uid: System.IO.FileNotFoundException
  isExternal: true
  name: System.IO.FileNotFoundException
- uid: System.SystemException
  parent: System
  isExternal: false
  name: SystemException
  nameWithType: SystemException
  fullName: System.SystemException
- uid: System.Diagnostics.Process.#ctor
  parent: System.Diagnostics.Process
  isExternal: false
  name: Process()
  nameWithType: Process.Process()
  fullName: System.Diagnostics.Process.Process()
- uid: System.Diagnostics.Process.BasePriority
  parent: System.Diagnostics.Process
  isExternal: false
  name: BasePriority
  nameWithType: Process.BasePriority
  fullName: System.Diagnostics.Process.BasePriority
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.Diagnostics.Process.BeginErrorReadLine
  parent: System.Diagnostics.Process
  isExternal: false
  name: BeginErrorReadLine()
  nameWithType: Process.BeginErrorReadLine()
  fullName: System.Diagnostics.Process.BeginErrorReadLine()
- uid: System.Diagnostics.Process.BeginOutputReadLine
  parent: System.Diagnostics.Process
  isExternal: false
  name: BeginOutputReadLine()
  nameWithType: Process.BeginOutputReadLine()
  fullName: System.Diagnostics.Process.BeginOutputReadLine()
- uid: System.Diagnostics.Process.CancelErrorRead
  parent: System.Diagnostics.Process
  isExternal: false
  name: CancelErrorRead()
  nameWithType: Process.CancelErrorRead()
  fullName: System.Diagnostics.Process.CancelErrorRead()
- uid: System.Diagnostics.Process.CancelOutputRead
  parent: System.Diagnostics.Process
  isExternal: false
  name: CancelOutputRead()
  nameWithType: Process.CancelOutputRead()
  fullName: System.Diagnostics.Process.CancelOutputRead()
- uid: System.Diagnostics.Process.Close
  parent: System.Diagnostics.Process
  isExternal: false
  name: Close()
  nameWithType: Process.Close()
  fullName: System.Diagnostics.Process.Close()
- uid: System.Diagnostics.Process.CloseMainWindow
  parent: System.Diagnostics.Process
  isExternal: false
  name: CloseMainWindow()
  nameWithType: Process.CloseMainWindow()
  fullName: System.Diagnostics.Process.CloseMainWindow()
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Diagnostics.Process.Dispose(System.Boolean)
  parent: System.Diagnostics.Process
  isExternal: false
  name: Dispose(Boolean)
  nameWithType: Process.Dispose(Boolean)
  fullName: System.Diagnostics.Process.Dispose(Boolean)
- uid: System.Diagnostics.Process.EnableRaisingEvents
  parent: System.Diagnostics.Process
  isExternal: false
  name: EnableRaisingEvents
  nameWithType: Process.EnableRaisingEvents
  fullName: System.Diagnostics.Process.EnableRaisingEvents
- uid: System.Diagnostics.Process.EnterDebugMode
  parent: System.Diagnostics.Process
  isExternal: false
  name: EnterDebugMode()
  nameWithType: Process.EnterDebugMode()
  fullName: System.Diagnostics.Process.EnterDebugMode()
- uid: System.Diagnostics.Process.ErrorDataReceived
  parent: System.Diagnostics.Process
  isExternal: false
  name: ErrorDataReceived
  nameWithType: Process.ErrorDataReceived
  fullName: System.Diagnostics.Process.ErrorDataReceived
- uid: System.Diagnostics.DataReceivedEventHandler
  parent: System.Diagnostics
  isExternal: false
  name: DataReceivedEventHandler
  nameWithType: DataReceivedEventHandler
  fullName: System.Diagnostics.DataReceivedEventHandler
- uid: System.Diagnostics.Process.ExitCode
  parent: System.Diagnostics.Process
  isExternal: false
  name: ExitCode
  nameWithType: Process.ExitCode
  fullName: System.Diagnostics.Process.ExitCode
- uid: System.Diagnostics.Process.Exited
  parent: System.Diagnostics.Process
  isExternal: false
  name: Exited
  nameWithType: Process.Exited
  fullName: System.Diagnostics.Process.Exited
- uid: System.EventHandler
  parent: System
  isExternal: true
  name: EventHandler
  nameWithType: EventHandler
  fullName: System.EventHandler
- uid: System.Diagnostics.Process.ExitTime
  parent: System.Diagnostics.Process
  isExternal: false
  name: ExitTime
  nameWithType: Process.ExitTime
  fullName: System.Diagnostics.Process.ExitTime
- uid: System.DateTime
  parent: System
  isExternal: true
  name: DateTime
  nameWithType: DateTime
  fullName: System.DateTime
- uid: System.Diagnostics.Process.GetCurrentProcess
  parent: System.Diagnostics.Process
  isExternal: false
  name: GetCurrentProcess()
  nameWithType: Process.GetCurrentProcess()
  fullName: System.Diagnostics.Process.GetCurrentProcess()
- uid: System.Diagnostics.Process
  parent: System.Diagnostics
  isExternal: false
  name: Process
  nameWithType: Process
  fullName: System.Diagnostics.Process
- uid: System.Diagnostics.Process.GetProcessById(System.Int32)
  parent: System.Diagnostics.Process
  isExternal: false
  name: GetProcessById(Int32)
  nameWithType: Process.GetProcessById(Int32)
  fullName: System.Diagnostics.Process.GetProcessById(Int32)
- uid: System.Diagnostics.Process.GetProcessById(System.Int32,System.String)
  parent: System.Diagnostics.Process
  isExternal: false
  name: GetProcessById(Int32,String)
  nameWithType: Process.GetProcessById(Int32,String)
  fullName: System.Diagnostics.Process.GetProcessById(Int32,String)
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.Diagnostics.Process.GetProcesses
  parent: System.Diagnostics.Process
  isExternal: false
  name: GetProcesses()
  nameWithType: Process.GetProcesses()
  fullName: System.Diagnostics.Process.GetProcesses()
- uid: System.Diagnostics.Process[]
  parent: System.Diagnostics
  isExternal: false
  name: Process
  nameWithType: Process
  fullName: System.Diagnostics.Process[]
  spec.csharp:
  - uid: System.Diagnostics.Process
    name: Process
    nameWithType: Process
    fullName: Process[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Diagnostics.Process.GetProcesses(System.String)
  parent: System.Diagnostics.Process
  isExternal: false
  name: GetProcesses(String)
  nameWithType: Process.GetProcesses(String)
  fullName: System.Diagnostics.Process.GetProcesses(String)
- uid: System.Diagnostics.Process.GetProcessesByName(System.String)
  parent: System.Diagnostics.Process
  isExternal: false
  name: GetProcessesByName(String)
  nameWithType: Process.GetProcessesByName(String)
  fullName: System.Diagnostics.Process.GetProcessesByName(String)
- uid: System.Diagnostics.Process.GetProcessesByName(System.String,System.String)
  parent: System.Diagnostics.Process
  isExternal: false
  name: GetProcessesByName(String,String)
  nameWithType: Process.GetProcessesByName(String,String)
  fullName: System.Diagnostics.Process.GetProcessesByName(String,String)
- uid: System.Diagnostics.Process.Handle
  parent: System.Diagnostics.Process
  isExternal: false
  name: Handle
  nameWithType: Process.Handle
  fullName: System.Diagnostics.Process.Handle
- uid: System.IntPtr
  parent: System
  isExternal: true
  name: IntPtr
  nameWithType: IntPtr
  fullName: System.IntPtr
- uid: System.Diagnostics.Process.HandleCount
  parent: System.Diagnostics.Process
  isExternal: false
  name: HandleCount
  nameWithType: Process.HandleCount
  fullName: System.Diagnostics.Process.HandleCount
- uid: System.Diagnostics.Process.HasExited
  parent: System.Diagnostics.Process
  isExternal: false
  name: HasExited
  nameWithType: Process.HasExited
  fullName: System.Diagnostics.Process.HasExited
- uid: System.Diagnostics.Process.Id
  parent: System.Diagnostics.Process
  isExternal: false
  name: Id
  nameWithType: Process.Id
  fullName: System.Diagnostics.Process.Id
- uid: System.Diagnostics.Process.Kill
  parent: System.Diagnostics.Process
  isExternal: false
  name: Kill()
  nameWithType: Process.Kill()
  fullName: System.Diagnostics.Process.Kill()
- uid: System.Diagnostics.Process.LeaveDebugMode
  parent: System.Diagnostics.Process
  isExternal: false
  name: LeaveDebugMode()
  nameWithType: Process.LeaveDebugMode()
  fullName: System.Diagnostics.Process.LeaveDebugMode()
- uid: System.Diagnostics.Process.MachineName
  parent: System.Diagnostics.Process
  isExternal: false
  name: MachineName
  nameWithType: Process.MachineName
  fullName: System.Diagnostics.Process.MachineName
- uid: System.Diagnostics.Process.MainModule
  parent: System.Diagnostics.Process
  isExternal: false
  name: MainModule
  nameWithType: Process.MainModule
  fullName: System.Diagnostics.Process.MainModule
- uid: System.Diagnostics.ProcessModule
  parent: System.Diagnostics
  isExternal: false
  name: ProcessModule
  nameWithType: ProcessModule
  fullName: System.Diagnostics.ProcessModule
- uid: System.Diagnostics.Process.MainWindowHandle
  parent: System.Diagnostics.Process
  isExternal: false
  name: MainWindowHandle
  nameWithType: Process.MainWindowHandle
  fullName: System.Diagnostics.Process.MainWindowHandle
- uid: System.Diagnostics.Process.MainWindowTitle
  parent: System.Diagnostics.Process
  isExternal: false
  name: MainWindowTitle
  nameWithType: Process.MainWindowTitle
  fullName: System.Diagnostics.Process.MainWindowTitle
- uid: System.Diagnostics.Process.MaxWorkingSet
  parent: System.Diagnostics.Process
  isExternal: false
  name: MaxWorkingSet
  nameWithType: Process.MaxWorkingSet
  fullName: System.Diagnostics.Process.MaxWorkingSet
- uid: System.Diagnostics.Process.MinWorkingSet
  parent: System.Diagnostics.Process
  isExternal: false
  name: MinWorkingSet
  nameWithType: Process.MinWorkingSet
  fullName: System.Diagnostics.Process.MinWorkingSet
- uid: System.Diagnostics.Process.Modules
  parent: System.Diagnostics.Process
  isExternal: false
  name: Modules
  nameWithType: Process.Modules
  fullName: System.Diagnostics.Process.Modules
- uid: System.Diagnostics.ProcessModuleCollection
  parent: System.Diagnostics
  isExternal: false
  name: ProcessModuleCollection
  nameWithType: ProcessModuleCollection
  fullName: System.Diagnostics.ProcessModuleCollection
- uid: System.Diagnostics.Process.NonpagedSystemMemorySize
  parent: System.Diagnostics.Process
  isExternal: false
  name: NonpagedSystemMemorySize
  nameWithType: Process.NonpagedSystemMemorySize
  fullName: System.Diagnostics.Process.NonpagedSystemMemorySize
- uid: System.Diagnostics.Process.NonpagedSystemMemorySize64
  parent: System.Diagnostics.Process
  isExternal: false
  name: NonpagedSystemMemorySize64
  nameWithType: Process.NonpagedSystemMemorySize64
  fullName: System.Diagnostics.Process.NonpagedSystemMemorySize64
- uid: System.Int64
  parent: System
  isExternal: true
  name: Int64
  nameWithType: Int64
  fullName: System.Int64
- uid: System.Diagnostics.Process.OnExited
  parent: System.Diagnostics.Process
  isExternal: false
  name: OnExited()
  nameWithType: Process.OnExited()
  fullName: System.Diagnostics.Process.OnExited()
- uid: System.Diagnostics.Process.OutputDataReceived
  parent: System.Diagnostics.Process
  isExternal: false
  name: OutputDataReceived
  nameWithType: Process.OutputDataReceived
  fullName: System.Diagnostics.Process.OutputDataReceived
- uid: System.Diagnostics.Process.PagedMemorySize
  parent: System.Diagnostics.Process
  isExternal: false
  name: PagedMemorySize
  nameWithType: Process.PagedMemorySize
  fullName: System.Diagnostics.Process.PagedMemorySize
- uid: System.Diagnostics.Process.PagedMemorySize64
  parent: System.Diagnostics.Process
  isExternal: false
  name: PagedMemorySize64
  nameWithType: Process.PagedMemorySize64
  fullName: System.Diagnostics.Process.PagedMemorySize64
- uid: System.Diagnostics.Process.PagedSystemMemorySize
  parent: System.Diagnostics.Process
  isExternal: false
  name: PagedSystemMemorySize
  nameWithType: Process.PagedSystemMemorySize
  fullName: System.Diagnostics.Process.PagedSystemMemorySize
- uid: System.Diagnostics.Process.PagedSystemMemorySize64
  parent: System.Diagnostics.Process
  isExternal: false
  name: PagedSystemMemorySize64
  nameWithType: Process.PagedSystemMemorySize64
  fullName: System.Diagnostics.Process.PagedSystemMemorySize64
- uid: System.Diagnostics.Process.PeakPagedMemorySize
  parent: System.Diagnostics.Process
  isExternal: false
  name: PeakPagedMemorySize
  nameWithType: Process.PeakPagedMemorySize
  fullName: System.Diagnostics.Process.PeakPagedMemorySize
- uid: System.Diagnostics.Process.PeakPagedMemorySize64
  parent: System.Diagnostics.Process
  isExternal: false
  name: PeakPagedMemorySize64
  nameWithType: Process.PeakPagedMemorySize64
  fullName: System.Diagnostics.Process.PeakPagedMemorySize64
- uid: System.Diagnostics.Process.PeakVirtualMemorySize
  parent: System.Diagnostics.Process
  isExternal: false
  name: PeakVirtualMemorySize
  nameWithType: Process.PeakVirtualMemorySize
  fullName: System.Diagnostics.Process.PeakVirtualMemorySize
- uid: System.Diagnostics.Process.PeakVirtualMemorySize64
  parent: System.Diagnostics.Process
  isExternal: false
  name: PeakVirtualMemorySize64
  nameWithType: Process.PeakVirtualMemorySize64
  fullName: System.Diagnostics.Process.PeakVirtualMemorySize64
- uid: System.Diagnostics.Process.PeakWorkingSet
  parent: System.Diagnostics.Process
  isExternal: false
  name: PeakWorkingSet
  nameWithType: Process.PeakWorkingSet
  fullName: System.Diagnostics.Process.PeakWorkingSet
- uid: System.Diagnostics.Process.PeakWorkingSet64
  parent: System.Diagnostics.Process
  isExternal: false
  name: PeakWorkingSet64
  nameWithType: Process.PeakWorkingSet64
  fullName: System.Diagnostics.Process.PeakWorkingSet64
- uid: System.Diagnostics.Process.PriorityBoostEnabled
  parent: System.Diagnostics.Process
  isExternal: false
  name: PriorityBoostEnabled
  nameWithType: Process.PriorityBoostEnabled
  fullName: System.Diagnostics.Process.PriorityBoostEnabled
- uid: System.Diagnostics.Process.PriorityClass
  parent: System.Diagnostics.Process
  isExternal: false
  name: PriorityClass
  nameWithType: Process.PriorityClass
  fullName: System.Diagnostics.Process.PriorityClass
- uid: System.Diagnostics.ProcessPriorityClass
  parent: System.Diagnostics
  isExternal: false
  name: ProcessPriorityClass
  nameWithType: ProcessPriorityClass
  fullName: System.Diagnostics.ProcessPriorityClass
- uid: System.Diagnostics.Process.PrivateMemorySize
  parent: System.Diagnostics.Process
  isExternal: false
  name: PrivateMemorySize
  nameWithType: Process.PrivateMemorySize
  fullName: System.Diagnostics.Process.PrivateMemorySize
- uid: System.Diagnostics.Process.PrivateMemorySize64
  parent: System.Diagnostics.Process
  isExternal: false
  name: PrivateMemorySize64
  nameWithType: Process.PrivateMemorySize64
  fullName: System.Diagnostics.Process.PrivateMemorySize64
- uid: System.Diagnostics.Process.PrivilegedProcessorTime
  parent: System.Diagnostics.Process
  isExternal: false
  name: PrivilegedProcessorTime
  nameWithType: Process.PrivilegedProcessorTime
  fullName: System.Diagnostics.Process.PrivilegedProcessorTime
- uid: System.TimeSpan
  parent: System
  isExternal: true
  name: TimeSpan
  nameWithType: TimeSpan
  fullName: System.TimeSpan
- uid: System.Diagnostics.Process.ProcessName
  parent: System.Diagnostics.Process
  isExternal: false
  name: ProcessName
  nameWithType: Process.ProcessName
  fullName: System.Diagnostics.Process.ProcessName
- uid: System.Diagnostics.Process.ProcessorAffinity
  parent: System.Diagnostics.Process
  isExternal: false
  name: ProcessorAffinity
  nameWithType: Process.ProcessorAffinity
  fullName: System.Diagnostics.Process.ProcessorAffinity
- uid: System.Diagnostics.Process.Refresh
  parent: System.Diagnostics.Process
  isExternal: false
  name: Refresh()
  nameWithType: Process.Refresh()
  fullName: System.Diagnostics.Process.Refresh()
- uid: System.Diagnostics.Process.Responding
  parent: System.Diagnostics.Process
  isExternal: false
  name: Responding
  nameWithType: Process.Responding
  fullName: System.Diagnostics.Process.Responding
- uid: System.Diagnostics.Process.SafeHandle
  parent: System.Diagnostics.Process
  isExternal: false
  name: SafeHandle
  nameWithType: Process.SafeHandle
  fullName: System.Diagnostics.Process.SafeHandle
- uid: Microsoft.Win32.SafeHandles.SafeProcessHandle
  parent: Microsoft.Win32.SafeHandles
  isExternal: false
  name: SafeProcessHandle
  nameWithType: SafeProcessHandle
  fullName: Microsoft.Win32.SafeHandles.SafeProcessHandle
- uid: System.Diagnostics.Process.SessionId
  parent: System.Diagnostics.Process
  isExternal: false
  name: SessionId
  nameWithType: Process.SessionId
  fullName: System.Diagnostics.Process.SessionId
- uid: System.Diagnostics.Process.StandardError
  parent: System.Diagnostics.Process
  isExternal: false
  name: StandardError
  nameWithType: Process.StandardError
  fullName: System.Diagnostics.Process.StandardError
- uid: System.IO.StreamReader
  parent: System.IO
  isExternal: true
  name: StreamReader
  nameWithType: StreamReader
  fullName: System.IO.StreamReader
- uid: System.Diagnostics.Process.StandardInput
  parent: System.Diagnostics.Process
  isExternal: false
  name: StandardInput
  nameWithType: Process.StandardInput
  fullName: System.Diagnostics.Process.StandardInput
- uid: System.IO.StreamWriter
  parent: System.IO
  isExternal: true
  name: StreamWriter
  nameWithType: StreamWriter
  fullName: System.IO.StreamWriter
- uid: System.Diagnostics.Process.StandardOutput
  parent: System.Diagnostics.Process
  isExternal: false
  name: StandardOutput
  nameWithType: Process.StandardOutput
  fullName: System.Diagnostics.Process.StandardOutput
- uid: System.Diagnostics.Process.Start
  parent: System.Diagnostics.Process
  isExternal: false
  name: Start()
  nameWithType: Process.Start()
  fullName: System.Diagnostics.Process.Start()
- uid: System.Diagnostics.Process.Start(System.Diagnostics.ProcessStartInfo)
  parent: System.Diagnostics.Process
  isExternal: false
  name: Start(ProcessStartInfo)
  nameWithType: Process.Start(ProcessStartInfo)
  fullName: System.Diagnostics.Process.Start(ProcessStartInfo)
- uid: System.Diagnostics.ProcessStartInfo
  parent: System.Diagnostics
  isExternal: false
  name: ProcessStartInfo
  nameWithType: ProcessStartInfo
  fullName: System.Diagnostics.ProcessStartInfo
- uid: System.Diagnostics.Process.Start(System.String)
  parent: System.Diagnostics.Process
  isExternal: false
  name: Start(String)
  nameWithType: Process.Start(String)
  fullName: System.Diagnostics.Process.Start(String)
- uid: System.Diagnostics.Process.Start(System.String,System.String)
  parent: System.Diagnostics.Process
  isExternal: false
  name: Start(String,String)
  nameWithType: Process.Start(String,String)
  fullName: System.Diagnostics.Process.Start(String,String)
- uid: System.Diagnostics.Process.Start(System.String,System.String,System.Security.SecureString,System.String)
  parent: System.Diagnostics.Process
  isExternal: false
  name: Start(String,String,SecureString,String)
  nameWithType: Process.Start(String,String,SecureString,String)
  fullName: System.Diagnostics.Process.Start(String,String,SecureString,String)
- uid: System.Security.SecureString
  parent: System.Security
  isExternal: false
  name: SecureString
  nameWithType: SecureString
  fullName: System.Security.SecureString
- uid: System.Diagnostics.Process.Start(System.String,System.String,System.String,System.Security.SecureString,System.String)
  parent: System.Diagnostics.Process
  isExternal: false
  name: Start(String,String,String,SecureString,String)
  nameWithType: Process.Start(String,String,String,SecureString,String)
  fullName: System.Diagnostics.Process.Start(String,String,String,SecureString,String)
- uid: System.Diagnostics.Process.StartInfo
  parent: System.Diagnostics.Process
  isExternal: false
  name: StartInfo
  nameWithType: Process.StartInfo
  fullName: System.Diagnostics.Process.StartInfo
- uid: System.Diagnostics.Process.StartTime
  parent: System.Diagnostics.Process
  isExternal: false
  name: StartTime
  nameWithType: Process.StartTime
  fullName: System.Diagnostics.Process.StartTime
- uid: System.Diagnostics.Process.SynchronizingObject
  parent: System.Diagnostics.Process
  isExternal: false
  name: SynchronizingObject
  nameWithType: Process.SynchronizingObject
  fullName: System.Diagnostics.Process.SynchronizingObject
- uid: System.ComponentModel.ISynchronizeInvoke
  parent: System.ComponentModel
  isExternal: false
  name: ISynchronizeInvoke
  nameWithType: ISynchronizeInvoke
  fullName: System.ComponentModel.ISynchronizeInvoke
- uid: System.Diagnostics.Process.Threads
  parent: System.Diagnostics.Process
  isExternal: false
  name: Threads
  nameWithType: Process.Threads
  fullName: System.Diagnostics.Process.Threads
- uid: System.Diagnostics.ProcessThreadCollection
  parent: System.Diagnostics
  isExternal: false
  name: ProcessThreadCollection
  nameWithType: ProcessThreadCollection
  fullName: System.Diagnostics.ProcessThreadCollection
- uid: System.Diagnostics.Process.ToString
  parent: System.Diagnostics.Process
  isExternal: false
  name: ToString()
  nameWithType: Process.ToString()
  fullName: System.Diagnostics.Process.ToString()
- uid: System.Diagnostics.Process.TotalProcessorTime
  parent: System.Diagnostics.Process
  isExternal: false
  name: TotalProcessorTime
  nameWithType: Process.TotalProcessorTime
  fullName: System.Diagnostics.Process.TotalProcessorTime
- uid: System.Diagnostics.Process.UserProcessorTime
  parent: System.Diagnostics.Process
  isExternal: false
  name: UserProcessorTime
  nameWithType: Process.UserProcessorTime
  fullName: System.Diagnostics.Process.UserProcessorTime
- uid: System.Diagnostics.Process.VirtualMemorySize
  parent: System.Diagnostics.Process
  isExternal: false
  name: VirtualMemorySize
  nameWithType: Process.VirtualMemorySize
  fullName: System.Diagnostics.Process.VirtualMemorySize
- uid: System.Diagnostics.Process.VirtualMemorySize64
  parent: System.Diagnostics.Process
  isExternal: false
  name: VirtualMemorySize64
  nameWithType: Process.VirtualMemorySize64
  fullName: System.Diagnostics.Process.VirtualMemorySize64
- uid: System.Diagnostics.Process.WaitForExit
  parent: System.Diagnostics.Process
  isExternal: false
  name: WaitForExit()
  nameWithType: Process.WaitForExit()
  fullName: System.Diagnostics.Process.WaitForExit()
- uid: System.Diagnostics.Process.WaitForExit(System.Int32)
  parent: System.Diagnostics.Process
  isExternal: false
  name: WaitForExit(Int32)
  nameWithType: Process.WaitForExit(Int32)
  fullName: System.Diagnostics.Process.WaitForExit(Int32)
- uid: System.Diagnostics.Process.WaitForInputIdle
  parent: System.Diagnostics.Process
  isExternal: false
  name: WaitForInputIdle()
  nameWithType: Process.WaitForInputIdle()
  fullName: System.Diagnostics.Process.WaitForInputIdle()
- uid: System.Diagnostics.Process.WaitForInputIdle(System.Int32)
  parent: System.Diagnostics.Process
  isExternal: false
  name: WaitForInputIdle(Int32)
  nameWithType: Process.WaitForInputIdle(Int32)
  fullName: System.Diagnostics.Process.WaitForInputIdle(Int32)
- uid: System.Diagnostics.Process.WorkingSet
  parent: System.Diagnostics.Process
  isExternal: false
  name: WorkingSet
  nameWithType: Process.WorkingSet
  fullName: System.Diagnostics.Process.WorkingSet
- uid: System.Diagnostics.Process.WorkingSet64
  parent: System.Diagnostics.Process
  isExternal: false
  name: WorkingSet64
  nameWithType: Process.WorkingSet64
  fullName: System.Diagnostics.Process.WorkingSet64
- uid: System.Diagnostics.Process.#ctor*
  parent: System.Diagnostics.Process
  isExternal: false
  name: Process
  nameWithType: Process.Process
- uid: System.Diagnostics.Process.BasePriority*
  parent: System.Diagnostics.Process
  isExternal: false
  name: BasePriority
  nameWithType: Process.BasePriority
- uid: System.Diagnostics.Process.BeginErrorReadLine*
  parent: System.Diagnostics.Process
  isExternal: false
  name: BeginErrorReadLine
  nameWithType: Process.BeginErrorReadLine
- uid: System.Diagnostics.Process.BeginOutputReadLine*
  parent: System.Diagnostics.Process
  isExternal: false
  name: BeginOutputReadLine
  nameWithType: Process.BeginOutputReadLine
- uid: System.Diagnostics.Process.CancelErrorRead*
  parent: System.Diagnostics.Process
  isExternal: false
  name: CancelErrorRead
  nameWithType: Process.CancelErrorRead
- uid: System.Diagnostics.Process.CancelOutputRead*
  parent: System.Diagnostics.Process
  isExternal: false
  name: CancelOutputRead
  nameWithType: Process.CancelOutputRead
- uid: System.Diagnostics.Process.Close*
  parent: System.Diagnostics.Process
  isExternal: false
  name: Close
  nameWithType: Process.Close
- uid: System.Diagnostics.Process.CloseMainWindow*
  parent: System.Diagnostics.Process
  isExternal: false
  name: CloseMainWindow
  nameWithType: Process.CloseMainWindow
- uid: System.Diagnostics.Process.Dispose*
  parent: System.Diagnostics.Process
  isExternal: false
  name: Dispose
  nameWithType: Process.Dispose
- uid: System.Diagnostics.Process.EnableRaisingEvents*
  parent: System.Diagnostics.Process
  isExternal: false
  name: EnableRaisingEvents
  nameWithType: Process.EnableRaisingEvents
- uid: System.Diagnostics.Process.EnterDebugMode*
  parent: System.Diagnostics.Process
  isExternal: false
  name: EnterDebugMode
  nameWithType: Process.EnterDebugMode
- uid: System.Diagnostics.Process.ExitCode*
  parent: System.Diagnostics.Process
  isExternal: false
  name: ExitCode
  nameWithType: Process.ExitCode
- uid: System.Diagnostics.Process.ExitTime*
  parent: System.Diagnostics.Process
  isExternal: false
  name: ExitTime
  nameWithType: Process.ExitTime
- uid: System.Diagnostics.Process.GetCurrentProcess*
  parent: System.Diagnostics.Process
  isExternal: false
  name: GetCurrentProcess
  nameWithType: Process.GetCurrentProcess
- uid: System.Diagnostics.Process.GetProcessById*
  parent: System.Diagnostics.Process
  isExternal: false
  name: GetProcessById
  nameWithType: Process.GetProcessById
- uid: System.Diagnostics.Process.GetProcesses*
  parent: System.Diagnostics.Process
  isExternal: false
  name: GetProcesses
  nameWithType: Process.GetProcesses
- uid: System.Diagnostics.Process.GetProcessesByName*
  parent: System.Diagnostics.Process
  isExternal: false
  name: GetProcessesByName
  nameWithType: Process.GetProcessesByName
- uid: System.Diagnostics.Process.Handle*
  parent: System.Diagnostics.Process
  isExternal: false
  name: Handle
  nameWithType: Process.Handle
- uid: System.Diagnostics.Process.HandleCount*
  parent: System.Diagnostics.Process
  isExternal: false
  name: HandleCount
  nameWithType: Process.HandleCount
- uid: System.Diagnostics.Process.HasExited*
  parent: System.Diagnostics.Process
  isExternal: false
  name: HasExited
  nameWithType: Process.HasExited
- uid: System.Diagnostics.Process.Id*
  parent: System.Diagnostics.Process
  isExternal: false
  name: Id
  nameWithType: Process.Id
- uid: System.Diagnostics.Process.Kill*
  parent: System.Diagnostics.Process
  isExternal: false
  name: Kill
  nameWithType: Process.Kill
- uid: System.Diagnostics.Process.LeaveDebugMode*
  parent: System.Diagnostics.Process
  isExternal: false
  name: LeaveDebugMode
  nameWithType: Process.LeaveDebugMode
- uid: System.Diagnostics.Process.MachineName*
  parent: System.Diagnostics.Process
  isExternal: false
  name: MachineName
  nameWithType: Process.MachineName
- uid: System.Diagnostics.Process.MainModule*
  parent: System.Diagnostics.Process
  isExternal: false
  name: MainModule
  nameWithType: Process.MainModule
- uid: System.Diagnostics.Process.MainWindowHandle*
  parent: System.Diagnostics.Process
  isExternal: false
  name: MainWindowHandle
  nameWithType: Process.MainWindowHandle
- uid: System.Diagnostics.Process.MainWindowTitle*
  parent: System.Diagnostics.Process
  isExternal: false
  name: MainWindowTitle
  nameWithType: Process.MainWindowTitle
- uid: System.Diagnostics.Process.MaxWorkingSet*
  parent: System.Diagnostics.Process
  isExternal: false
  name: MaxWorkingSet
  nameWithType: Process.MaxWorkingSet
- uid: System.Diagnostics.Process.MinWorkingSet*
  parent: System.Diagnostics.Process
  isExternal: false
  name: MinWorkingSet
  nameWithType: Process.MinWorkingSet
- uid: System.Diagnostics.Process.Modules*
  parent: System.Diagnostics.Process
  isExternal: false
  name: Modules
  nameWithType: Process.Modules
- uid: System.Diagnostics.Process.NonpagedSystemMemorySize*
  parent: System.Diagnostics.Process
  isExternal: false
  name: NonpagedSystemMemorySize
  nameWithType: Process.NonpagedSystemMemorySize
- uid: System.Diagnostics.Process.NonpagedSystemMemorySize64*
  parent: System.Diagnostics.Process
  isExternal: false
  name: NonpagedSystemMemorySize64
  nameWithType: Process.NonpagedSystemMemorySize64
- uid: System.Diagnostics.Process.OnExited*
  parent: System.Diagnostics.Process
  isExternal: false
  name: OnExited
  nameWithType: Process.OnExited
- uid: System.Diagnostics.Process.PagedMemorySize*
  parent: System.Diagnostics.Process
  isExternal: false
  name: PagedMemorySize
  nameWithType: Process.PagedMemorySize
- uid: System.Diagnostics.Process.PagedMemorySize64*
  parent: System.Diagnostics.Process
  isExternal: false
  name: PagedMemorySize64
  nameWithType: Process.PagedMemorySize64
- uid: System.Diagnostics.Process.PagedSystemMemorySize*
  parent: System.Diagnostics.Process
  isExternal: false
  name: PagedSystemMemorySize
  nameWithType: Process.PagedSystemMemorySize
- uid: System.Diagnostics.Process.PagedSystemMemorySize64*
  parent: System.Diagnostics.Process
  isExternal: false
  name: PagedSystemMemorySize64
  nameWithType: Process.PagedSystemMemorySize64
- uid: System.Diagnostics.Process.PeakPagedMemorySize*
  parent: System.Diagnostics.Process
  isExternal: false
  name: PeakPagedMemorySize
  nameWithType: Process.PeakPagedMemorySize
- uid: System.Diagnostics.Process.PeakPagedMemorySize64*
  parent: System.Diagnostics.Process
  isExternal: false
  name: PeakPagedMemorySize64
  nameWithType: Process.PeakPagedMemorySize64
- uid: System.Diagnostics.Process.PeakVirtualMemorySize*
  parent: System.Diagnostics.Process
  isExternal: false
  name: PeakVirtualMemorySize
  nameWithType: Process.PeakVirtualMemorySize
- uid: System.Diagnostics.Process.PeakVirtualMemorySize64*
  parent: System.Diagnostics.Process
  isExternal: false
  name: PeakVirtualMemorySize64
  nameWithType: Process.PeakVirtualMemorySize64
- uid: System.Diagnostics.Process.PeakWorkingSet*
  parent: System.Diagnostics.Process
  isExternal: false
  name: PeakWorkingSet
  nameWithType: Process.PeakWorkingSet
- uid: System.Diagnostics.Process.PeakWorkingSet64*
  parent: System.Diagnostics.Process
  isExternal: false
  name: PeakWorkingSet64
  nameWithType: Process.PeakWorkingSet64
- uid: System.Diagnostics.Process.PriorityBoostEnabled*
  parent: System.Diagnostics.Process
  isExternal: false
  name: PriorityBoostEnabled
  nameWithType: Process.PriorityBoostEnabled
- uid: System.Diagnostics.Process.PriorityClass*
  parent: System.Diagnostics.Process
  isExternal: false
  name: PriorityClass
  nameWithType: Process.PriorityClass
- uid: System.Diagnostics.Process.PrivateMemorySize*
  parent: System.Diagnostics.Process
  isExternal: false
  name: PrivateMemorySize
  nameWithType: Process.PrivateMemorySize
- uid: System.Diagnostics.Process.PrivateMemorySize64*
  parent: System.Diagnostics.Process
  isExternal: false
  name: PrivateMemorySize64
  nameWithType: Process.PrivateMemorySize64
- uid: System.Diagnostics.Process.PrivilegedProcessorTime*
  parent: System.Diagnostics.Process
  isExternal: false
  name: PrivilegedProcessorTime
  nameWithType: Process.PrivilegedProcessorTime
- uid: System.Diagnostics.Process.ProcessName*
  parent: System.Diagnostics.Process
  isExternal: false
  name: ProcessName
  nameWithType: Process.ProcessName
- uid: System.Diagnostics.Process.ProcessorAffinity*
  parent: System.Diagnostics.Process
  isExternal: false
  name: ProcessorAffinity
  nameWithType: Process.ProcessorAffinity
- uid: System.Diagnostics.Process.Refresh*
  parent: System.Diagnostics.Process
  isExternal: false
  name: Refresh
  nameWithType: Process.Refresh
- uid: System.Diagnostics.Process.Responding*
  parent: System.Diagnostics.Process
  isExternal: false
  name: Responding
  nameWithType: Process.Responding
- uid: System.Diagnostics.Process.SafeHandle*
  parent: System.Diagnostics.Process
  isExternal: false
  name: SafeHandle
  nameWithType: Process.SafeHandle
- uid: System.Diagnostics.Process.SessionId*
  parent: System.Diagnostics.Process
  isExternal: false
  name: SessionId
  nameWithType: Process.SessionId
- uid: System.Diagnostics.Process.StandardError*
  parent: System.Diagnostics.Process
  isExternal: false
  name: StandardError
  nameWithType: Process.StandardError
- uid: System.Diagnostics.Process.StandardInput*
  parent: System.Diagnostics.Process
  isExternal: false
  name: StandardInput
  nameWithType: Process.StandardInput
- uid: System.Diagnostics.Process.StandardOutput*
  parent: System.Diagnostics.Process
  isExternal: false
  name: StandardOutput
  nameWithType: Process.StandardOutput
- uid: System.Diagnostics.Process.Start*
  parent: System.Diagnostics.Process
  isExternal: false
  name: Start
  nameWithType: Process.Start
- uid: System.Diagnostics.Process.StartInfo*
  parent: System.Diagnostics.Process
  isExternal: false
  name: StartInfo
  nameWithType: Process.StartInfo
- uid: System.Diagnostics.Process.StartTime*
  parent: System.Diagnostics.Process
  isExternal: false
  name: StartTime
  nameWithType: Process.StartTime
- uid: System.Diagnostics.Process.SynchronizingObject*
  parent: System.Diagnostics.Process
  isExternal: false
  name: SynchronizingObject
  nameWithType: Process.SynchronizingObject
- uid: System.Diagnostics.Process.Threads*
  parent: System.Diagnostics.Process
  isExternal: false
  name: Threads
  nameWithType: Process.Threads
- uid: System.Diagnostics.Process.ToString*
  parent: System.Diagnostics.Process
  isExternal: false
  name: ToString
  nameWithType: Process.ToString
- uid: System.Diagnostics.Process.TotalProcessorTime*
  parent: System.Diagnostics.Process
  isExternal: false
  name: TotalProcessorTime
  nameWithType: Process.TotalProcessorTime
- uid: System.Diagnostics.Process.UserProcessorTime*
  parent: System.Diagnostics.Process
  isExternal: false
  name: UserProcessorTime
  nameWithType: Process.UserProcessorTime
- uid: System.Diagnostics.Process.VirtualMemorySize*
  parent: System.Diagnostics.Process
  isExternal: false
  name: VirtualMemorySize
  nameWithType: Process.VirtualMemorySize
- uid: System.Diagnostics.Process.VirtualMemorySize64*
  parent: System.Diagnostics.Process
  isExternal: false
  name: VirtualMemorySize64
  nameWithType: Process.VirtualMemorySize64
- uid: System.Diagnostics.Process.WaitForExit*
  parent: System.Diagnostics.Process
  isExternal: false
  name: WaitForExit
  nameWithType: Process.WaitForExit
- uid: System.Diagnostics.Process.WaitForInputIdle*
  parent: System.Diagnostics.Process
  isExternal: false
  name: WaitForInputIdle
  nameWithType: Process.WaitForInputIdle
- uid: System.Diagnostics.Process.WorkingSet*
  parent: System.Diagnostics.Process
  isExternal: false
  name: WorkingSet
  nameWithType: Process.WorkingSet
- uid: System.Diagnostics.Process.WorkingSet64*
  parent: System.Diagnostics.Process
  isExternal: false
  name: WorkingSet64
  nameWithType: Process.WorkingSet64
