### YamlMime:ManagedReference
items:
- uid: System.Net.Sockets.NetworkStream
  id: NetworkStream
  children:
  - System.Net.Sockets.NetworkStream.#ctor(System.Net.Sockets.Socket)
  - System.Net.Sockets.NetworkStream.#ctor(System.Net.Sockets.Socket,System.Boolean)
  - System.Net.Sockets.NetworkStream.#ctor(System.Net.Sockets.Socket,System.IO.FileAccess)
  - System.Net.Sockets.NetworkStream.#ctor(System.Net.Sockets.Socket,System.IO.FileAccess,System.Boolean)
  - System.Net.Sockets.NetworkStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  - System.Net.Sockets.NetworkStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  - System.Net.Sockets.NetworkStream.CanRead
  - System.Net.Sockets.NetworkStream.CanSeek
  - System.Net.Sockets.NetworkStream.CanTimeout
  - System.Net.Sockets.NetworkStream.CanWrite
  - System.Net.Sockets.NetworkStream.Close(System.Int32)
  - System.Net.Sockets.NetworkStream.DataAvailable
  - System.Net.Sockets.NetworkStream.Dispose(System.Boolean)
  - System.Net.Sockets.NetworkStream.EndRead(System.IAsyncResult)
  - System.Net.Sockets.NetworkStream.EndWrite(System.IAsyncResult)
  - System.Net.Sockets.NetworkStream.Finalize
  - System.Net.Sockets.NetworkStream.Flush
  - System.Net.Sockets.NetworkStream.FlushAsync(System.Threading.CancellationToken)
  - System.Net.Sockets.NetworkStream.Length
  - System.Net.Sockets.NetworkStream.Position
  - System.Net.Sockets.NetworkStream.Read(System.Byte[],System.Int32,System.Int32)
  - System.Net.Sockets.NetworkStream.Readable
  - System.Net.Sockets.NetworkStream.ReadTimeout
  - System.Net.Sockets.NetworkStream.Seek(System.Int64,System.IO.SeekOrigin)
  - System.Net.Sockets.NetworkStream.SetLength(System.Int64)
  - System.Net.Sockets.NetworkStream.Socket
  - System.Net.Sockets.NetworkStream.Write(System.Byte[],System.Int32,System.Int32)
  - System.Net.Sockets.NetworkStream.Writeable
  - System.Net.Sockets.NetworkStream.WriteTimeout
  langs:
  - csharp
  name: NetworkStream
  nameWithType: NetworkStream
  fullName: System.Net.Sockets.NetworkStream
  type: Class
  summary: "Inneholder den underliggende datastrøm for nettverkstilgang."
  remarks: "Klassen NetworkStream inneholder metoder for sending og mottak av data over <xref:System.Net.Sockets.SocketType>sockets i blokkerer modus.</xref:System.Net.Sockets.SocketType> For mer informasjon om blokkering sammenlignet med ikke-blokkerende <xref:System.Net.Sockets.Socket>s, kan du se [ved hjelp av en asynkron klientsocket](~/add/includes/ajax-current-ext-md.md).</xref:System.Net.Sockets.Socket> Du kan bruke klassen NetworkStream for både synkrone og asynkrone dataoverføring. Du finner mer informasjon om synkrone og asynkrone kommunikasjon [Sockets](~/add/includes/ajax-current-ext-md.md).       Hvis du vil opprette en NetworkStream, må du angi en tilkoblet <xref:System.Net.Sockets.Socket>.</xref:System.Net.Sockets.Socket> Du kan også angi hvilken <xref:System.IO.FileAccess>tillatelse av NetworkStream er over den angitte <xref:System.Net.Sockets.Socket>.</xref:System.Net.Sockets.Socket> </xref:System.IO.FileAccess> Som standard lukkes lukking av NetworkStream ikke den angitte <xref:System.Net.Sockets.Socket>.</xref:System.Net.Sockets.Socket> Hvis du vil NetworkStream har tillatelse til å lukke den angitte <xref:System.Net.Sockets.Socket>, må du angi `true` for verdien for den `ownsSocket` parameteren.</xref:System.Net.Sockets.Socket>       Bruk av <xref:System.Net.Sockets.NetworkStream.Write%2A>og <xref:System.Net.Sockets.NetworkStream.Read%2A>metoder for enkel én tråd synkron blokkerer i/u.</xref:System.Net.Sockets.NetworkStream.Read%2A> </xref:System.Net.Sockets.NetworkStream.Write%2A> Hvis du vil behandle din i/u med egne tråder, kan du vurdere å bruke den <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A>og <xref:System.Net.Sockets.NetworkStream.EndWrite%2A>metoder, eller <xref:System.Net.Sockets.NetworkStream.BeginRead%2A>og <xref:System.Net.Sockets.NetworkStream.EndRead%2A>metoder for kommunikasjon.</xref:System.Net.Sockets.NetworkStream.EndRead%2A> </xref:System.Net.Sockets.NetworkStream.BeginRead%2A> </xref:System.Net.Sockets.NetworkStream.EndWrite%2A> </xref:System.Net.Sockets.NetworkStream.BeginWrite%2A>       NetworkStream støtter ikke RAM i nettverket dataflyten. Verdien for den <xref:System.Net.Sockets.NetworkStream.CanSeek%2A>egenskap, som angir om Dataflyten støtter søking, er alltid `false`; lesing <xref:System.Net.Sockets.NetworkStream.Position%2A>egenskapen lesing av <xref:System.Net.Sockets.NetworkStream.Length%2A>egenskapen, eller kaller <xref:System.Net.Sockets.NetworkStream.Seek%2A>metoden vil throw <xref:System.NotSupportedException>.</xref:System.NotSupportedException> </xref:System.Net.Sockets.NetworkStream.Seek%2A> </xref:System.Net.Sockets.NetworkStream.Length%2A> </xref:System.Net.Sockets.NetworkStream.Position%2A> </xref:System.Net.Sockets.NetworkStream.CanSeek%2A>       Lese og skrive kan utføres samtidig til en forekomst av klassen NetworkStream uten å måtte synkronisering. Så lenge det finnes en unik tråd for skriveoperasjoner én unik tråd for leseoperasjoner, vil det være uten tvers-forstyrrelser mellom lese og skrive tråder, og ingen synkronisering er nødvendig."
  example:
  - "The following code example demonstrates how to create a NetworkStream from a connected <xref:System.Net.Sockets.SocketType><xref:System.Net.Sockets.Socket> and perform basic synchronous blocking I/O.  \n  \n [!code-vb[NetworkStream_Synch_SendAndReceive#2](~/add/codesnippet/visualbasic/t-system.net.sockets.net_1.vb)]\n [!code-cpp[NetworkStream_Synch_SendAndReceive#2](~/add/codesnippet/cpp/t-system.net.sockets.net_1.cpp)]\n [!code-cs[NetworkStream_Synch_SendAndReceive#2](~/add/codesnippet/csharp/t-system.net.sockets.net_1.cs)]"
  syntax:
    content: 'public class NetworkStream : System.IO.Stream'
  inheritance:
  - System.IO.Stream
  implements: []
  inheritedMembers: []
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.#ctor(System.Net.Sockets.Socket)
  id: '#ctor(System.Net.Sockets.Socket)'
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: NetworkStream(Socket)
  nameWithType: NetworkStream.NetworkStream(Socket)
  fullName: System.Net.Sockets.NetworkStream.NetworkStream(Socket)
  type: Constructor
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Oppretter en ny forekomst av den <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> klasse for den angitte <xref:System.Net.Sockets.Socket>.</xref:System.Net.Sockets.Socket>"
  remarks: "<xref:System.Net.Sockets.NetworkStream>Opprettes med lese-/ skrivetilgang til den angitte <xref:System.Net.Sockets.Socket>.</xref:System.Net.Sockets.Socket> </xref:System.Net.Sockets.NetworkStream> <xref:System.Net.Sockets.NetworkStream>Ikke eier den underliggende <xref:System.Net.Sockets.Socket>så kaller <xref:System.Net.Sockets.NetworkStream.Close%2A>metoden kan ikke lukke <xref:System.Net.Sockets.Socket>.</xref:System.Net.Sockets.Socket> </xref:System.Net.Sockets.NetworkStream.Close%2A> </xref:System.Net.Sockets.Socket> </xref:System.Net.Sockets.NetworkStream>"
  example:
  - "The following code example illustrates how to create a <xref:System.Net.Sockets.NetworkStream> with a <xref:System.Net.Sockets.Socket>.  \n  \n [!code-vb[NetworkStream_Synch_SendAndReceive#2](~/add/codesnippet/visualbasic/m-system.net.sockets.net_0_1.vb)]\n [!code-cpp[NetworkStream_Synch_SendAndReceive#2](~/add/codesnippet/cpp/m-system.net.sockets.net_0_1.cpp)]\n [!code-cs[NetworkStream_Synch_SendAndReceive#2](~/add/codesnippet/csharp/m-system.net.sockets.net_0_1.cs)]"
  syntax:
    content: public NetworkStream (System.Net.Sockets.Socket socket);
    parameters:
    - id: socket
      type: System.Net.Sockets.Socket
      description: "Den <xref:System.Net.Sockets.Socket>som den <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> skal bruke til å sende og motta data.</xref:System.Net.Sockets.Socket>"
  overload: System.Net.Sockets.NetworkStream.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>socket</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Den <code> socket </code> parameteren er ikke koblet til.       - eller - <xref:System.Net.Sockets.Socket.SocketType*>for den <code> socket </code> -parameteren er ikke &lt;xref:System.Net.Sockets.SocketType?displayProperty=fullName&gt;.</xref:System.Net.Sockets.Socket.SocketType*>       - eller - <code> socket </code> parameteren er i en ikke-blokkerende tilstand."
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.#ctor(System.Net.Sockets.Socket,System.Boolean)
  id: '#ctor(System.Net.Sockets.Socket,System.Boolean)'
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: NetworkStream(Socket,Boolean)
  nameWithType: NetworkStream.NetworkStream(Socket,Boolean)
  fullName: System.Net.Sockets.NetworkStream.NetworkStream(Socket,Boolean)
  type: Constructor
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Initialiserer en ny forekomst av den <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> klasse for den angitte <xref:System.Net.Sockets.Socket>med angitt <xref:System.Net.Sockets.Socket>eierskap.</xref:System.Net.Sockets.Socket> </xref:System.Net.Sockets.Socket>"
  remarks: "<xref:System.Net.Sockets.NetworkStream>Opprettes med lese-/ skrivetilgang til den angitte <xref:System.Net.Sockets.Socket>.</xref:System.Net.Sockets.Socket> </xref:System.Net.Sockets.NetworkStream> Hvis verdien for `ownsSocket` parameteren er `true`, <xref:System.Net.Sockets.NetworkStream>blir eier av den underliggende <xref:System.Net.Sockets.Socket>, og kaller <xref:System.Net.Sockets.NetworkStream.Close%2A>metoden lukker også underliggende <xref:System.Net.Sockets.Socket>.</xref:System.Net.Sockets.Socket> </xref:System.Net.Sockets.NetworkStream.Close%2A> </xref:System.Net.Sockets.Socket> </xref:System.Net.Sockets.NetworkStream>"
  example:
  - "The following code example creates a <xref:System.Net.Sockets.NetworkStream> with ownership of the <xref:System.Net.Sockets.Socket>.  \n  \n [!code-vb[NetworkStream_Synch_SendAndReceive#2](~/add/codesnippet/visualbasic/59c93a1c-9c9b-46b2-a872-_1.vb)]\n [!code-cpp[NetworkStream_Synch_SendAndReceive#2](~/add/codesnippet/cpp/59c93a1c-9c9b-46b2-a872-_1.cpp)]\n [!code-cs[NetworkStream_Synch_SendAndReceive#2](~/add/codesnippet/csharp/59c93a1c-9c9b-46b2-a872-_1.cs)]"
  syntax:
    content: public NetworkStream (System.Net.Sockets.Socket socket, bool ownsSocket);
    parameters:
    - id: socket
      type: System.Net.Sockets.Socket
      description: "Den <xref:System.Net.Sockets.Socket>som den <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> skal bruke til å sende og motta data.</xref:System.Net.Sockets.Socket>"
    - id: ownsSocket
      type: System.Boolean
      description: "Satt til <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref> å angi at den <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> vil ta eierskap over den <xref:System.Net.Sockets.Socket>; ellers <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>.</xref:System.Net.Sockets.Socket>"
  overload: System.Net.Sockets.NetworkStream.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>socket</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Den <code> socket </code> parameteren er ikke koblet til.       - eller - verdien for den <xref:System.Net.Sockets.Socket.SocketType*>for den <code> socket </code> -parameteren er ikke &lt;xref:System.Net.Sockets.SocketType?displayProperty=fullName&gt;.</xref:System.Net.Sockets.Socket.SocketType*>       - eller - <code> socket </code> parameteren er i en ikke-blokkerende tilstand."
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.#ctor(System.Net.Sockets.Socket,System.IO.FileAccess)
  id: '#ctor(System.Net.Sockets.Socket,System.IO.FileAccess)'
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: NetworkStream(Socket,FileAccess)
  nameWithType: NetworkStream.NetworkStream(Socket,FileAccess)
  fullName: System.Net.Sockets.NetworkStream.NetworkStream(Socket,FileAccess)
  type: Constructor
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Oppretter en ny forekomst av den <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> klasse for den angitte <xref:System.Net.Sockets.Socket>med de angitte tilgangsrettighetene.</xref:System.Net.Sockets.Socket>"
  remarks: "Det <xref:System.Net.Sockets.NetworkStream>er opprettet med den angitte tilgangen til den angitte <xref:System.Net.Sockets.Socket>.</xref:System.Net.Sockets.Socket> </xref:System.Net.Sockets.NetworkStream> Med denne konstruktøren, kan du <xref:System.Net.Sockets.NetworkStream>ikke eier den underliggende <xref:System.Net.Sockets.Socket>kaller så <xref:System.Net.Sockets.NetworkStream.Close%2A>metoden kan ikke lukke den underliggende <xref:System.Net.Sockets.Socket>.</xref:System.Net.Sockets.Socket> </xref:System.Net.Sockets.NetworkStream.Close%2A> </xref:System.Net.Sockets.Socket> </xref:System.Net.Sockets.NetworkStream>       Den `access` parameteren angir <xref:System.Net.Sockets.NetworkStream.CanRead%2A>og <xref:System.Net.Sockets.NetworkStream.CanWrite%2A>Egenskaper for <xref:System.Net.Sockets.NetworkStream>.</xref:System.Net.Sockets.NetworkStream> </xref:System.Net.Sockets.NetworkStream.CanWrite%2A> </xref:System.Net.Sockets.NetworkStream.CanRead%2A> Hvis du angir <xref:System.IO.FileAccess>, vil <xref:System.Net.Sockets.NetworkStream>tillater kall til den <xref:System.Net.Sockets.NetworkStream.Write%2A>metoden.</xref:System.Net.Sockets.NetworkStream.Write%2A> </xref:System.Net.Sockets.NetworkStream> </xref:System.IO.FileAccess> Hvis du angir <xref:System.IO.FileAccess>, vil <xref:System.Net.Sockets.NetworkStream>tillater kall til den <xref:System.Net.Sockets.NetworkStream.Read%2A>metoden.</xref:System.Net.Sockets.NetworkStream.Read%2A> </xref:System.Net.Sockets.NetworkStream> </xref:System.IO.FileAccess> Hvis du angir <xref:System.IO.FileAccess>, både metodekall er tillatt.</xref:System.IO.FileAccess>"
  example:
  - "The following code example creates a <xref:System.Net.Sockets.NetworkStream> with the ability to read and write to the <xref:System.Net.Sockets.Socket>.  \n  \n [!code-vb[NetworkStream_Async_SendAndReceive#1](~/add/codesnippet/visualbasic/586c6962-cd9c-4b70-aa3e-_1.vb)]\n [!code-cs[NetworkStream_Async_SendAndReceive#1](~/add/codesnippet/csharp/586c6962-cd9c-4b70-aa3e-_1.cs)]\n [!code-cpp[NetworkStream_Async_SendAndReceive#1](~/add/codesnippet/cpp/586c6962-cd9c-4b70-aa3e-_1.cpp)]"
  syntax:
    content: public NetworkStream (System.Net.Sockets.Socket socket, System.IO.FileAccess access);
    parameters:
    - id: socket
      type: System.Net.Sockets.Socket
      description: "Den <xref:System.Net.Sockets.Socket>som den <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> skal bruke til å sende og motta data.</xref:System.Net.Sockets.Socket>"
    - id: access
      type: System.IO.FileAccess
      description: "En bitvis kombinasjon av det <xref href=&quot;System.IO.FileAccess&quot;> </xref> verdier som angir hvilken type tilgang gitt til den <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> over den angitte <xref:System.Net.Sockets.Socket>.</xref:System.Net.Sockets.Socket>"
  overload: System.Net.Sockets.NetworkStream.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>socket</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Den <code> socket </code> parameteren er ikke koblet til.       - eller - <xref:System.Net.Sockets.Socket.SocketType*>for den <code> socket </code> -parameteren er ikke &lt;xref:System.Net.Sockets.SocketType?displayProperty=fullName&gt;.</xref:System.Net.Sockets.Socket.SocketType*>       - eller - <code> socket </code> parameteren er i en ikke-blokkerende tilstand."
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.#ctor(System.Net.Sockets.Socket,System.IO.FileAccess,System.Boolean)
  id: '#ctor(System.Net.Sockets.Socket,System.IO.FileAccess,System.Boolean)'
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: NetworkStream(Socket,FileAccess,Boolean)
  nameWithType: NetworkStream.NetworkStream(Socket,FileAccess,Boolean)
  fullName: System.Net.Sockets.NetworkStream.NetworkStream(Socket,FileAccess,Boolean)
  type: Constructor
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Oppretter en ny forekomst av den <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> klasse for den angitte <xref:System.Net.Sockets.Socket>med de angitte tilgangsrettighetene og den angitte <xref:System.Net.Sockets.Socket>eierskap.</xref:System.Net.Sockets.Socket> </xref:System.Net.Sockets.Socket>"
  remarks: "<xref:System.Net.Sockets.NetworkStream>Opprettes med lese-/ skrivetilgang til den angitte <xref:System.Net.Sockets.Socket>.</xref:System.Net.Sockets.Socket> </xref:System.Net.Sockets.NetworkStream> Hvis verdien for den `ownsSocket` parameteren er `true`, <xref:System.Net.Sockets.NetworkStream>blir eier av den underliggende <xref:System.Net.Sockets.Socket>, og kaller <xref:System.Net.Sockets.NetworkStream.Close%2A>metoden lukker også underliggende <xref:System.Net.Sockets.Socket>.</xref:System.Net.Sockets.Socket> </xref:System.Net.Sockets.NetworkStream.Close%2A> </xref:System.Net.Sockets.Socket> </xref:System.Net.Sockets.NetworkStream>       Den `access` parameteren angir <xref:System.Net.Sockets.NetworkStream.CanRead%2A>og <xref:System.Net.Sockets.NetworkStream.CanWrite%2A>Egenskaper for <xref:System.Net.Sockets.NetworkStream>.</xref:System.Net.Sockets.NetworkStream> </xref:System.Net.Sockets.NetworkStream.CanWrite%2A> </xref:System.Net.Sockets.NetworkStream.CanRead%2A> Hvis du angir <xref:System.IO.FileAccess>, vil <xref:System.Net.Sockets.NetworkStream>tillater kall til den <xref:System.Net.Sockets.NetworkStream.Write%2A>metoden.</xref:System.Net.Sockets.NetworkStream.Write%2A> </xref:System.Net.Sockets.NetworkStream> </xref:System.IO.FileAccess> Hvis du angir <xref:System.IO.FileAccess>, vil <xref:System.Net.Sockets.NetworkStream>tillater kall til den <xref:System.Net.Sockets.NetworkStream.Read%2A>metoden.</xref:System.Net.Sockets.NetworkStream.Read%2A> </xref:System.Net.Sockets.NetworkStream> </xref:System.IO.FileAccess> Hvis du angir <xref:System.IO.FileAccess>, både metodekall er tillatt.</xref:System.IO.FileAccess>"
  example:
  - "The following code example creates a <xref:System.Net.Sockets.NetworkStream> with the ability to read and write to the <xref:System.Net.Sockets.Socket>. Ownership of the <xref:System.Net.Sockets.Socket> is given to this <xref:System.Net.Sockets.NetworkStream> by specifying `true` for the `ownsSocket` parameter.  \n  \n [!code-vb[NetworkStream_Async_SendAndReceive#1](~/add/codesnippet/visualbasic/db34d484-28c0-47ef-b5ca-_1.vb)]\n [!code-cs[NetworkStream_Async_SendAndReceive#1](~/add/codesnippet/csharp/db34d484-28c0-47ef-b5ca-_1.cs)]\n [!code-cpp[NetworkStream_Async_SendAndReceive#1](~/add/codesnippet/cpp/db34d484-28c0-47ef-b5ca-_1.cpp)]"
  syntax:
    content: public NetworkStream (System.Net.Sockets.Socket socket, System.IO.FileAccess access, bool ownsSocket);
    parameters:
    - id: socket
      type: System.Net.Sockets.Socket
      description: "Den <xref:System.Net.Sockets.Socket>som den <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> skal bruke til å sende og motta data.</xref:System.Net.Sockets.Socket>"
    - id: access
      type: System.IO.FileAccess
      description: "En bitvis kombinasjon av det <xref href=&quot;System.IO.FileAccess&quot;> </xref> verdier som angir hvilken type tilgang gitt til den <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> over den angitte <xref:System.Net.Sockets.Socket>.</xref:System.Net.Sockets.Socket>"
    - id: ownsSocket
      type: System.Boolean
      description: "Satt til <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref> å angi at den <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> vil ta eierskap over den <xref:System.Net.Sockets.Socket>; ellers <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>.</xref:System.Net.Sockets.Socket>"
  overload: System.Net.Sockets.NetworkStream.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>socket</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Den <code> socket </code> parameteren er ikke koblet til.       - eller - <xref:System.Net.Sockets.Socket.SocketType*>for den <code> socket </code> -parameteren er ikke &lt;xref:System.Net.Sockets.SocketType?displayProperty=fullName&gt;.</xref:System.Net.Sockets.Socket.SocketType*>       - eller - <code> socket </code> parameteren er i en ikke-blokkerende tilstand."
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  id: BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)
  nameWithType: NetworkStream.BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)
  fullName: System.Net.Sockets.NetworkStream.BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Starter en asynkron lesing fra den <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref>."
  remarks: "Metoden BeginRead starter asynkron lesing av data fra innkommende nettverket bufferne. Kaller metoden BeginRead gir deg muligheten til å motta data på en egen kjøring-tråd.       Du må opprette en tilbakeringing metode som implementerer den <xref:System.AsyncCallback>delegere og sende navnet til metoden BeginRead.</xref:System.AsyncCallback> På den svært minimums din `state` parameteren må inneholde <xref:System.Net.Sockets.NetworkStream>.</xref:System.Net.Sockets.NetworkStream> Fordi du vil hente mottatte data i tilbakeringing metoden, må du opprette en liten klasse eller -strukturen har en lesebuffer og annen nyttig informasjon. Sende forekomst structure eller klasse til metoden BeginRead via den `state` parameteren.       Metoden tilbakeringing må kalle den <xref:System.Net.Sockets.NetworkStream.EndRead%2A>metoden.</xref:System.Net.Sockets.NetworkStream.EndRead%2A> Når programmet kaller BeginRead, systemet skal vente før data mottas eller det oppstår en feil, og deretter systemet bruker en separat tråd til å utføre den angitte tilbakeringing metoden og blokker på <xref:System.Net.Sockets.NetworkStream.EndRead%2A>før det angitte <xref:System.Net.Sockets.NetworkStream>leser data eller oppstår det et unntak.</xref:System.Net.Sockets.NetworkStream> </xref:System.Net.Sockets.NetworkStream.EndRead%2A> Hvis du vil den opprinnelige tråden til å blokkere når du kaller BeginRead-metoden, kan du bruke den <xref:System.Threading.WaitHandle.WaitOne%2A>metoden.</xref:System.Threading.WaitHandle.WaitOne%2A> Kall <xref:System.Threading.EventWaitHandle.Set%2A>i metoden tilbakeringing når du ønsker den opprinnelige tråden fortsette kjøring.</xref:System.Threading.EventWaitHandle.Set%2A> Hvis du vil ha mer informasjon om hvordan du skriver tilbakeringing metoder, se [formidling representant som en tilbakeringing metode](~/add/includes/ajax-current-ext-md.md).       Metoden BeginRead leser så mye data som er tilgjengelig, opptil antall byte som er angitt av den `size` parameteren.      > [!NOTE] > Hvis du får en <xref:System.IO.IOException>må du kontrollere <xref:System.Exception.InnerException%2A>til å fastslå om det ble forårsaket av en <xref:System.Net.Sockets.SocketException>.</xref:System.Net.Sockets.SocketException> </xref:System.Exception.InnerException%2A> </xref:System.IO.IOException> Hvis dette er tilfellet, kan du bruke den <xref:System.Net.Sockets.SocketException.ErrorCode%2A>til å hente feilkoden og i Windows Sockets versjon 2 API feil kode dokumentasjonen i MSDN for en detaljert beskrivelse av feilen.</xref:System.Net.Sockets.SocketException.ErrorCode%2A>       Lese og skrive operasjoner kan utføres samtidig til en forekomst av den <xref:System.Net.Sockets.NetworkStream>klasse uten å måtte synkronisering.</xref:System.Net.Sockets.NetworkStream> Så lenge det finnes en unik tråd for skriveoperasjoner én unik tråd for leseoperasjoner, vil det være uten tvers-forstyrrelser mellom lese og skrive tråder, og ingen synkronisering er nødvendig."
  example:
  - "The following code example uses BeginRead to read data asynchronously from the network stream. The `myReadCallBack` method implements the <xref:System.AsyncCallback> delegate and is called by the system when BeginRead returns.  \n  \n [!code-vb[NetworkStream_Async_SendAndReceive#3](~/add/codesnippet/visualbasic/b2716ae9-7520-4d87-8b97-_1.vb)]\n [!code-cs[NetworkStream_Async_SendAndReceive#3](~/add/codesnippet/csharp/b2716ae9-7520-4d87-8b97-_1.cs)]\n [!code-cpp[NetworkStream_Async_SendAndReceive#3](~/add/codesnippet/cpp/b2716ae9-7520-4d87-8b97-_1.cpp)]"
  syntax:
    content: public override IAsyncResult BeginRead (byte[] buffer, int offset, int size, AsyncCallback callback, object state);
    parameters:
    - id: buffer
      type: System.Byte[]
      description: "En matrise av typen <xref:System.Byte>som plasseringen i minne til å lagre dataene fra den <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref>.</xref:System.Byte>"
    - id: offset
      type: System.Int32
      description: "Plasseringen i `buffer` til å begynne å lagre dataene."
    - id: size
      type: System.Int32
      description: "Antall byte ikke lese fra den <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref>."
    - id: callback
      type: System.AsyncCallback
      description: "Den <xref:System.AsyncCallback>representanten som kjøres når BeginRead er fullført.</xref:System.AsyncCallback>"
    - id: state
      type: System.Object
      description: "Et objekt som inneholder en brukerdefinert datatype."
    return:
      type: System.IAsyncResult
      description: "En <xref:System.IAsyncResult>som representerer asynkront kall.</xref:System.IAsyncResult>"
  overload: System.Net.Sockets.NetworkStream.BeginRead*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>buffer</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "Den <code> offset </code> parameteren er mindre enn 0.       - eller - <code> offset </code> parameteren er større enn lengden på den <code> buffer </code> parameteren.       - eller - <code> size </code> er mindre enn 0.       - eller - <code> size </code> er større enn lengden på <code> buffer </code> minus verdien for den <code> offset </code> parameteren."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Den underliggende <xref:System.Net.Sockets.Socket>er lukket.</xref:System.Net.Sockets.Socket>       - eller - det oppstod en feil under lesing fra nettverket.       - eller - det oppstod en feilen under tilgang til socket. Se kommentarer for mer informasjon."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Den <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> er lukket."
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  id: BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)
  nameWithType: NetworkStream.BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)
  fullName: System.Net.Sockets.NetworkStream.BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Starter en asynkron skriving til en dataflyt."
  remarks: "Metoden BeginWrite starter en asynkron sendingsoperasjonen til den eksterne verten. Kaller metoden BeginWrite gjør mulighet å sende data på en egen kjøring-tråd.       Du må opprette en tilbakeringing metode som implementerer den <xref:System.AsyncCallback>delegere og sende navnet til metoden BeginWrite.</xref:System.AsyncCallback> På den svært minimums din `state` parameteren må inneholde <xref:System.Net.Sockets.NetworkStream>.</xref:System.Net.Sockets.NetworkStream> Hvis tilbakeringing trenger mer informasjon, kan du opprette en liten klasse eller strukturen til å inneholde den <xref:System.Net.Sockets.NetworkStream>og den obligatoriske informasjonen.</xref:System.Net.Sockets.NetworkStream> Sende forekomst structure eller klasse til metoden BeginWrite via den `state` parameteren.       Tilbakekallingsmetoden skal implementere den <xref:System.Net.Sockets.NetworkStream.EndWrite%2A>metoden.</xref:System.Net.Sockets.NetworkStream.EndWrite%2A> Når programmet kaller BeginWrite, systemet bruker en separat tråd til å utføre den angitte tilbakeringing-metoden, og blokkerer på <xref:System.Net.Sockets.NetworkStream.EndWrite%2A>før den <xref:System.Net.Sockets.NetworkStream>sender antall byte som ble forespurt eller oppstår det et unntak.</xref:System.Net.Sockets.NetworkStream> </xref:System.Net.Sockets.NetworkStream.EndWrite%2A> Hvis du vil den opprinnelige tråden til å blokkere når du kaller BeginWrite-metoden, kan du bruke den <xref:System.Threading.WaitHandle.WaitOne%2A>metoden.</xref:System.Threading.WaitHandle.WaitOne%2A> Kall <xref:System.Threading.EventWaitHandle.Set%2A>i metoden tilbakeringing når du ønsker den opprinnelige tråden fortsette kjøring.</xref:System.Threading.EventWaitHandle.Set%2A> Hvis du vil ha mer informasjon om hvordan du skriver tilbakeringing metoder, se [formidling representant som en tilbakeringing metode](~/add/includes/ajax-current-ext-md.md).      > [!NOTE] > Hvis du får en <xref:System.IO.IOException>må du kontrollere <xref:System.Exception.InnerException%2A>til å fastslå om det ble forårsaket av en <xref:System.Net.Sockets.SocketException>.</xref:System.Net.Sockets.SocketException> </xref:System.Exception.InnerException%2A> </xref:System.IO.IOException> Hvis dette er tilfellet, kan du bruke den <xref:System.Net.Sockets.SocketException.ErrorCode%2A>til å hente feilkoden og i Windows Sockets versjon 2 API feil kode dokumentasjonen i MSDN for en detaljert beskrivelse av feilen.</xref:System.Net.Sockets.SocketException.ErrorCode%2A>       Lese og skrive operasjoner kan utføres samtidig til en forekomst av den <xref:System.Net.Sockets.NetworkStream>klasse uten å måtte synkronisering.</xref:System.Net.Sockets.NetworkStream> Så lenge det finnes en unik tråd for skriveoperasjoner én unik tråd for leseoperasjoner, vil det være uten tvers-forstyrrelser mellom lese og skrive tråder, og ingen synkronisering er nødvendig."
  example:
  - "The following code example uses BeginWrite to write data asynchronously to a network stream. The `myWriteCallBack` method implements the <xref:System.AsyncCallback> delegate and is called by the system when BeginWrite returns.  \n  \n [!code-vb[NetworkStream_Async_SendAndReceive#2](~/add/codesnippet/visualbasic/d3b03755-0183-42fc-98c1-_1.vb)]\n [!code-cs[NetworkStream_Async_SendAndReceive#2](~/add/codesnippet/csharp/d3b03755-0183-42fc-98c1-_1.cs)]\n [!code-cpp[NetworkStream_Async_SendAndReceive#2](~/add/codesnippet/cpp/d3b03755-0183-42fc-98c1-_1.cpp)]"
  syntax:
    content: public override IAsyncResult BeginWrite (byte[] buffer, int offset, int size, AsyncCallback callback, object state);
    parameters:
    - id: buffer
      type: System.Byte[]
      description: "En matrise av typen <xref:System.Byte>som inneholder dataene for å skrive til den <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref>.</xref:System.Byte>"
    - id: offset
      type: System.Int32
      description: "Plasseringen i `buffer` til å begynne å sende dataene."
    - id: size
      type: System.Int32
      description: "Antall byte ikke skrive til den <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref>."
    - id: callback
      type: System.AsyncCallback
      description: "Den <xref:System.AsyncCallback>representanten som kjøres når BeginWrite er fullført.</xref:System.AsyncCallback>"
    - id: state
      type: System.Object
      description: "Et objekt som inneholder en brukerdefinert datatype."
    return:
      type: System.IAsyncResult
      description: "En <xref:System.IAsyncResult>som representerer asynkront kall.</xref:System.IAsyncResult>"
  overload: System.Net.Sockets.NetworkStream.BeginWrite*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>buffer</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "Den <code> offset </code> parameteren er mindre enn 0.       - eller - <code> offset </code> parameteren er større enn lengden på <code> buffer </code>.       - eller - <code> size </code> parameteren er mindre enn 0.       - eller - <code> size </code> parameteren er større enn lengden på <code> buffer </code> minus verdien for den <code> offset </code> parameteren."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Den underliggende <xref:System.Net.Sockets.Socket>er lukket.</xref:System.Net.Sockets.Socket>       - eller - det oppstod en feil under skriving til nettverket.       - eller - det oppstod en feilen under tilgang til socket. Se kommentarer for mer informasjon."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Den <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> er lukket."
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.CanRead
  id: CanRead
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: CanRead
  nameWithType: NetworkStream.CanRead
  fullName: System.Net.Sockets.NetworkStream.CanRead
  type: Property
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Henter en verdi som angir om den <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> støtter lesing."
  remarks: "Hvis CanRead `true`, <xref:System.Net.Sockets.NetworkStream>tillater kall til den <xref:System.Net.Sockets.NetworkStream.Read%2A>metoden.</xref:System.Net.Sockets.NetworkStream.Read%2A> </xref:System.Net.Sockets.NetworkStream> Angi den riktige <xref:System.IO.FileAccess>listes opp verdien i konstruktøren for å angi lese og writability for <xref:System.Net.Sockets.NetworkStream>.</xref:System.Net.Sockets.NetworkStream> </xref:System.IO.FileAccess> Egenskapen CanRead angis når den <xref:System.Net.Sockets.NetworkStream>er initialisert.</xref:System.Net.Sockets.NetworkStream>"
  example:
  - "The following code example checks CanRead to verify that the <xref:System.Net.Sockets.NetworkStream> is readable. It then performs a read operation on the <xref:System.Net.Sockets.NetworkStream>.  \n  \n [!code-vb[NetworkStream_Synch_SendAndReceive#4](~/add/codesnippet/visualbasic/p-system.net.sockets.net_6_1.vb)]\n [!code-cpp[NetworkStream_Synch_SendAndReceive#4](~/add/codesnippet/cpp/p-system.net.sockets.net_6_1.cpp)]\n [!code-cs[NetworkStream_Synch_SendAndReceive#4](~/add/codesnippet/csharp/p-system.net.sockets.net_6_1.cs)]"
  syntax:
    content: public override bool CanRead { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Hvis kan lese data fra dataflyten; Ellers <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>. Standardverdien er <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>."
  overload: System.Net.Sockets.NetworkStream.CanRead*
  exceptions: []
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.CanSeek
  id: CanSeek
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: CanSeek
  nameWithType: NetworkStream.CanSeek
  fullName: System.Net.Sockets.NetworkStream.CanSeek
  type: Property
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Henter en verdi som angir om Dataflyten støtter søking. Denne egenskapen støttes ikke. Denne egenskapen returnerer alltid <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  syntax:
    content: public override bool CanSeek { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>i alle tilfellene tyde på at <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> kan ikke søke et spesifikt sted i dataflyten."
  overload: System.Net.Sockets.NetworkStream.CanSeek*
  exceptions: []
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.CanTimeout
  id: CanTimeout
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: CanTimeout
  nameWithType: NetworkStream.CanTimeout
  fullName: System.Net.Sockets.NetworkStream.CanTimeout
  type: Property
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Angir om tidsavbrudd egenskaper brukes for <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref>."
  remarks: "Denne egenskapen finnes fordi den er arvet fra <xref:System.IO.Stream>.</xref:System.IO.Stream>"
  syntax:
    content: public override bool CanTimeout { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>i alle tilfeller."
  overload: System.Net.Sockets.NetworkStream.CanTimeout*
  exceptions: []
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.CanWrite
  id: CanWrite
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: CanWrite
  nameWithType: NetworkStream.CanWrite
  fullName: System.Net.Sockets.NetworkStream.CanWrite
  type: Property
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Henter en verdi som angir om den <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> støtter skriving."
  remarks: "Hvis CanWrite `true`, <xref:System.Net.Sockets.NetworkStream>tillater kall til den <xref:System.Net.Sockets.NetworkStream.Write%2A>metoden.</xref:System.Net.Sockets.NetworkStream.Write%2A> </xref:System.Net.Sockets.NetworkStream> Angi den riktige <xref:System.IO.FileAccess>listes opp verdien i konstruktøren for å angi lese og writability for <xref:System.Net.Sockets.NetworkStream>.</xref:System.Net.Sockets.NetworkStream> </xref:System.IO.FileAccess> Egenskapen CanWrite angis når den <xref:System.Net.Sockets.NetworkStream>er initialisert.</xref:System.Net.Sockets.NetworkStream>"
  example:
  - "The following code example checks CanWrite to verify that the <xref:System.Net.Sockets.NetworkStream> is writable. It then performs a write operation on the <xref:System.Net.Sockets.NetworkStream>.  \n  \n [!code-vb[NetworkStream_Synch_SendAndReceive#3](~/add/codesnippet/visualbasic/p-system.net.sockets.net_0_1.vb)]\n [!code-cpp[NetworkStream_Synch_SendAndReceive#3](~/add/codesnippet/cpp/p-system.net.sockets.net_0_1.cpp)]\n [!code-cs[NetworkStream_Synch_SendAndReceive#3](~/add/codesnippet/csharp/p-system.net.sockets.net_0_1.cs)]"
  syntax:
    content: public override bool CanWrite { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Hvis kan skrive data til den <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref>; ellers <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>. Standardverdien er <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>."
  overload: System.Net.Sockets.NetworkStream.CanWrite*
  exceptions: []
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.Close(System.Int32)
  id: Close(System.Int32)
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: Close(Int32)
  nameWithType: NetworkStream.Close(Int32)
  fullName: System.Net.Sockets.NetworkStream.Close(Int32)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Lukker det <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> etter å ha ventet den angitte tiden for å tillate at data sendes."
  remarks: "Metoden Close frigjør både uforvaltede og behandlede ressurser som er knyttet til <xref:System.Net.Sockets.NetworkStream>.</xref:System.Net.Sockets.NetworkStream> Hvis den <xref:System.Net.Sockets.NetworkStream>eier den underliggende <xref:System.Net.Sockets.Socket>, den er lukket samt.</xref:System.Net.Sockets.Socket> </xref:System.Net.Sockets.NetworkStream>       Hvis en <xref:System.Net.Sockets.NetworkStream>er knyttet til en <xref:System.Net.Sockets.TcpClient>metoden Close lukkes TCP-tilkobling, men ikke Kast tilknyttede <xref:System.Net.Sockets.TcpClient>.</xref:System.Net.Sockets.TcpClient> </xref:System.Net.Sockets.TcpClient> </xref:System.Net.Sockets.NetworkStream>"
  syntax:
    content: public void Close (int timeout);
    parameters:
    - id: timeout
      type: System.Int32
      description: "En 32-biters heltall med fortegn som angir antall millisekunder det skal ventes sende gjenværende data før du lukker."
  overload: System.Net.Sockets.NetworkStream.Close*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "Den <code> timeout </code> parameteren er mindre enn -1."
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.DataAvailable
  id: DataAvailable
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: DataAvailable
  nameWithType: NetworkStream.DataAvailable
  fullName: System.Net.Sockets.NetworkStream.DataAvailable
  type: Property
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Henter en verdi som angir om data er tilgjengelig på den <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> leses."
  remarks: "Bruk DataAvailable-egenskapen til å finne ut om dataene er klar til å lese. Hvis DataAvailable `true`, et kall til <xref:System.Net.Sockets.NetworkStream.Read%2A>returnerer umiddelbart.</xref:System.Net.Sockets.NetworkStream.Read%2A> Hvis den eksterne verten avsluttes eller lukker tilkoblingen, kan DataAvailable throw <xref:System.Net.Sockets.SocketException>.</xref:System.Net.Sockets.SocketException>"
  example:
  - "The following code example reads from the <xref:System.Net.Sockets.NetworkStream> as long as data is available.  \n  \n [!code-vb[NetworkStream_Synch_SendAndReceive#4](~/add/codesnippet/visualbasic/p-system.net.sockets.net_2_1.vb)]\n [!code-cpp[NetworkStream_Synch_SendAndReceive#4](~/add/codesnippet/cpp/p-system.net.sockets.net_2_1.cpp)]\n [!code-cs[NetworkStream_Synch_SendAndReceive#4](~/add/codesnippet/csharp/p-system.net.sockets.net_2_1.cs)]"
  syntax:
    content: public virtual bool DataAvailable { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Hvis data er tilgjengelig for dataflyten leses; Ellers <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Net.Sockets.NetworkStream.DataAvailable*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Den <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> er lukket."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Den underliggende <xref:System.Net.Sockets.Socket>er lukket.</xref:System.Net.Sockets.Socket>"
  - type: System.Net.Sockets.SocketException
    commentId: T:System.Net.Sockets.SocketException
    description: "Bruk av &lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt; til å hente feilkoden og i Windows Sockets versjon 2 API feil kode dokumentasjonen i MSDN for en detaljert beskrivelse av feilen."
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.Dispose(System.Boolean)
  id: Dispose(System.Boolean)
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: Dispose(Boolean)
  nameWithType: NetworkStream.Dispose(Boolean)
  fullName: System.Net.Sockets.NetworkStream.Dispose(Boolean)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Frigir uforvaltede ressursene som brukes av den <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> og eventuelt frigir administrerte ressurser."
  remarks: "Denne metoden kalles av offentlig `Dispose` metoden og <xref:System.Object.Finalize%2A>metode.</xref:System.Object.Finalize%2A> `Dispose`Aktiverer den beskyttede `Dispose(Boolean)` metoden med den `disposing` parameteren satt til `true`. <xref:System.Object.Finalize%2A>aktiverer `Dispose` med `disposing` satt til `false`.</xref:System.Object.Finalize%2A>       Når den `disposing` parameteren er `true`, denne metoden Frigjør alle ressurser holdes av administrerte objekter som denne <xref:System.Net.Sockets.NetworkStream>referanser.</xref:System.Net.Sockets.NetworkStream> Denne metoden starter den `Dispose` metode for hver referert objekt."
  syntax:
    content: protected override void Dispose (bool disposing);
    parameters:
    - id: disposing
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>å frigjøre både administrerte og uforvaltede ressurser. <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> frigi bare uforvaltede ressurser."
  overload: System.Net.Sockets.NetworkStream.Dispose*
  exceptions: []
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.EndRead(System.IAsyncResult)
  id: EndRead(System.IAsyncResult)
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: EndRead(IAsyncResult)
  nameWithType: NetworkStream.EndRead(IAsyncResult)
  fullName: System.Net.Sockets.NetworkStream.EndRead(IAsyncResult)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Behandler slutten av en asynkron lesing."
  remarks: "EndRead-metoden fullfører asynkrone leseoperasjonen startet i den <xref:System.Net.Sockets.NetworkStream.BeginRead%2A>metoden.</xref:System.Net.Sockets.NetworkStream.BeginRead%2A>       Før du kaller <xref:System.Net.Sockets.NetworkStream.BeginRead%2A>, må du opprette en tilbakeringing metode som implementerer den <xref:System.AsyncCallback>delegere.</xref:System.AsyncCallback> </xref:System.Net.Sockets.NetworkStream.BeginRead%2A> Denne tilbakeringing-metoden utføres i en separat tråd og kalles av systemet etter <xref:System.Net.Sockets.NetworkStream.BeginRead%2A>returnerer.</xref:System.Net.Sockets.NetworkStream.BeginRead%2A> Metoden tilbakeringing må godta de <xref:System.IAsyncResult>returnert fra den <xref:System.Net.Sockets.NetworkStream.BeginRead%2A>metoden som en parameter.</xref:System.Net.Sockets.NetworkStream.BeginRead%2A> </xref:System.IAsyncResult>       I metoden tilbakeringing kalle den <xref:System.IAsyncResult.AsyncState%2A>for den <xref:System.IAsyncResult>ikke hente tilstanden-objektet som ble sendt til den <xref:System.Net.Sockets.NetworkStream.BeginRead%2A>metoden.</xref:System.Net.Sockets.NetworkStream.BeginRead%2A> </xref:System.IAsyncResult> </xref:System.IAsyncResult.AsyncState%2A> Trekk ut motta <xref:System.Net.Sockets.NetworkStream>fra dette tilstand-objektet.</xref:System.Net.Sockets.NetworkStream> Etter henting av <xref:System.Net.Sockets.NetworkStream>, kalle metoden EndRead for å fullføre leseoperasjonen ble og returnere antall byte som leses.</xref:System.Net.Sockets.NetworkStream>       Blokker med EndRead-metoden før data er tilgjengelig. Metoden EndRead leser så mye data som er tilgjengelig opptil antall byte som er angitt i den `size` -parameteren for den <xref:System.Net.Sockets.NetworkStream.BeginRead%2A>metoden.</xref:System.Net.Sockets.NetworkStream.BeginRead%2A> Hvis den eksterne verten avsluttes den <xref:System.Net.Sockets.Socket>tilkoblingen og alle tilgjengelige data er mottatt, metoden EndRead umiddelbart er fullført, og returnerer null byte.</xref:System.Net.Sockets.Socket>       For å få den mottatte data, kan du kalle den <xref:System.IAsyncResult.AsyncState%2A>for den <xref:System.IAsyncResult>, og Pakk ut bufferen finnes i de resulterende tilstand-objektet.</xref:System.IAsyncResult> </xref:System.IAsyncResult.AsyncState%2A>      > [!NOTE] > Hvis du får en <xref:System.IO.IOException>må du kontrollere <xref:System.Exception.InnerException%2A>til å fastslå om det ble forårsaket av en <xref:System.Net.Sockets.SocketException>.</xref:System.Net.Sockets.SocketException> </xref:System.Exception.InnerException%2A> </xref:System.IO.IOException> Hvis dette er tilfellet, kan du bruke den <xref:System.Net.Sockets.SocketException.ErrorCode%2A>til å hente feilkoden og i Windows Sockets versjon 2 API feil kode dokumentasjonen i MSDN for en detaljert beskrivelse av feilen.</xref:System.Net.Sockets.SocketException.ErrorCode%2A>"
  example:
  - "In the following code example, `myReadCallback` is provided to <xref:System.Net.Sockets.NetworkStream.BeginRead%2A> as the callback method. EndRead is implemented in `myReadCallback` to complete the asynchronous read call started by <xref:System.Net.Sockets.NetworkStream.BeginRead%2A>.  \n  \n [!code-vb[NetworkStream_Async_SendAndReceive#5](~/add/codesnippet/visualbasic/m-system.net.sockets.net_2_1.vb)]\n [!code-cs[NetworkStream_Async_SendAndReceive#5](~/add/codesnippet/csharp/m-system.net.sockets.net_2_1.cs)]\n [!code-cpp[NetworkStream_Async_SendAndReceive#5](~/add/codesnippet/cpp/m-system.net.sockets.net_2_1.cpp)]"
  syntax:
    content: public override int EndRead (IAsyncResult asyncResult);
    parameters:
    - id: asyncResult
      type: System.IAsyncResult
      description: "En <xref:System.IAsyncResult>som representerer et asynkront kall.</xref:System.IAsyncResult>"
    return:
      type: System.Int32
      description: "Antall byte lest fra den <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref>."
  overload: System.Net.Sockets.NetworkStream.EndRead*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <code>asyncResult</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Den underliggende <xref:System.Net.Sockets.Socket>er lukket.</xref:System.Net.Sockets.Socket>       - eller - det oppstod en feilen under tilgang til socket. Se kommentarer for mer informasjon."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Den <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> er lukket."
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.EndWrite(System.IAsyncResult)
  id: EndWrite(System.IAsyncResult)
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: EndWrite(IAsyncResult)
  nameWithType: NetworkStream.EndWrite(IAsyncResult)
  fullName: System.Net.Sockets.NetworkStream.EndWrite(IAsyncResult)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Behandler slutten av en asynkron skriving."
  remarks: "EndWrite er fullført asynkrone sendeoperasjonen startet i <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A>.</xref:System.Net.Sockets.NetworkStream.BeginWrite%2A>       Før du kaller <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A>, må du opprette en tilbakeringing metode som implementerer den <xref:System.AsyncCallback>delegere.</xref:System.AsyncCallback> </xref:System.Net.Sockets.NetworkStream.BeginWrite%2A> Denne tilbakeringing-metoden utføres i en separat tråd og kalles av systemet etter <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A>returnerer.</xref:System.Net.Sockets.NetworkStream.BeginWrite%2A> Metoden tilbakeringing må godta de <xref:System.IAsyncResult>returnert fra den <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A>metoden som en parameter.</xref:System.Net.Sockets.NetworkStream.BeginWrite%2A> </xref:System.IAsyncResult>       I metoden tilbakeringing kalle den <xref:System.IAsyncResult.AsyncState%2A>for den `IAsyncResult` parameter for å hente <xref:System.Net.Sockets.NetworkStream>.</xref:System.Net.Sockets.NetworkStream> </xref:System.IAsyncResult.AsyncState%2A> Etter henting av <xref:System.Net.Sockets.NetworkStream>, kan du kalle metoden EndWrite for å fullføre sendeoperasjonen og returnere antall byte sendt ble.</xref:System.Net.Sockets.NetworkStream>       Blokker med EndWrite-metoden til ønsket antall byte som er sendt.      > [!NOTE] > Hvis du får en <xref:System.IO.IOException>må du kontrollere <xref:System.Exception.InnerException%2A>til å fastslå om det ble forårsaket av en <xref:System.Net.Sockets.SocketException>.</xref:System.Net.Sockets.SocketException> </xref:System.Exception.InnerException%2A> </xref:System.IO.IOException> Hvis dette er tilfellet, kan du bruke den <xref:System.Net.Sockets.SocketException.ErrorCode%2A>til å hente feilkoden og i Windows Sockets versjon 2 API feil kode dokumentasjonen i MSDN for en detaljert beskrivelse av feilen.</xref:System.Net.Sockets.SocketException.ErrorCode%2A>"
  example:
  - "In the following code example, `myWriteCallback` is provided to <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A> as the callback method. EndWrite is implemented in `myWriteCallback` to complete the asynchronous write call started by <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A>.  \n  \n [!code-vb[NetworkStream_Async_SendAndReceive#4](~/add/codesnippet/visualbasic/m-system.net.sockets.net_3_1.vb)]\n [!code-cs[NetworkStream_Async_SendAndReceive#4](~/add/codesnippet/csharp/m-system.net.sockets.net_3_1.cs)]\n [!code-cpp[NetworkStream_Async_SendAndReceive#4](~/add/codesnippet/cpp/m-system.net.sockets.net_3_1.cpp)]"
  syntax:
    content: public override void EndWrite (IAsyncResult asyncResult);
    parameters:
    - id: asyncResult
      type: System.IAsyncResult
      description: "Den <xref:System.IAsyncResult>som representerer asynkront kall.</xref:System.IAsyncResult>"
  overload: System.Net.Sockets.NetworkStream.EndWrite*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>asyncResult</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Den underliggende <xref:System.Net.Sockets.Socket>er lukket.</xref:System.Net.Sockets.Socket>       - eller - det oppstod en feilen under skriving til nettverket.       - eller - det oppstod en feilen under tilgang til socket. Se kommentarer for mer informasjon."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Den <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> er lukket."
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.Finalize
  id: Finalize
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: Finalize()
  nameWithType: NetworkStream.Finalize()
  fullName: System.Net.Sockets.NetworkStream.Finalize()
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Frigir alle ressursene som brukes av den <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref>."
  remarks: "Denne metoden overstyrer <xref:System.Object.Finalize%2A?displayProperty=fullName>.</xref:System.Object.Finalize%2A?displayProperty=fullName> Applikasjons-koden kan ikke kalle denne metoden. et objekts <xref:System.Object.Finalize%2A>metode startes automatisk under datasanering, med mindre finalization av saneringsoppsamlingen er deaktivert av et kall til den <xref:System.GC.SuppressFinalize%2A?displayProperty=fullName>metoden.</xref:System.GC.SuppressFinalize%2A?displayProperty=fullName> </xref:System.Object.Finalize%2A>       Du finner mer informasjon om hvordan du bruker metoden Fullfør [fullføre metoder og destruktører](http://msdn.microsoft.com/en-us/fd376774-1643-499b-869e-9546a3aeea70), [Rydder opp uforvaltede ressurser](~/add/includes/ajax-current-ext-md.md), og [overstyrer metoden fullføre](http://msdn.microsoft.com/en-us/8026cb68-fe93-43fc-96c1-c09ad7d64cd3)."
  syntax:
    content: ~NetworkStream ();
    parameters: []
  overload: System.Net.Sockets.NetworkStream.Finalize*
  exceptions: []
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.Flush
  id: Flush
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: Flush()
  nameWithType: NetworkStream.Flush()
  fullName: System.Net.Sockets.NetworkStream.Flush()
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Tømmer data fra dataflyten. Denne metoden er reservert for fremtidig bruk."
  remarks: "Metoden tømming implementerer den <xref:System.IO.Stream.Flush%2A?displayProperty=fullName>metoden; imidlertid fordi <xref:System.Net.Sockets.NetworkStream>er ikke bufres den har ingen innvirkning på nettverket flyter.</xref:System.Net.Sockets.NetworkStream> </xref:System.IO.Stream.Flush%2A?displayProperty=fullName> Kaller metoden tømming ikke Iverksett et unntak."
  syntax:
    content: public override void Flush ();
    parameters: []
  overload: System.Net.Sockets.NetworkStream.Flush*
  exceptions: []
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.FlushAsync(System.Threading.CancellationToken)
  id: FlushAsync(System.Threading.CancellationToken)
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: FlushAsync(CancellationToken)
  nameWithType: NetworkStream.FlushAsync(CancellationToken)
  fullName: System.Net.Sockets.NetworkStream.FlushAsync(CancellationToken)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Tømmer data fra dataflyten som en asynkron operasjon."
  remarks: "Denne operasjonen blokkere ikke. Det returnerte <xref:System.Threading.Tasks.Task>objektet fullfører etter at dataene har blitt tømt fra dataflyten for den <xref:System.Net.Sockets.NetworkStream>forekomsten.</xref:System.Net.Sockets.NetworkStream> </xref:System.Threading.Tasks.Task>"
  syntax:
    content: public override System.Threading.Tasks.Task FlushAsync (System.Threading.CancellationToken cancellationToken);
    parameters:
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: "Et avbryte token brukes til å overføre varsling at denne operasjonen kan avbrytes."
    return:
      type: System.Threading.Tasks.Task
      description: "Returnerer <xref:System.Threading.Tasks.Task>.</xref:System.Threading.Tasks.Task>       Oppgaveobjektet som representerer den asynkrone operasjonen."
  overload: System.Net.Sockets.NetworkStream.FlushAsync*
  exceptions: []
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.Length
  id: Length
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: Length
  nameWithType: NetworkStream.Length
  fullName: System.Net.Sockets.NetworkStream.Length
  type: Property
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Henter lengden på data som er tilgjengelige for dataflyten. Denne egenskapen støttes ikke og oppstår alltid <xref:System.NotSupportedException>.</xref:System.NotSupportedException>"
  syntax:
    content: public override long Length { get; }
    return:
      type: System.Int64
      description: "Lengden på dataene i dataflyten."
  overload: System.Net.Sockets.NetworkStream.Length*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Bruken av denne egenskapen."
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.Position
  id: Position
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: Position
  nameWithType: NetworkStream.Position
  fullName: System.Net.Sockets.NetworkStream.Position
  type: Property
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Henter eller angir posisjonen i dataflyten. Denne egenskapen støttes ikke og oppstår alltid <xref:System.NotSupportedException>.</xref:System.NotSupportedException>"
  syntax:
    content: public override long Position { get; set; }
    return:
      type: System.Int64
      description: "Gjeldende plassering i dataflyten."
  overload: System.Net.Sockets.NetworkStream.Position*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Bruken av denne egenskapen."
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.Read(System.Byte[],System.Int32,System.Int32)
  id: Read(System.Byte[],System.Int32,System.Int32)
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: Read(Byte[],Int32,Int32)
  nameWithType: NetworkStream.Read(Byte[],Int32,Int32)
  fullName: System.Net.Sockets.NetworkStream.Read(Byte[],Int32,Int32)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Viser data fra den <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref>."
  remarks: "Denne metoden viser data i den `buffer` parameteren og returnerer antall byte som ble lest. Hvis ingen data er tilgjengelig for lesing, returneres lese 0. Leseoperasjon leser så mye data som er tilgjengelig, opptil antall byte som er angitt av den `size` parameteren. Hvis den eksterne verten slås av tilkoblingen, og alle tilgjengelige data er mottatt Read-metoden fullfører umiddelbart, og returnerer null byte.      > [!NOTE] > Kontroller om det <xref:System.Net.Sockets.NetworkStream>kan leses ved å kalle den <xref:System.Net.Sockets.NetworkStream.CanRead%2A>egenskapen.</xref:System.Net.Sockets.NetworkStream.CanRead%2A> </xref:System.Net.Sockets.NetworkStream> Hvis du prøver å lese fra en <xref:System.Net.Sockets.NetworkStream>som ikke kan leses, får du en <xref:System.IO.IOException>.</xref:System.IO.IOException> </xref:System.Net.Sockets.NetworkStream>      > [!NOTE] > Hvis du får en <xref:System.IO.IOException>må du kontrollere <xref:System.Exception.InnerException%2A>til å fastslå om det ble forårsaket av en <xref:System.Net.Sockets.SocketException>.</xref:System.Net.Sockets.SocketException> </xref:System.Exception.InnerException%2A> </xref:System.IO.IOException> Hvis dette er tilfellet, kan du bruke den <xref:System.Net.Sockets.SocketException.ErrorCode%2A>til å hente feilkoden og i Windows Sockets versjon 2 API feil kode dokumentasjonen i MSDN for en detaljert beskrivelse av feilen.</xref:System.Net.Sockets.SocketException.ErrorCode%2A>"
  example:
  - "The following code example uses <xref:System.Net.Sockets.NetworkStream.DataAvailable%2A> to determine if data is available to be read. If data is available, it reads from the <xref:System.Net.Sockets.NetworkStream>.  \n  \n [!code-vb[NetworkStream_Synch_SendAndReceive#4](~/add/codesnippet/visualbasic/m-system.net.sockets.net_1_1.vb)]\n [!code-cpp[NetworkStream_Synch_SendAndReceive#4](~/add/codesnippet/cpp/m-system.net.sockets.net_1_1.cpp)]\n [!code-cs[NetworkStream_Synch_SendAndReceive#4](~/add/codesnippet/csharp/m-system.net.sockets.net_1_1.cs)]"
  syntax:
    content: public override int Read (byte[] buffer, int offset, int size);
    parameters:
    - id: buffer
      type: System.Byte[]
      description: "En matrise av typen <xref:System.Byte>som plasseringen i minne til å lagre dataene fra den <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref>.</xref:System.Byte>"
    - id: offset
      type: System.Int32
      description: "Plasseringen i `buffer` til å begynne å lagre data til."
    - id: size
      type: System.Int32
      description: "Antall byte ikke lese fra den <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref>."
    return:
      type: System.Int32
      description: "Antall byte lest fra den <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref>."
  overload: System.Net.Sockets.NetworkStream.Read*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>buffer</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "Den <code> offset </code> parameteren er mindre enn 0.       - eller - <code> offset </code> parameteren er større enn lengden på <code> buffer </code>.       - eller - <code> size </code> parameteren er mindre enn 0.       - eller - <code> size </code> parameteren er større enn lengden på <code> buffer </code> minus verdien for den <code> offset </code> parameteren.       - eller - det oppstod en feilen under tilgang til socket. Se kommentarer for mer informasjon."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Den underliggende <xref:System.Net.Sockets.Socket>er lukket.</xref:System.Net.Sockets.Socket>"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Den <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> er lukket.       - eller - det er en feil under lesing fra nettverket."
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.Readable
  id: Readable
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: Readable
  nameWithType: NetworkStream.Readable
  fullName: System.Net.Sockets.NetworkStream.Readable
  type: Property
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Henter eller angir en verdi som angir om den <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> kan leses."
  remarks: "Du må være utledet fra den <xref:System.Net.Sockets.NetworkStream>klassen for å bruke egenskapen lesbar.</xref:System.Net.Sockets.NetworkStream> Hvis Readable `true`, <xref:System.Net.Sockets.NetworkStream>tillater kall til den <xref:System.Net.Sockets.NetworkStream.Read%2A>metoden.</xref:System.Net.Sockets.NetworkStream.Read%2A> </xref:System.Net.Sockets.NetworkStream> Du kan også angi om en <xref:System.Net.Sockets.NetworkStream>kan leses ved å kontrollere den allment tilgjengelige <xref:System.Net.Sockets.NetworkStream.CanRead%2A>egenskapen.</xref:System.Net.Sockets.NetworkStream.CanRead%2A> </xref:System.Net.Sockets.NetworkStream>       Egenskapen lesbar angis når den <xref:System.Net.Sockets.NetworkStream>er initialisert.</xref:System.Net.Sockets.NetworkStream>"
  example:
  - "In the following code example, the `CanCommunicate` property checks the Readable property to determine if the <xref:System.Net.Sockets.NetworkStream> is readable.  \n  \n [!code-cpp[NetworkStream_Protected_Members#1](~/add/codesnippet/cpp/p-system.net.sockets.net_7_1.cpp)]\n [!code-cs[NetworkStream_Protected_Members#1](~/add/codesnippet/csharp/p-system.net.sockets.net_7_1.cs)]\n [!code-vb[NetworkStream_Protected_Members#1](~/add/codesnippet/visualbasic/p-system.net.sockets.net_7_1.vb)]"
  syntax:
    content: protected bool Readable { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>å angi at den <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> kan være skrivebeskyttet; ellers, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>. Standardverdien er <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>."
  overload: System.Net.Sockets.NetworkStream.Readable*
  exceptions: []
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.ReadTimeout
  id: ReadTimeout
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: ReadTimeout
  nameWithType: NetworkStream.ReadTimeout
  fullName: System.Net.Sockets.NetworkStream.ReadTimeout
  type: Property
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Henter eller angir hvor lang tid som en leseoperasjonen som venter på at data."
  remarks: "Hvis leseoperasjonen ikke fullfører innen angitt av denne egenskapen, oppstår leseoperasjonen en <xref:System.IO.IOException>.</xref:System.IO.IOException>      > [!NOTE] > Denne egenskapen påvirker bare synkron leseoperasjoner utføres ved kall av <xref:System.Net.Sockets.NetworkStream.Read%2A>metode.</xref:System.Net.Sockets.NetworkStream.Read%2A> Denne egenskapen påvirker ikke asynkron leser utføres ved kall fra den <xref:System.Net.Sockets.NetworkStream.BeginRead%2A>metoden.</xref:System.Net.Sockets.NetworkStream.BeginRead%2A>"
  example:
  - "The following code example sets the read time-out for a network stream to 10 milliseconds.  \n  \n [!code-cs[NCLTcpClientSync#2](~/add/codesnippet/csharp/p-system.net.sockets.net_4_1.cs)]"
  syntax:
    content: public override int ReadTimeout { get; set; }
    return:
      type: System.Int32
      description: "En <xref:System.Int32>som angir hvor lang tid, i millisekunder det skal gå før en leseoperasjon mislykkes.</xref:System.Int32> Standardverdien <xref:System.Threading.Timeout.Infinite>, angir leseoperasjonen er tidsavbrutt.</xref:System.Threading.Timeout.Infinite>"
  overload: System.Net.Sockets.NetworkStream.ReadTimeout*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "Den angitte verdien er mindre enn eller lik null, og er ikke <xref:System.Threading.Timeout.Infinite>.</xref:System.Threading.Timeout.Infinite>"
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.Seek(System.Int64,System.IO.SeekOrigin)
  id: Seek(System.Int64,System.IO.SeekOrigin)
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: Seek(Int64,SeekOrigin)
  nameWithType: NetworkStream.Seek(Int64,SeekOrigin)
  fullName: System.Net.Sockets.NetworkStream.Seek(Int64,SeekOrigin)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Angir gjeldende plassering i dataflyten for den angitte verdien. Denne metoden støttes ikke og oppstår alltid <xref:System.NotSupportedException>.</xref:System.NotSupportedException>"
  syntax:
    content: public override long Seek (long offset, System.IO.SeekOrigin origin);
    parameters:
    - id: offset
      type: System.Int64
      description: "Denne parameteren brukes ikke."
    - id: origin
      type: System.IO.SeekOrigin
      description: "Denne parameteren brukes ikke."
    return:
      type: System.Int64
      description: "Plasseringen i dataflyten."
  overload: System.Net.Sockets.NetworkStream.Seek*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Bruken av denne egenskapen."
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.SetLength(System.Int64)
  id: SetLength(System.Int64)
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: SetLength(Int64)
  nameWithType: NetworkStream.SetLength(Int64)
  fullName: System.Net.Sockets.NetworkStream.SetLength(Int64)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Angir lengden på dataflyten. Denne metoden oppstår alltid <xref:System.NotSupportedException>.</xref:System.NotSupportedException>"
  syntax:
    content: public override void SetLength (long value);
    parameters:
    - id: value
      type: System.Int64
      description: "Denne parameteren brukes ikke."
  overload: System.Net.Sockets.NetworkStream.SetLength*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Bruken av denne egenskapen."
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.Socket
  id: Socket
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: Socket
  nameWithType: NetworkStream.Socket
  fullName: System.Net.Sockets.NetworkStream.Socket
  type: Property
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Henter den underliggende <xref:System.Net.Sockets.Socket>.</xref:System.Net.Sockets.Socket>"
  remarks: "Klasser som er avledet fra <xref:System.Net.Sockets.NetworkStream>kan bruke denne egenskapen for å få den underliggende <xref:System.Net.Sockets.Socket>.</xref:System.Net.Sockets.Socket> </xref:System.Net.Sockets.NetworkStream> Bruk den underliggende <xref:System.Net.Sockets.Socket>returnert fra egenskapen Socket Hvis du trenger tilgang enn det som <xref:System.Net.Sockets.NetworkStream>gir.</xref:System.Net.Sockets.NetworkStream> </xref:System.Net.Sockets.Socket>      > [!NOTE] > Denne egenskapen er kun tilgjengelig gjennom denne klasse eller en avledet."
  example:
  - "The following code example retrieves the underlying <xref:System.Net.Sockets.Socket> to verify an active connection.  \n  \n [!code-cpp[NetworkStream_Protected_Members#1](~/add/codesnippet/cpp/p-system.net.sockets.net_3_1.cpp)]\n [!code-cs[NetworkStream_Protected_Members#1](~/add/codesnippet/csharp/p-system.net.sockets.net_3_1.cs)]\n [!code-vb[NetworkStream_Protected_Members#1](~/add/codesnippet/visualbasic/p-system.net.sockets.net_3_1.vb)]"
  syntax:
    content: protected System.Net.Sockets.Socket Socket { get; }
    return:
      type: System.Net.Sockets.Socket
      description: "En <xref:System.Net.Sockets.Socket>som representerer underliggende nettverkstilkoblingen.</xref:System.Net.Sockets.Socket>"
  overload: System.Net.Sockets.NetworkStream.Socket*
  exceptions: []
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.Write(System.Byte[],System.Int32,System.Int32)
  id: Write(System.Byte[],System.Int32,System.Int32)
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: Write(Byte[],Int32,Int32)
  nameWithType: NetworkStream.Write(Byte[],Int32,Int32)
  fullName: System.Net.Sockets.NetworkStream.Write(Byte[],Int32,Int32)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Skriver data til den <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref>."
  remarks: "Write-metoden starter på den angitte `offset` og sender `size` byte fra innholdet i `buffer` til nettverket. Write-metoden blokkerer til ønsket antall byte sendt eller en <xref:System.Net.Sockets.SocketException>forårsakes.</xref:System.Net.Sockets.SocketException> Hvis du får en <xref:System.Net.Sockets.SocketException>, bruker du <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName>til å hente feilkoden og i Windows Sockets versjon 2 API feil kode dokumentasjonen i MSDN for en detaljert beskrivelse av feilen.</xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> </xref:System.Net.Sockets.SocketException>      > [!NOTE] > Kontroller om det <xref:System.Net.Sockets.NetworkStream>skrives ved å åpne den <xref:System.Net.Sockets.NetworkStream.CanWrite%2A>egenskapen.</xref:System.Net.Sockets.NetworkStream.CanWrite%2A> </xref:System.Net.Sockets.NetworkStream> Hvis du prøver å skrive til en <xref:System.Net.Sockets.NetworkStream>som er ikke skrivbar, får du en <xref:System.IO.IOException>.</xref:System.IO.IOException> </xref:System.Net.Sockets.NetworkStream> Hvis du får en <xref:System.IO.IOException>må du kontrollere <xref:System.Exception.InnerException%2A>til å fastslå om det ble forårsaket av en <xref:System.Net.Sockets.SocketException>.</xref:System.Net.Sockets.SocketException> </xref:System.Exception.InnerException%2A> </xref:System.IO.IOException>"
  example:
  - "The following code example checks to see whether the <xref:System.Net.Sockets.NetworkStream> is writable. If it is, then Write is used to write a small message.  \n  \n [!code-vb[NetworkStream_Synch_SendAndReceive#3](~/add/codesnippet/visualbasic/87c395a5-03ea-4324-8b05-_1.vb)]\n [!code-cpp[NetworkStream_Synch_SendAndReceive#3](~/add/codesnippet/cpp/87c395a5-03ea-4324-8b05-_1.cpp)]\n [!code-cs[NetworkStream_Synch_SendAndReceive#3](~/add/codesnippet/csharp/87c395a5-03ea-4324-8b05-_1.cs)]"
  syntax:
    content: public override void Write (byte[] buffer, int offset, int size);
    parameters:
    - id: buffer
      type: System.Byte[]
      description: "En matrise av typen <xref:System.Byte>som inneholder dataene for å skrive til den <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref>.</xref:System.Byte>"
    - id: offset
      type: System.Int32
      description: "Plasseringen i `buffer` som begynner å skrive data."
    - id: size
      type: System.Int32
      description: "Antall byte ikke skrive til den <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref>."
  overload: System.Net.Sockets.NetworkStream.Write*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>buffer</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "Den <code> offset </code> parameteren er mindre enn 0.       - eller - <code> offset </code> parameteren er større enn lengden på <code> buffer </code>.       - eller - <code> size </code> parameteren er mindre enn 0.       - eller - <code> size </code> parameteren er større enn lengden på <code> buffer </code> minus verdien for den <code> offset </code> parameteren."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Det oppstod en feil under skriving til nettverket.       - eller - det oppstod en feilen under tilgang til socket. Se kommentarer for mer informasjon."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Den <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> er lukket.       - eller - det oppstod en feil under lesing fra nettverket."
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.Writeable
  id: Writeable
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: Writeable
  nameWithType: NetworkStream.Writeable
  fullName: System.Net.Sockets.NetworkStream.Writeable
  type: Property
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Henter en verdi som angir om den <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> skrives."
  remarks: "Du må være utledet fra den <xref:System.Net.Sockets.NetworkStream>klassen for å bruke egenskapen skrivbar.</xref:System.Net.Sockets.NetworkStream> Hvis Writeable `true`, <xref:System.Net.Sockets.NetworkStream>tillater kall til den <xref:System.Net.Sockets.NetworkStream.Write%2A>metoden.</xref:System.Net.Sockets.NetworkStream.Write%2A> </xref:System.Net.Sockets.NetworkStream> Du kan også angi om en <xref:System.Net.Sockets.NetworkStream>skrives ved å kontrollere den allment tilgjengelige <xref:System.Net.Sockets.NetworkStream.CanWrite%2A>egenskapen.</xref:System.Net.Sockets.NetworkStream.CanWrite%2A> </xref:System.Net.Sockets.NetworkStream>       Writeable-egenskapen er angitt når den <xref:System.Net.Sockets.NetworkStream>er initialisert.</xref:System.Net.Sockets.NetworkStream>"
  example:
  - "In the following code example, the `CanCommunicate` property checks the Writeable property to determine if the <xref:System.Net.Sockets.NetworkStream> is writable.  \n  \n [!code-cpp[NetworkStream_Protected_Members#1](~/add/codesnippet/cpp/p-system.net.sockets.net_5_1.cpp)]\n [!code-cs[NetworkStream_Protected_Members#1](~/add/codesnippet/csharp/p-system.net.sockets.net_5_1.cs)]\n [!code-vb[NetworkStream_Protected_Members#1](~/add/codesnippet/visualbasic/p-system.net.sockets.net_5_1.vb)]"
  syntax:
    content: protected bool Writeable { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Hvis kan skrive data til dataflyten; Ellers <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>. Standardverdien er <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>."
  overload: System.Net.Sockets.NetworkStream.Writeable*
  exceptions: []
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.WriteTimeout
  id: WriteTimeout
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: WriteTimeout
  nameWithType: NetworkStream.WriteTimeout
  fullName: System.Net.Sockets.NetworkStream.WriteTimeout
  type: Property
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Henter eller angir hvor lang tid som en skrive operasjonen som venter på at data."
  remarks: "Hvis Skriveoperasjonen ikke fullfører innen angitt av denne egenskapen, oppstår Skriveoperasjonen <xref:System.IO.IOException>.</xref:System.IO.IOException>      > [!NOTE] > Denne egenskapen påvirker bare synkron skriving operasjoner som utføres ved kall av <xref:System.Net.Sockets.NetworkStream.Write%2A>metode.</xref:System.Net.Sockets.NetworkStream.Write%2A> Denne egenskapen påvirker ikke asynkron skriving utføres ved kall av <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A>metode.</xref:System.Net.Sockets.NetworkStream.BeginWrite%2A>"
  example:
  - "The following code example sets the write time-out for a network stream to 10 milliseconds.  \n  \n [!code-cpp[NCLTcpServerSync#0](~/add/codesnippet/cpp/p-system.net.sockets.net_1_1.cpp)]\n [!code-cs[NCLTcpServerSync#0](~/add/codesnippet/csharp/p-system.net.sockets.net_1_1.cs)]"
  syntax:
    content: public override int WriteTimeout { get; set; }
    return:
      type: System.Int32
      description: "En <xref:System.Int32>som angir hvor lang tid, i millisekunder det skal gå før en skriveoperasjon mislykkes.</xref:System.Int32> Standardverdien <xref:System.Threading.Timeout.Infinite>, angir Skriveoperasjonen er tidsavbrutt.</xref:System.Threading.Timeout.Infinite>"
  overload: System.Net.Sockets.NetworkStream.WriteTimeout*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "Den angitte verdien er mindre enn eller lik null, og er ikke <xref:System.Threading.Timeout.Infinite>.</xref:System.Threading.Timeout.Infinite>"
  platform:
  - net462
references:
- uid: System.IO.Stream
  isExternal: false
  name: System.IO.Stream
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.IO.IOException
  isExternal: true
  name: System.IO.IOException
- uid: System.ArgumentOutOfRangeException
  isExternal: true
  name: System.ArgumentOutOfRangeException
- uid: System.ObjectDisposedException
  isExternal: true
  name: System.ObjectDisposedException
- uid: System.Net.Sockets.SocketException
  isExternal: true
  name: System.Net.Sockets.SocketException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.NotSupportedException
  isExternal: true
  name: System.NotSupportedException
- uid: System.Net.Sockets.NetworkStream.#ctor(System.Net.Sockets.Socket)
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: NetworkStream(Socket)
  nameWithType: NetworkStream.NetworkStream(Socket)
  fullName: System.Net.Sockets.NetworkStream.NetworkStream(Socket)
- uid: System.Net.Sockets.Socket
  parent: System.Net.Sockets
  isExternal: true
  name: Socket
  nameWithType: Socket
  fullName: System.Net.Sockets.Socket
- uid: System.Net.Sockets.NetworkStream.#ctor(System.Net.Sockets.Socket,System.Boolean)
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: NetworkStream(Socket,Boolean)
  nameWithType: NetworkStream.NetworkStream(Socket,Boolean)
  fullName: System.Net.Sockets.NetworkStream.NetworkStream(Socket,Boolean)
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Net.Sockets.NetworkStream.#ctor(System.Net.Sockets.Socket,System.IO.FileAccess)
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: NetworkStream(Socket,FileAccess)
  nameWithType: NetworkStream.NetworkStream(Socket,FileAccess)
  fullName: System.Net.Sockets.NetworkStream.NetworkStream(Socket,FileAccess)
- uid: System.IO.FileAccess
  parent: System.IO
  isExternal: false
  name: FileAccess
  nameWithType: FileAccess
  fullName: System.IO.FileAccess
- uid: System.Net.Sockets.NetworkStream.#ctor(System.Net.Sockets.Socket,System.IO.FileAccess,System.Boolean)
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: NetworkStream(Socket,FileAccess,Boolean)
  nameWithType: NetworkStream.NetworkStream(Socket,FileAccess,Boolean)
  fullName: System.Net.Sockets.NetworkStream.NetworkStream(Socket,FileAccess,Boolean)
- uid: System.Net.Sockets.NetworkStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)
  nameWithType: NetworkStream.BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)
  fullName: System.Net.Sockets.NetworkStream.BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)
- uid: System.IAsyncResult
  parent: System
  isExternal: true
  name: IAsyncResult
  nameWithType: IAsyncResult
  fullName: System.IAsyncResult
- uid: System.Byte[]
  parent: System
  isExternal: true
  name: Byte
  nameWithType: Byte
  fullName: System.Byte[]
  spec.csharp:
  - uid: System.Byte
    name: Byte
    nameWithType: Byte
    fullName: Byte[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.AsyncCallback
  parent: System
  isExternal: true
  name: AsyncCallback
  nameWithType: AsyncCallback
  fullName: System.AsyncCallback
- uid: System.Object
  parent: System
  isExternal: true
  name: Object
  nameWithType: Object
  fullName: System.Object
- uid: System.Net.Sockets.NetworkStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)
  nameWithType: NetworkStream.BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)
  fullName: System.Net.Sockets.NetworkStream.BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)
- uid: System.Net.Sockets.NetworkStream.CanRead
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: CanRead
  nameWithType: NetworkStream.CanRead
  fullName: System.Net.Sockets.NetworkStream.CanRead
- uid: System.Net.Sockets.NetworkStream.CanSeek
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: CanSeek
  nameWithType: NetworkStream.CanSeek
  fullName: System.Net.Sockets.NetworkStream.CanSeek
- uid: System.Net.Sockets.NetworkStream.CanTimeout
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: CanTimeout
  nameWithType: NetworkStream.CanTimeout
  fullName: System.Net.Sockets.NetworkStream.CanTimeout
- uid: System.Net.Sockets.NetworkStream.CanWrite
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: CanWrite
  nameWithType: NetworkStream.CanWrite
  fullName: System.Net.Sockets.NetworkStream.CanWrite
- uid: System.Net.Sockets.NetworkStream.Close(System.Int32)
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Close(Int32)
  nameWithType: NetworkStream.Close(Int32)
  fullName: System.Net.Sockets.NetworkStream.Close(Int32)
- uid: System.Net.Sockets.NetworkStream.DataAvailable
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: DataAvailable
  nameWithType: NetworkStream.DataAvailable
  fullName: System.Net.Sockets.NetworkStream.DataAvailable
- uid: System.Net.Sockets.NetworkStream.Dispose(System.Boolean)
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Dispose(Boolean)
  nameWithType: NetworkStream.Dispose(Boolean)
  fullName: System.Net.Sockets.NetworkStream.Dispose(Boolean)
- uid: System.Net.Sockets.NetworkStream.EndRead(System.IAsyncResult)
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: EndRead(IAsyncResult)
  nameWithType: NetworkStream.EndRead(IAsyncResult)
  fullName: System.Net.Sockets.NetworkStream.EndRead(IAsyncResult)
- uid: System.Net.Sockets.NetworkStream.EndWrite(System.IAsyncResult)
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: EndWrite(IAsyncResult)
  nameWithType: NetworkStream.EndWrite(IAsyncResult)
  fullName: System.Net.Sockets.NetworkStream.EndWrite(IAsyncResult)
- uid: System.Net.Sockets.NetworkStream.Finalize
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Finalize()
  nameWithType: NetworkStream.Finalize()
  fullName: System.Net.Sockets.NetworkStream.Finalize()
- uid: System.Net.Sockets.NetworkStream.Flush
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Flush()
  nameWithType: NetworkStream.Flush()
  fullName: System.Net.Sockets.NetworkStream.Flush()
- uid: System.Net.Sockets.NetworkStream.FlushAsync(System.Threading.CancellationToken)
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: FlushAsync(CancellationToken)
  nameWithType: NetworkStream.FlushAsync(CancellationToken)
  fullName: System.Net.Sockets.NetworkStream.FlushAsync(CancellationToken)
- uid: System.Threading.Tasks.Task
  parent: System.Threading.Tasks
  isExternal: true
  name: Task
  nameWithType: Task
  fullName: System.Threading.Tasks.Task
- uid: System.Threading.CancellationToken
  parent: System.Threading
  isExternal: true
  name: CancellationToken
  nameWithType: CancellationToken
  fullName: System.Threading.CancellationToken
- uid: System.Net.Sockets.NetworkStream.Length
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Length
  nameWithType: NetworkStream.Length
  fullName: System.Net.Sockets.NetworkStream.Length
- uid: System.Int64
  parent: System
  isExternal: true
  name: Int64
  nameWithType: Int64
  fullName: System.Int64
- uid: System.Net.Sockets.NetworkStream.Position
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Position
  nameWithType: NetworkStream.Position
  fullName: System.Net.Sockets.NetworkStream.Position
- uid: System.Net.Sockets.NetworkStream.Read(System.Byte[],System.Int32,System.Int32)
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Read(Byte[],Int32,Int32)
  nameWithType: NetworkStream.Read(Byte[],Int32,Int32)
  fullName: System.Net.Sockets.NetworkStream.Read(Byte[],Int32,Int32)
- uid: System.Net.Sockets.NetworkStream.Readable
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Readable
  nameWithType: NetworkStream.Readable
  fullName: System.Net.Sockets.NetworkStream.Readable
- uid: System.Net.Sockets.NetworkStream.ReadTimeout
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: ReadTimeout
  nameWithType: NetworkStream.ReadTimeout
  fullName: System.Net.Sockets.NetworkStream.ReadTimeout
- uid: System.Net.Sockets.NetworkStream.Seek(System.Int64,System.IO.SeekOrigin)
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Seek(Int64,SeekOrigin)
  nameWithType: NetworkStream.Seek(Int64,SeekOrigin)
  fullName: System.Net.Sockets.NetworkStream.Seek(Int64,SeekOrigin)
- uid: System.IO.SeekOrigin
  parent: System.IO
  isExternal: true
  name: SeekOrigin
  nameWithType: SeekOrigin
  fullName: System.IO.SeekOrigin
- uid: System.Net.Sockets.NetworkStream.SetLength(System.Int64)
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: SetLength(Int64)
  nameWithType: NetworkStream.SetLength(Int64)
  fullName: System.Net.Sockets.NetworkStream.SetLength(Int64)
- uid: System.Net.Sockets.NetworkStream.Socket
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Socket
  nameWithType: NetworkStream.Socket
  fullName: System.Net.Sockets.NetworkStream.Socket
- uid: System.Net.Sockets.NetworkStream.Write(System.Byte[],System.Int32,System.Int32)
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Write(Byte[],Int32,Int32)
  nameWithType: NetworkStream.Write(Byte[],Int32,Int32)
  fullName: System.Net.Sockets.NetworkStream.Write(Byte[],Int32,Int32)
- uid: System.Net.Sockets.NetworkStream.Writeable
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Writeable
  nameWithType: NetworkStream.Writeable
  fullName: System.Net.Sockets.NetworkStream.Writeable
- uid: System.Net.Sockets.NetworkStream.WriteTimeout
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: WriteTimeout
  nameWithType: NetworkStream.WriteTimeout
  fullName: System.Net.Sockets.NetworkStream.WriteTimeout
- uid: System.Net.Sockets.NetworkStream.#ctor*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: NetworkStream
  nameWithType: NetworkStream.NetworkStream
- uid: System.Net.Sockets.NetworkStream.BeginRead*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: BeginRead
  nameWithType: NetworkStream.BeginRead
- uid: System.Net.Sockets.NetworkStream.BeginWrite*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: BeginWrite
  nameWithType: NetworkStream.BeginWrite
- uid: System.Net.Sockets.NetworkStream.CanRead*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: CanRead
  nameWithType: NetworkStream.CanRead
- uid: System.Net.Sockets.NetworkStream.CanSeek*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: CanSeek
  nameWithType: NetworkStream.CanSeek
- uid: System.Net.Sockets.NetworkStream.CanTimeout*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: CanTimeout
  nameWithType: NetworkStream.CanTimeout
- uid: System.Net.Sockets.NetworkStream.CanWrite*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: CanWrite
  nameWithType: NetworkStream.CanWrite
- uid: System.Net.Sockets.NetworkStream.Close*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Close
  nameWithType: NetworkStream.Close
- uid: System.Net.Sockets.NetworkStream.DataAvailable*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: DataAvailable
  nameWithType: NetworkStream.DataAvailable
- uid: System.Net.Sockets.NetworkStream.Dispose*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Dispose
  nameWithType: NetworkStream.Dispose
- uid: System.Net.Sockets.NetworkStream.EndRead*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: EndRead
  nameWithType: NetworkStream.EndRead
- uid: System.Net.Sockets.NetworkStream.EndWrite*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: EndWrite
  nameWithType: NetworkStream.EndWrite
- uid: System.Net.Sockets.NetworkStream.Finalize*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Finalize
  nameWithType: NetworkStream.Finalize
- uid: System.Net.Sockets.NetworkStream.Flush*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Flush
  nameWithType: NetworkStream.Flush
- uid: System.Net.Sockets.NetworkStream.FlushAsync*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: FlushAsync
  nameWithType: NetworkStream.FlushAsync
- uid: System.Net.Sockets.NetworkStream.Length*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Length
  nameWithType: NetworkStream.Length
- uid: System.Net.Sockets.NetworkStream.Position*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Position
  nameWithType: NetworkStream.Position
- uid: System.Net.Sockets.NetworkStream.Read*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Read
  nameWithType: NetworkStream.Read
- uid: System.Net.Sockets.NetworkStream.Readable*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Readable
  nameWithType: NetworkStream.Readable
- uid: System.Net.Sockets.NetworkStream.ReadTimeout*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: ReadTimeout
  nameWithType: NetworkStream.ReadTimeout
- uid: System.Net.Sockets.NetworkStream.Seek*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Seek
  nameWithType: NetworkStream.Seek
- uid: System.Net.Sockets.NetworkStream.SetLength*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: SetLength
  nameWithType: NetworkStream.SetLength
- uid: System.Net.Sockets.NetworkStream.Socket*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Socket
  nameWithType: NetworkStream.Socket
- uid: System.Net.Sockets.NetworkStream.Write*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Write
  nameWithType: NetworkStream.Write
- uid: System.Net.Sockets.NetworkStream.Writeable*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Writeable
  nameWithType: NetworkStream.Writeable
- uid: System.Net.Sockets.NetworkStream.WriteTimeout*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: WriteTimeout
  nameWithType: NetworkStream.WriteTimeout
