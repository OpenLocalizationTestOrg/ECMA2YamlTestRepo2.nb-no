### YamlMime:ManagedReference
items:
- uid: System.Threading.ThreadPool
  id: ThreadPool
  children:
  - System.Threading.ThreadPool.BindHandle(System.IntPtr)
  - System.Threading.ThreadPool.BindHandle(System.Runtime.InteropServices.SafeHandle)
  - System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)
  - System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)
  - System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)
  - System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback)
  - System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback,System.Object)
  - System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int32,System.Boolean)
  - System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int64,System.Boolean)
  - System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.TimeSpan,System.Boolean)
  - System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.UInt32,System.Boolean)
  - System.Threading.ThreadPool.SetMaxThreads(System.Int32,System.Int32)
  - System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)
  - System.Threading.ThreadPool.UnsafeQueueNativeOverlapped(System.Threading.NativeOverlapped*)
  - System.Threading.ThreadPool.UnsafeQueueUserWorkItem(System.Threading.WaitCallback,System.Object)
  - System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int32,System.Boolean)
  - System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int64,System.Boolean)
  - System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.TimeSpan,System.Boolean)
  - System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.UInt32,System.Boolean)
  langs:
  - csharp
  name: ThreadPool
  nameWithType: ThreadPool
  fullName: System.Threading.ThreadPool
  type: Class
  summary: "Gir et utvalg av tråder som kan brukes til å utføre oppgaver, post-arbeidselementer, behandle asynkront i/u, Ventingen på vegne av andre tråder og behandle tidtakerne."
  remarks: "Mange programmer opprette tråder som bruker mye tidspunktet tilstanden i dvalemodus, venter på en hendelse kan utføres. Andre tråder kan angi en i dvalemodus tilstand bare reaktiveres regelmessig for å registrere deg for en endring eller oppdatere statusinformasjon. Trådutvalget kan du bruke tråder mer effektivt ved å gi programmet med et utvalg av arbeidstråder som administreres av systemet. Operasjoner som bruker tråd applikasjonsutvalget tråder eksempler på følgende: – Når du oppretter en <xref:System.Threading.Tasks.Task>eller <xref:System.Threading.Tasks.Task%601>-objektet til å utføre noen asynkront, som standard planlegges til å kjøre på en tråd applikasjonsutvalget tråd.</xref:System.Threading.Tasks.Task%601> </xref:System.Threading.Tasks.Task>      -Asynkron tidtakerne Bruk trådutvalget. Tråden applikasjonsutvalget tråder utføres tilbakeringinger fra <xref:System.Threading.Timer?displayProperty=fullName>klassen og øke hendelser fra <xref:System.Timers.Timer?displayProperty=fullName>klasse.</xref:System.Timers.Timer?displayProperty=fullName> </xref:System.Threading.Timer?displayProperty=fullName>      -Når du bruker registrerte Vent håndtak, overvåker en systemtråd statusen for Vent håndtakene. Når en Venteoperasjonen er fullført, utfører en arbeidstråd fra trådutvalget tilsvarende Tilbakekallfunksjonen.      -Når du kaller den <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>metoden kø en metode for kjøring på en tråd applikasjonsutvalget tråd.</xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> Du gjør dette ved å sende metoden en <xref:System.Threading.WaitCallback>delegere.</xref:System.Threading.WaitCallback>   Representanten har signaturen <CodeContentPlaceHolder>0</CodeContentPlaceHolder><CodeContentPlaceHolder>1</CodeContentPlaceHolder> der `state` er et objekt som inneholder data som skal brukes av representanten.    De faktiske dataene kan sendes til representanten ved å kalle den <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29>metoden.</xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29>      > [!NOTE] > Tråder i forvaltet trådutvalget er bakgrunnstråder som. Det vil si deres <xref:System.Threading.Thread.IsBackground%2A>egenskapene `true`.</xref:System.Threading.Thread.IsBackground%2A> Dette betyr at en arbeidstråd tråd ikke ta et program som kjører etter at alle forgrunnen tråder er avsluttet.      > [!IMPORTANT] > Når trådutvalget blir brukt en tråd, operasjonen fjerner ikke data i tråd lokalt eller i feltene som er merket med den <xref:System.ThreadStaticAttribute>attributtet.</xref:System.ThreadStaticAttribute> Derfor når en metode undersøker tråd lokalt eller felt som er merket med den <xref:System.ThreadStaticAttribute>attributtet verdiene oppdages kan stå fra tidligere ved bruk av tråd applikasjonsutvalget tråden.</xref:System.ThreadStaticAttribute>       Du kan også kø arbeidselementer som ikke er relatert til en operasjon for Vent til trådutvalget. For å be om at et arbeidselement håndteres av en tråd i thread pool kalle den <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>metoden.</xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> Denne metoden tar som en parameter en referanse til metoden eller representanten som kalles av tråd valgte fra trådutvalget. Det er ikke mulig å avbryte et arbeidselement etter at den er plassert i kø.       Tidtaker køen tidtakerne og registrert Vent operasjoner må du også bruke trådutvalget. Funksjonene sine tilbakeringing er i kø til trådutvalget.       Det er én trådutvalget per sekund. Begynner med den [!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)], standardstørrelsen på trådutvalget for en prosess som er avhengig av flere faktorer, for eksempel størrelsen på det virtuelle adresseområdet. En prosess kan kalle den <xref:System.Threading.ThreadPool.GetMaxThreads%2A>metode for å bestemme antall tråder.</xref:System.Threading.ThreadPool.GetMaxThreads%2A> Antall tråder som trådutvalget kan endres ved hjelp av den <xref:System.Threading.ThreadPool.SetMaxThreads%2A>metoden.</xref:System.Threading.ThreadPool.SetMaxThreads%2A> Hver tråd bruker stakk standardstørrelsen og kjører på standardprioritet.      > [!NOTE] > Ubehandlet kode som er vert for .NET Framework kan endre størrelsen på trådutvalget ved hjelp av `CorSetMaxThreads` -funksjonen, som er definert i filen mscoree.h.       Thread pool gir nye arbeidstråder eller i/u-fullføring tråder ved behov før den når minimumsverdien for hver kategori. Når en minimumsverdi er nådd, kan trådutvalget opprette flere tråder i denne kategorien eller vente til noen oppgaver er fullført. Begynner med den [!INCLUDE[net_v40_short](~/add/includes/net-v40-short-md.md)], trådutvalget oppretter og ødelegger arbeidstråder for å optimalisere ytelse, som er definert som antall oppgaver som fullfører per tidsenheten. For få tråder kan ikke gjøre optimalisere bruken av tilgjengelige ressurser mens for mange tråder kan øke ressursen konflikten.      > [!NOTE] > Når behov er lavt, faktisk antall tråder som tråd applikasjonsutvalget kan faller under minimumsverdien.       Du kan bruke den <xref:System.Threading.ThreadPool.GetMinThreads%2A>metode for å hente disse minimumsverdiene.</xref:System.Threading.ThreadPool.GetMinThreads%2A>      > [!CAUTION] > Kan du bruke den <xref:System.Threading.ThreadPool.SetMinThreads%2A>metode for å øke antallet tråder.</xref:System.Threading.ThreadPool.SetMinThreads%2A> Uten grunn øke disse verdiene kan imidlertid føre til problemer. Hvis for mange oppgaver starter samtidig, vises alle kan derfor være treg. I de fleste tilfeller utfører trådutvalget bedre med sin egen algoritme for tilordning av tråder."
  example:
  - "In the following example, the main application thread  queues a method named `ThreadProc` to execute on a thread pool thread, sleeps for one second, and then exits. The `ThreadProc` method simply displays a message.  \n  \n [!code-cpp[System.Threading.ThreadPool QueueUserWorkItem0#1](~/add/codesnippet/cpp/t-system.threading.threa_5_1.cpp)]\n [!code-vb[System.Threading.ThreadPool QueueUserWorkItem0#1](~/add/codesnippet/visualbasic/t-system.threading.threa_5_1.vb)]\n [!code-cs[System.Threading.ThreadPool QueueUserWorkItem0#1](~/add/codesnippet/csharp/t-system.threading.threa_5_1.cs)]  \n  \n If you comment out the call to the <xref:System.Threading.Thread.Sleep%2A?displayProperty=fullName> method, the main thread exits before         method runs on the thread pool thread.  The thread pool uses background         threads, which do not keep the application running if all foreground threads have terminated.  (This         is a simple example of a race condition.)"
  syntax:
    content: public static class ThreadPool
  inheritance:
  - System.Object
  implements: []
  inheritedMembers: []
  platform:
  - net462
- uid: System.Threading.ThreadPool.BindHandle(System.IntPtr)
  id: BindHandle(System.IntPtr)
  parent: System.Threading.ThreadPool
  langs:
  - csharp
  name: BindHandle(IntPtr)
  nameWithType: ThreadPool.BindHandle(IntPtr)
  fullName: System.Threading.ThreadPool.BindHandle(IntPtr)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Binding en operativsystemet håndtak til den <xref href=&quot;System.Threading.ThreadPool&quot;> </xref>."
  syntax:
    content: public static bool BindHandle (IntPtr osHandle);
    parameters:
    - id: osHandle
      type: System.IntPtr
      description: "En <xref:System.IntPtr>som inneholder håndtaket.</xref:System.IntPtr> Referansen må ha åpnet for overlappende i/u på uforvaltede side."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Hvis referansen er bundet; Ellers <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Threading.ThreadPool.BindHandle*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "Oppkalleren har ikke den nødvendige tillatelsen."
  platform:
  - net462
- uid: System.Threading.ThreadPool.BindHandle(System.Runtime.InteropServices.SafeHandle)
  id: BindHandle(System.Runtime.InteropServices.SafeHandle)
  parent: System.Threading.ThreadPool
  langs:
  - csharp
  name: BindHandle(SafeHandle)
  nameWithType: ThreadPool.BindHandle(SafeHandle)
  fullName: System.Threading.ThreadPool.BindHandle(SafeHandle)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Binding en operativsystemet håndtak til den <xref href=&quot;System.Threading.ThreadPool&quot;> </xref>."
  remarks: "Den `osHandle` -parameteren må være en <xref:Microsoft.Win32.SafeHandles.SafeFileHandle>som er avledet fra abstrakt <xref:System.Runtime.InteropServices.SafeHandle>klasse.</xref:System.Runtime.InteropServices.SafeHandle> </xref:Microsoft.Win32.SafeHandles.SafeFileHandle>"
  syntax:
    content: public static bool BindHandle (System.Runtime.InteropServices.SafeHandle osHandle);
    parameters:
    - id: osHandle
      type: System.Runtime.InteropServices.SafeHandle
      description: "En <xref:System.Runtime.InteropServices.SafeHandle>som inneholder operativsystemet håndtaket.</xref:System.Runtime.InteropServices.SafeHandle> Referansen må ha åpnet for overlappende i/u på uforvaltede side."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Hvis referansen er bundet; Ellers <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Threading.ThreadPool.BindHandle*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>osHandle</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)
  id: GetAvailableThreads(System.Int32@,System.Int32@)
  parent: System.Threading.ThreadPool
  langs:
  - csharp
  name: GetAvailableThreads(Int32,Int32)
  nameWithType: ThreadPool.GetAvailableThreads(Int32,Int32)
  fullName: System.Threading.ThreadPool.GetAvailableThreads(Int32,Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Henter forskjellen mellom det maksimale antallet tråd applikasjonsutvalget tråder som ble returnert av den <xref:System.Threading.ThreadPool.GetMaxThreads*>metoden og antall aktive.</xref:System.Threading.ThreadPool.GetMaxThreads*>"
  remarks: "Når GetAvailableThreads returnerer, variabelen som er angitt av `workerThreads` inneholder antallet ekstra arbeidstråder som kan starte og variabelen som er angitt av `completionPortThreads` inneholder antall ekstra asynkront i/u-tråder som kan startes.       Hvis det er ingen tilgjengelige tråder, forblir ekstra tråd applikasjonsutvalget forespørsler i kø til tråd applikasjonsutvalget tråder blir tilgjengelig."
  example:
  - "The following example displays the number of worker threads and I/O threads available when a simple app is started.  \n  \n [!code-cs[System.Threading.ThreadPool.GetAvailableThreads#2](~/add/codesnippet/csharp/m-system.threading.threa_23_1.cs)]\n [!code-vb[System.Threading.ThreadPool.GetAvailableThreads#2](~/add/codesnippet/visualbasic/m-system.threading.threa_23_1.vb)]"
  syntax:
    content: public static void GetAvailableThreads (out int workerThreads, out int completionPortThreads);
    parameters:
    - id: workerThreads
      type: System.Int32
      description: "Antall tilgjengelige arbeidstråder."
    - id: completionPortThreads
      type: System.Int32
      description: "Antall tilgjengelige asynkrone i/u-tråder."
  overload: System.Threading.ThreadPool.GetAvailableThreads*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)
  id: GetMaxThreads(System.Int32@,System.Int32@)
  parent: System.Threading.ThreadPool
  langs:
  - csharp
  name: GetMaxThreads(Int32,Int32)
  nameWithType: ThreadPool.GetMaxThreads(Int32,Int32)
  fullName: System.Threading.ThreadPool.GetMaxThreads(Int32,Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Henter antall forespørsler til trådutvalget som kan være aktive samtidig. Alle forespørsler over dette nummeret forblir i kø til tråd applikasjonsutvalget tråder blir tilgjengelig."
  remarks: "Når GetMaxThreads returnerer, variabelen som er angitt av `workerThreads` inneholder maksimalt antall arbeidstråder som er tillatt i thread pool og variabel som er angitt av `completionPortThreads` inneholder maksimalt antall tillatte i thread pool asynkront i/u-tråder.       Du kan bruke den <xref:System.Threading.ThreadPool.GetAvailableThreads%2A>metoden for å bestemme antall tråder i thread pool om gangen.</xref:System.Threading.ThreadPool.GetAvailableThreads%2A>       Du kan bruke den <xref:System.Threading.ThreadPool.SetMaxThreads%2A>du angir det maksimale antallet arbeidstråder og asynkront i/u-tråder i thread pool.</xref:System.Threading.ThreadPool.SetMaxThreads%2A>       Du kan sette som mange tråd applikasjonsutvalget forespørsler som tillater systemminnet. Hvis det finnes flere forespørsler enn tråd applikasjonsutvalget tråder, forblir flere forespørsler i kø til tråd applikasjonsutvalget tråder blir tilgjengelig."
  example:
  - "The following code example shows how to retrieve a count of the maximum and available number of threads in the thread pool. A work item is queued that uses `FileStream` to asynchronously write to two files. The callback methods are timed to overlap. A worker thread handles the work item and, depending on the speed and number of processors on the computer, one or two completion port threads handle the write operations.  \n  \n [!code-cpp[System.Threading.ThreadPool.GetAvailableThreads#1](~/add/codesnippet/cpp/m-system.threading.threa_14_1.cpp)]\n [!code-cs[System.Threading.ThreadPool.GetAvailableThreads#1](~/add/codesnippet/csharp/m-system.threading.threa_14_1.cs)]\n [!code-vb[System.Threading.ThreadPool.GetAvailableThreads#1](~/add/codesnippet/visualbasic/m-system.threading.threa_14_1.vb)]"
  syntax:
    content: public static void GetMaxThreads (out int workerThreads, out int completionPortThreads);
    parameters:
    - id: workerThreads
      type: System.Int32
      description: "Maksimalt antall arbeidstråder i trådutvalget."
    - id: completionPortThreads
      type: System.Int32
      description: "Maksimalt antall tråder som asynkront i/u i trådutvalget."
  overload: System.Threading.ThreadPool.GetMaxThreads*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)
  id: GetMinThreads(System.Int32@,System.Int32@)
  parent: System.Threading.ThreadPool
  langs:
  - csharp
  name: GetMinThreads(Int32,Int32)
  nameWithType: ThreadPool.GetMinThreads(Int32,Int32)
  fullName: System.Threading.ThreadPool.GetMinThreads(Int32,Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Henter minimum antall tråder som trådutvalget oppretter ved behov, slik at nye forespørsler, før du bytter til en algoritme for administrasjon av tråd oppretting og ødelegges."
  remarks: "Thread pool gir nye arbeidstråder eller i/u-fullføring tråder ved behov før den når minimumsverdien for hver kategori. Minste antall tråder som er satt til antallet prosessorer på et system som standard. Når minimumsverdien er nådd, kan trådutvalget opprette flere tråder i denne kategorien eller vente til noen oppgaver er fullført. Begynner med den [!INCLUDE[net_v40_short](~/add/includes/net-v40-short-md.md)], trådutvalget oppretter og ødelegger tråder for å optimalisere ytelse, som er definert som antall oppgaver som fullfører per tidsenheten. For få tråder kan ikke gjøre optimalisere bruken av tilgjengelige ressurser mens for mange tråder kan øke ressursen konflikten.      > [!NOTE] > Når behov er lavt, faktisk antall tråder som tråd applikasjonsutvalget kan faller under minimumsverdien."
  example:
  - "The following example sets the minimum number of worker threads to four, and preserves the original value for the minimum number of asynchronous I/O completion threads.  \n  \n [!code-vb[System.Threading.ThreadPool.GetSetMinThreads#1](~/add/codesnippet/visualbasic/m-system.threading.threa_20_1.vb)]\n [!code-cs[System.Threading.ThreadPool.GetSetMinThreads#1](~/add/codesnippet/csharp/m-system.threading.threa_20_1.cs)]\n [!code-cpp[System.Threading.ThreadPool.GetSetMinThreads#1](~/add/codesnippet/cpp/m-system.threading.threa_20_1.cpp)]"
  syntax:
    content: public static void GetMinThreads (out int workerThreads, out int completionPortThreads);
    parameters:
    - id: workerThreads
      type: System.Int32
      description: "Låse denne metoden, inneholder det minste antallet arbeidstråder som trådutvalget oppretter ved behov."
    - id: completionPortThreads
      type: System.Int32
      description: "Låse denne metoden, inneholder minimumsantallet asynkront i/u-tråder som trådutvalget oppretter ved behov."
  overload: System.Threading.ThreadPool.GetMinThreads*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback)
  id: QueueUserWorkItem(System.Threading.WaitCallback)
  parent: System.Threading.ThreadPool
  langs:
  - csharp
  name: QueueUserWorkItem(WaitCallback)
  nameWithType: ThreadPool.QueueUserWorkItem(WaitCallback)
  fullName: System.Threading.ThreadPool.QueueUserWorkItem(WaitCallback)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "En annen metode for kjøring i kø. Metoden utfører når en tråd applikasjonsutvalget tråd blir tilgjengelig."
  remarks: "Du kan sette inn data som kreves av metoden i kø i feltene forekomsten av klassen der metoden er definert, eller du kan bruke den <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29>overbelastning som godtar et objekt som inneholder de nødvendige dataene.</xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29>      > [!NOTE] > Visual Basic-brukere kan utelate den <xref:System.Threading.WaitCallback>konstruktøren, og ganske enkelt å bruke den `AddressOf` operatoren ved sending av tilbakeringing-metoden til <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>.</xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> </xref:System.Threading.WaitCallback> Visual Basic kaller automatisk riktig representanten-konstruktøren.      ## Versjonen informasjon i i .NET Framework, versjon 2.0, den <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=fullName>egenskapsverdien er overført til arbeidstråder i kø ved hjelp av den <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>metoden.</xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> </xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=fullName> Sikkerhetskontohaveren informasjonen er ikke overført i tidligere versjoner."
  example:
  - "The following example uses the QueueUserWorkItem method overload to queue a task, which is represented by the `ThreadProc` method, to execute when a thread becomes available. No task information is supplied with this overload. Therefore, the information that is available to the `ThreadProc` method is limited to the object the method belongs to.  \n  \n [!code-cpp[System.Threading.ThreadPool QueueUserWorkItem0#1](~/add/codesnippet/cpp/m-system.threading.threa_22_1.cpp)]\n [!code-vb[System.Threading.ThreadPool QueueUserWorkItem0#1](~/add/codesnippet/visualbasic/m-system.threading.threa_22_1.vb)]\n [!code-cs[System.Threading.ThreadPool QueueUserWorkItem0#1](~/add/codesnippet/csharp/m-system.threading.threa_22_1.cs)]"
  syntax:
    content: public static bool QueueUserWorkItem (System.Threading.WaitCallback callBack);
    parameters:
    - id: callBack
      type: System.Threading.WaitCallback
      description: "En <xref href=&quot;System.Threading.WaitCallback&quot;> </xref> som representerer metoden kjøres."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Hvis metoden er lagt i kø; <xref:System.NotSupportedException>oppstår hvis arbeidselementet ikke kan plasseres i kø.</xref:System.NotSupportedException>"
  overload: System.Threading.ThreadPool.QueueUserWorkItem*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>callBack</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Common language runtime (CLR) er vertsbasert og verten støtter ikke denne handlingen."
  platform:
  - net462
- uid: System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback,System.Object)
  id: QueueUserWorkItem(System.Threading.WaitCallback,System.Object)
  parent: System.Threading.ThreadPool
  langs:
  - csharp
  name: QueueUserWorkItem(WaitCallback,Object)
  nameWithType: ThreadPool.QueueUserWorkItem(WaitCallback,Object)
  fullName: System.Threading.ThreadPool.QueueUserWorkItem(WaitCallback,Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "En annen metode for kjøring i kø, og angir et objekt som inneholder data som skal brukes ved hjelp av metoden. Metoden utfører når en tråd applikasjonsutvalget tråd blir tilgjengelig."
  remarks: "Hvis metoden tilbakeringing krever kompliserte data, kan du definere en klasse skal inneholde dataene.      > [!NOTE] > Visual Basic-brukere kan utelate den <xref:System.Threading.WaitCallback>konstruktøren, og ganske enkelt å bruke den `AddressOf` operatoren ved sending av tilbakeringing-metoden til QueueUserWorkItem.</xref:System.Threading.WaitCallback> Visual Basic kaller automatisk riktig representanten-konstruktøren.      ## Versjonen informasjon i i .NET Framework, versjon 2.0, den <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=fullName>egenskapsverdien er overført til arbeidstråder i kø ved hjelp av den <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>metoden.</xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> </xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=fullName> Sikkerhetskontohaveren informasjonen er ikke overført i tidligere versjoner."
  example:
  - "The following example shows how to create an object that contains task information. It also demonstrates how to pass that object to a task that is queued for execution by the thread pool.  \n  \n [!code-cpp[System.Threading.ThreadPool QueueUserWorkItem1#1](~/add/codesnippet/cpp/9389ae71-aa49-4ceb-9b0a-_1.cpp)]\n [!code-cs[System.Threading.ThreadPool QueueUserWorkItem1#1](~/add/codesnippet/csharp/9389ae71-aa49-4ceb-9b0a-_1.cs)]\n [!code-vb[System.Threading.ThreadPool QueueUserWorkItem1#1](~/add/codesnippet/visualbasic/9389ae71-aa49-4ceb-9b0a-_1.vb)]"
  syntax:
    content: public static bool QueueUserWorkItem (System.Threading.WaitCallback callBack, object state);
    parameters:
    - id: callBack
      type: System.Threading.WaitCallback
      description: "En <xref href=&quot;System.Threading.WaitCallback&quot;> </xref> som representerer metoden som skal kjøres."
    - id: state
      type: System.Object
      description: "Et objekt som inneholder data som skal brukes av metoden."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Hvis metoden er lagt i kø; <xref:System.NotSupportedException>oppstår hvis arbeidselementet ikke kan plasseres i kø.</xref:System.NotSupportedException>"
  overload: System.Threading.ThreadPool.QueueUserWorkItem*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Common language runtime (CLR) er vertsbasert og verten støtter ikke denne handlingen."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>callBack</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int32,System.Boolean)
  id: RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int32,System.Boolean)
  parent: System.Threading.ThreadPool
  langs:
  - csharp
  name: RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int32,Boolean)
  nameWithType: ThreadPool.RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int32,Boolean)
  fullName: System.Threading.ThreadPool.RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int32,Boolean)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Registrerer representant man skal vente på en <xref:System.Threading.WaitHandle>, angir et 32-biters fortegn for tidsavbrudd for i millisekunder.</xref:System.Threading.WaitHandle>"
  remarks: "Når du er ferdig med den <xref:System.Threading.RegisteredWaitHandle>som returneres av denne metoden, kan du kontakte den <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>metode for å frigjøre referanser til Vent håndtaket.</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> </xref:System.Threading.RegisteredWaitHandle> Vi anbefaler at du alltid ringer den <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>metoden, selv om du angir `true` for `executeOnlyOnce`.</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> Datasanering fungerer mer effektivt Hvis du kaller den <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>metoden i stedet for avhengig av den registrerte Vent referansen Sluttbehandler.</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>       Metoden RegisterWaitForSingleObject køer angitte representanten til trådutvalget. En arbeidstråd vil kjøre representanten når oppstår ett av følgende:-det angitte objektet er i tilstanden signalisert.      Det går-tidsavbrudd.       Metoden RegisterWaitForSingleObject kontrollerer den gjeldende tilstanden til det angitte objektet <xref:System.Threading.WaitHandle>.</xref:System.Threading.WaitHandle> Hvis objektets tilstand unsignaled, registrerer metoden en operasjon på vent. Venteoperasjonen utføres av en tråd fra trådutvalget. Representanten utføres av en arbeidstråd når objektets tilstand er signalisert eller tidsavbruddet utløper. Hvis den `timeOutInterval` parameteren er 0 (null) og `executeOnlyOnce` parameteren er `false`, tidtakeren tilbakestilles hver gang hendelsen signalisert eller tidsavbruddet utløper.      > [!IMPORTANT] > Ved hjelp av en <xref:System.Threading.Mutex>for `waitObject` leverer ikke gjensidig unntak for tilbakeringinger fordi underliggende Win32 API bruker standard `WT_EXECUTEDEFAULT` flagget, slik at hver tilbakeringing fordele på en egen tråd applikasjonsutvalget tråd.</xref:System.Threading.Mutex> I stedet for en <xref:System.Threading.Mutex>, Bruk et <xref:System.Threading.Semaphore>med et maksimalt antall 1.</xref:System.Threading.Semaphore> </xref:System.Threading.Mutex>       Hvis du vil avbryte Venteoperasjonen, kan du kalle den <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>metoden.</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>       Vent tråden bruker Win32 `WaitForMultipleObjects` funksjonen til å overvåke registrerte Vent operasjoner. Hvis du må bruke samme opprinnelig operativsystemet håndtaket i flere kall til RegisterWaitForSingleObject, må du derfor duplisere håndtak med Win32 `DuplicateHandle` funksjonen. Vær oppmerksom på at du ikke skal pulse en hendelsesobjektet som er sendt til RegisterWaitForSingleObject, fordi Vent tråden ikke registrerer at hendelsen er signalisert før den er tilbakestilt.       Før den returnerer, endrer funksjonen tilstanden av enkelte dokumenttyper synkroniseringsobjektene. Endringen oppstår bare for objektet som har angitt tilstand forårsaket Vent betingelsen oppfylles. For eksempel er antall en semafor redusert av en.      ## Versjonen informasjon fra og med .NET Framework, versjon 2.0, den <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=fullName>egenskapsverdien er overført til arbeidstråder i kø ved hjelp av den <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>metoden.</xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> </xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=fullName> Sikkerhetskontohaveren informasjonen er ikke overført i tidligere versjoner."
  syntax:
    content: public static System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, int millisecondsTimeOutInterval, bool executeOnlyOnce);
    parameters:
    - id: waitObject
      type: System.Threading.WaitHandle
      description: "Den <xref:System.Threading.WaitHandle>til å registrere.</xref:System.Threading.WaitHandle> Bruk en <xref:System.Threading.WaitHandle>enn <xref:System.Threading.Mutex>.</xref:System.Threading.Mutex> </xref:System.Threading.WaitHandle>"
    - id: callBack
      type: System.Threading.WaitOrTimerCallback
      description: "Den <xref href=&quot;System.Threading.WaitOrTimerCallback&quot;> </xref> representanten å kalle når den `waitObject` parameteren signalisert."
    - id: state
      type: System.Object
      description: "Objektet som er sendt til representanten."
    - id: millisecondsTimeOutInterval
      type: System.Int32
      description: "Tidsavbrudd i millisekunder. Hvis den `millisecondsTimeOutInterval` parameteren er 0 (null), funksjonen tester objektets tilstand, og returnerer umiddelbart. Hvis `millisecondsTimeOutInterval` er -1, aldri går funksjonens tidsavbrudd."
    - id: executeOnlyOnce
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>for å angi at tråden vil ikke lenger vente den `waitObject` parameteren etter representanten er kalt; <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> til å angi at tidtakeren tilbakestilles hver gang Venteoperasjonen er fullført før ventetiden er fjernet."
    return:
      type: System.Threading.RegisteredWaitHandle
      description: "Den <xref href=&quot;System.Threading.RegisteredWaitHandle&quot;> </xref> som innkapsler den opprinnelige referansen."
  overload: System.Threading.ThreadPool.RegisterWaitForSingleObject*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "Den <code> millisecondsTimeOutInterval </code> parameteren er mindre enn -1."
  platform:
  - net462
- uid: System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int64,System.Boolean)
  id: RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int64,System.Boolean)
  parent: System.Threading.ThreadPool
  langs:
  - csharp
  name: RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int64,Boolean)
  nameWithType: ThreadPool.RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int64,Boolean)
  fullName: System.Threading.ThreadPool.RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int64,Boolean)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Registrerer representant man skal vente på en <xref:System.Threading.WaitHandle>, angir et 64-biters fortegn for tidsavbrudd for i millisekunder.</xref:System.Threading.WaitHandle>"
  remarks: "Når du er ferdig med den <xref:System.Threading.RegisteredWaitHandle>som returneres av denne metoden, kan du kontakte den <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>metode for å frigjøre referanser til Vent håndtaket.</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> </xref:System.Threading.RegisteredWaitHandle> Vi anbefaler at du alltid ringer den <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>metoden, selv om du angir `true` for `executeOnlyOnce`.</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> Datasanering fungerer mer effektivt Hvis du kaller den <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>metoden i stedet for avhengig av den registrerte Vent referansen Sluttbehandler.</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>       Metoden RegisterWaitForSingleObject køer angitte representanten til trådutvalget. En arbeidstråd vil kjøre representanten når oppstår ett av følgende:-det angitte objektet er i tilstanden signalisert.      Det går-tidsavbrudd.       Metoden RegisterWaitForSingleObject kontrollerer den gjeldende tilstanden til det angitte objektet <xref:System.Threading.WaitHandle>.</xref:System.Threading.WaitHandle> Hvis objektets tilstand unsignaled, registrerer metoden en operasjon på vent. Venteoperasjonen utføres av en tråd fra trådutvalget. Representanten utføres av en arbeidstråd når objektets tilstand er signalisert eller tidsavbruddet utløper. Hvis den `timeOutInterval` parameteren er 0 (null) og `executeOnlyOnce` parameteren er `false`, tidtakeren tilbakestilles hver gang hendelsen signalisert eller tidsavbruddet utløper.      > [!IMPORTANT] > Ved hjelp av en <xref:System.Threading.Mutex>for `waitObject` leverer ikke gjensidig unntak for tilbakeringinger fordi underliggende Win32 API bruker standard `WT_EXECUTEDEFAULT` flagget, slik at hver tilbakeringing fordele på en egen tråd applikasjonsutvalget tråd.</xref:System.Threading.Mutex> I stedet for en <xref:System.Threading.Mutex>, Bruk et <xref:System.Threading.Semaphore>med et maksimalt antall 1.</xref:System.Threading.Semaphore> </xref:System.Threading.Mutex>       Hvis du vil avbryte Venteoperasjonen, kan du kalle den <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>metoden.</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>       Vent tråden bruker Win32 `WaitForMultipleObjects` funksjonen til å overvåke registrerte Vent operasjoner. Hvis du må bruke samme opprinnelig operativsystemet håndtaket i flere kall til RegisterWaitForSingleObject, må du derfor duplisere håndtak med Win32 `DuplicateHandle` funksjonen. Vær oppmerksom på at du ikke skal pulse en hendelsesobjektet som er sendt til RegisterWaitForSingleObject, fordi Vent tråden ikke registrerer at hendelsen er signalisert før den er tilbakestilt.       Før den returnerer, endrer funksjonen tilstanden av enkelte dokumenttyper synkroniseringsobjektene. Endringen oppstår bare for objektet som har angitt tilstand forårsaket Vent betingelsen oppfylles. For eksempel er antall en semafor redusert av en.      ## Versjonen informasjon fra og med .NET Framework, versjon 2.0, den <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=fullName>egenskapsverdien er overført til arbeidstråder i kø ved hjelp av den <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>metoden.</xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> </xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=fullName> Sikkerhetskontohaveren informasjonen er ikke overført i tidligere versjoner."
  syntax:
    content: public static System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, long millisecondsTimeOutInterval, bool executeOnlyOnce);
    parameters:
    - id: waitObject
      type: System.Threading.WaitHandle
      description: "Den <xref:System.Threading.WaitHandle>til å registrere.</xref:System.Threading.WaitHandle> Bruk en <xref:System.Threading.WaitHandle>enn <xref:System.Threading.Mutex>.</xref:System.Threading.Mutex> </xref:System.Threading.WaitHandle>"
    - id: callBack
      type: System.Threading.WaitOrTimerCallback
      description: "Den <xref href=&quot;System.Threading.WaitOrTimerCallback&quot;> </xref> representanten å kalle når den `waitObject` parameteren signalisert."
    - id: state
      type: System.Object
      description: "Objektet som er sendt til representanten."
    - id: millisecondsTimeOutInterval
      type: System.Int64
      description: "Tidsavbrudd i millisekunder. Hvis den `millisecondsTimeOutInterval` parameteren er 0 (null), funksjonen tester objektets tilstand, og returnerer umiddelbart. Hvis `millisecondsTimeOutInterval` er -1, aldri går funksjonens tidsavbrudd."
    - id: executeOnlyOnce
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>for å angi at tråden vil ikke lenger vente den `waitObject` parameteren etter representanten er kalt; <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> til å angi at tidtakeren tilbakestilles hver gang Venteoperasjonen er fullført før ventetiden er fjernet."
    return:
      type: System.Threading.RegisteredWaitHandle
      description: "Den <xref href=&quot;System.Threading.RegisteredWaitHandle&quot;> </xref> som innkapsler den opprinnelige referansen."
  overload: System.Threading.ThreadPool.RegisterWaitForSingleObject*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "Den <code> millisecondsTimeOutInterval </code> parameteren er mindre enn -1."
  platform:
  - net462
- uid: System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.TimeSpan,System.Boolean)
  id: RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.TimeSpan,System.Boolean)
  parent: System.Threading.ThreadPool
  langs:
  - csharp
  name: RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,TimeSpan,Boolean)
  nameWithType: ThreadPool.RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,TimeSpan,Boolean)
  fullName: System.Threading.ThreadPool.RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,TimeSpan,Boolean)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Registrerer representant man skal vente på en <xref:System.Threading.WaitHandle>, som angir en <xref:System.TimeSpan>verdien for tidsavbrudd for.</xref:System.TimeSpan> </xref:System.Threading.WaitHandle>"
  remarks: "Når du er ferdig med den <xref:System.Threading.RegisteredWaitHandle>som returneres av denne metoden, kan du kontakte den <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>metode for å frigjøre referanser til Vent håndtaket.</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> </xref:System.Threading.RegisteredWaitHandle> Vi anbefaler at du alltid ringer den <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>metoden, selv om du angir `true` for `executeOnlyOnce`.</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> Datasanering fungerer mer effektivt Hvis du kaller den <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>metoden i stedet for avhengig av den registrerte Vent referansen Sluttbehandler.</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>       Metoden RegisterWaitForSingleObject køer angitte representanten til trådutvalget. En arbeidstråd vil kjøre representanten når oppstår ett av følgende:-det angitte objektet er i tilstanden signalisert.      Det går-tidsavbrudd.       Metoden RegisterWaitForSingleObject kontrollerer den gjeldende tilstanden til det angitte objektet <xref:System.Threading.WaitHandle>.</xref:System.Threading.WaitHandle> Hvis objektets tilstand unsignaled, registrerer metoden en operasjon på vent. Venteoperasjonen utføres av en tråd fra trådutvalget. Representanten utføres av en arbeidstråd når objektets tilstand er signalisert eller tidsavbruddet utløper. Hvis den `timeOutInterval` parameteren er 0 (null) og `executeOnlyOnce` parameteren er `false`, tidtakeren tilbakestilles hver gang hendelsen signalisert eller tidsavbruddet utløper.      > [!IMPORTANT] > Ved hjelp av en <xref:System.Threading.Mutex>for `waitObject` leverer ikke gjensidig unntak for tilbakeringinger fordi underliggende Win32 API bruker standard `WT_EXECUTEDEFAULT` flagget, slik at hver tilbakeringing fordele på en egen tråd applikasjonsutvalget tråd.</xref:System.Threading.Mutex> I stedet for en <xref:System.Threading.Mutex>, Bruk et <xref:System.Threading.Semaphore>med et maksimalt antall 1.</xref:System.Threading.Semaphore> </xref:System.Threading.Mutex>       Hvis du vil avbryte Venteoperasjonen, kan du kalle den <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>metoden.</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>       Vent tråden bruker Win32 `WaitForMultipleObjects` funksjonen til å overvåke registrerte Vent operasjoner. Hvis du må bruke samme opprinnelig operativsystemet håndtaket i flere kall til RegisterWaitForSingleObject, må du derfor duplisere håndtak med Win32 `DuplicateHandle` funksjonen. Vær oppmerksom på at du ikke skal pulse en hendelsesobjektet som er sendt til RegisterWaitForSingleObject, fordi Vent tråden ikke registrerer at hendelsen er signalisert før den er tilbakestilt.       Før den returnerer, endrer funksjonen tilstanden av enkelte dokumenttyper synkroniseringsobjektene. Endringen oppstår bare for objektet som har angitt tilstand forårsaket Vent betingelsen oppfylles. For eksempel er antall en semafor redusert av en.      ## Versjonen informasjon fra og med .NET Framework, versjon 2.0, den <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=fullName>egenskapsverdien er overført til arbeidstråder i kø ved hjelp av den <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>metoden.</xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> </xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=fullName> Sikkerhetskontohaveren informasjonen er ikke overført i tidligere versjoner."
  syntax:
    content: public static System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, TimeSpan timeout, bool executeOnlyOnce);
    parameters:
    - id: waitObject
      type: System.Threading.WaitHandle
      description: "Den <xref:System.Threading.WaitHandle>til å registrere.</xref:System.Threading.WaitHandle> Bruk en <xref:System.Threading.WaitHandle>enn <xref:System.Threading.Mutex>.</xref:System.Threading.Mutex> </xref:System.Threading.WaitHandle>"
    - id: callBack
      type: System.Threading.WaitOrTimerCallback
      description: "Den <xref href=&quot;System.Threading.WaitOrTimerCallback&quot;> </xref> representanten å kalle når den `waitObject` parameteren signalisert."
    - id: state
      type: System.Object
      description: "Objektet som er sendt til representanten."
    - id: timeout
      type: System.TimeSpan
      description: "Tidsavbruddet som er representert av <xref:System.TimeSpan>.</xref:System.TimeSpan> Hvis `timeout` er 0 (null), funksjonen tester objektets tilstand, og returnerer umiddelbart. Hvis `timeout` er -1, aldri går funksjonens tidsavbrudd."
    - id: executeOnlyOnce
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>for å angi at tråden vil ikke lenger vente den `waitObject` parameteren etter representanten er kalt; <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> til å angi at tidtakeren tilbakestilles hver gang Venteoperasjonen er fullført før ventetiden er fjernet."
    return:
      type: System.Threading.RegisteredWaitHandle
      description: "Den <xref href=&quot;System.Threading.RegisteredWaitHandle&quot;> </xref> som innkapsler den opprinnelige referansen."
  overload: System.Threading.ThreadPool.RegisterWaitForSingleObject*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "Den <code> timeout </code> parameteren er mindre enn -1."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Den <code> timeout </code> parameteren er større enn &lt;xref:System.Int32.MaxValue?displayProperty=fullName&gt;."
  platform:
  - net462
- uid: System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.UInt32,System.Boolean)
  id: RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.UInt32,System.Boolean)
  parent: System.Threading.ThreadPool
  langs:
  - csharp
  name: RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,UInt32,Boolean)
  nameWithType: ThreadPool.RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,UInt32,Boolean)
  fullName: System.Threading.ThreadPool.RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,UInt32,Boolean)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Registrerer representant man skal vente på en <xref:System.Threading.WaitHandle>, angir et 32-biters heltall uten fortegn for tidsavbrudd for i millisekunder.</xref:System.Threading.WaitHandle>"
  remarks: "Når du er ferdig med den <xref:System.Threading.RegisteredWaitHandle>som returneres av denne metoden, kan du kontakte den <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>metode for å frigjøre referanser til Vent håndtaket.</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> </xref:System.Threading.RegisteredWaitHandle> Vi anbefaler at du alltid ringer den <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>metoden, selv om du angir `true` for `executeOnlyOnce`.</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> Datasanering fungerer mer effektivt Hvis du kaller den <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>metoden i stedet for avhengig av den registrerte Vent referansen Sluttbehandler.</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>       Den <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>metoden køer angitte representanten til trådutvalget.</xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> En arbeidstråd vil kjøre representanten når oppstår ett av følgende:-det angitte objektet er i tilstanden signalisert.      Det går-tidsavbrudd.       <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>Metoden kontrollerer den gjeldende tilstanden til det angitte objektet <xref:System.Threading.WaitHandle>.</xref:System.Threading.WaitHandle> </xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> Hvis objektets tilstand unsignaled, registrerer metoden en operasjon på vent. Venteoperasjonen utføres av en tråd fra trådutvalget. Representanten utføres av en arbeidstråd når objektets tilstand er signalisert eller tidsavbruddet utløper. Hvis den `timeOutInterval` parameteren er 0 (null) og `executeOnlyOnce` parameteren er `false`, tidtakeren tilbakestilles hver gang hendelsen signalisert eller tidsavbruddet utløper.      > [!IMPORTANT] > Ved hjelp av en <xref:System.Threading.Mutex>for `waitObject` leverer ikke gjensidig unntak for tilbakeringinger fordi underliggende Win32 API bruker standard `WT_EXECUTEDEFAULT` flagget, slik at hver tilbakeringing fordele på en egen tråd applikasjonsutvalget tråd.</xref:System.Threading.Mutex> I stedet for en <xref:System.Threading.Mutex>, Bruk et <xref:System.Threading.Semaphore>med et maksimalt antall 1.</xref:System.Threading.Semaphore> </xref:System.Threading.Mutex>       Hvis du vil avbryte Venteoperasjonen, kan du kalle den <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>metoden.</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>       Vent tråden bruker Win32 `WaitForMultipleObjects` funksjonen til å overvåke registrerte Vent operasjoner. Derfor Hvis du må bruke samme opprinnelig operativsystemet håndtaket i flere kall til <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, må du duplisere håndtak med Win32 `DuplicateHandle` funksjonen.</xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> Vær oppmerksom på at du ikke skal pulse en hendelse-objekt som er sendt til <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>fordi Vent tråden ikke registrerer at hendelsen er signalisert før den er tilbakestilt.</xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>       Før den returnerer, endrer funksjonen tilstanden av enkelte dokumenttyper synkroniseringsobjektene. Endringen oppstår bare for objektet som har angitt tilstand forårsaket Vent betingelsen oppfylles. For eksempel er antall en semafor redusert av en.      ## Versjonen informasjon fra og med .NET Framework, versjon 2.0, den <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=fullName>egenskapsverdien er overført til arbeidstråder i kø ved hjelp av den <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>metoden.</xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> </xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=fullName> Sikkerhetskontohaveren informasjonen er ikke overført i tidligere versjoner."
  example:
  - "The following example shows how to use the RegisterWaitForSingleObject method to execute a specified callback method when a specified wait handle is signaled. In this example, the callback method is `WaitProc`, and the wait handle is an <xref:System.Threading.AutoResetEvent>.  \n  \n The example defines a `TaskInfo` class to hold the information that is passed to the callback when it executes. The example creates a `TaskInfo` object and assigns it some string data. The <xref:System.Threading.RegisteredWaitHandle> that is returned by the RegisterWaitForSingleObject method is assigned to the `Handle` field of the `TaskInfo` object so that the callback method has access to the <xref:System.Threading.RegisteredWaitHandle>.  \n  \n In addition to specifying `TaskInfo` as the object to pass to the callback method, the call to the RegisterWaitForSingleObject method specifies the <xref:System.Threading.AutoResetEvent> that the task will wait for, a <xref:System.Threading.WaitOrTimerCallback> delegate that represents the `WaitProc` callback method, a one second time-out interval, and multiple callbacks.  \n  \n When the main thread signals the <xref:System.Threading.AutoResetEvent> by calling its <xref:System.Threading.EventWaitHandle.Set%2A> method, the <xref:System.Threading.WaitOrTimerCallback> delegate is invoked. The `WaitProc` method tests <xref:System.Threading.RegisteredWaitHandle> to determine whether a time-out occurred. If the callback was invoked because the wait handle was signaled, the `WaitProc` method unregisters the <xref:System.Threading.RegisteredWaitHandle>, stopping additional callbacks. In the case of a time-out, the task continues to wait. The `WaitProc` method ends by printing a message to the console.  \n  \n [!code-cs[System.Threading.ThreadPool RegisterWaitForSingleObject0#1](~/add/codesnippet/csharp/2f901dc9-3ce0-4cdc-bf06-_1.cs)]\n [!code-cpp[System.Threading.ThreadPool RegisterWaitForSingleObject0#1](~/add/codesnippet/cpp/2f901dc9-3ce0-4cdc-bf06-_1.cpp)]\n [!code-vb[System.Threading.ThreadPool RegisterWaitForSingleObject0#1](~/add/codesnippet/visualbasic/2f901dc9-3ce0-4cdc-bf06-_1.vb)]"
  syntax:
    content: public static System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, uint millisecondsTimeOutInterval, bool executeOnlyOnce);
    parameters:
    - id: waitObject
      type: System.Threading.WaitHandle
      description: "Den <xref:System.Threading.WaitHandle>til å registrere.</xref:System.Threading.WaitHandle> Bruk en <xref:System.Threading.WaitHandle>enn <xref:System.Threading.Mutex>.</xref:System.Threading.Mutex> </xref:System.Threading.WaitHandle>"
    - id: callBack
      type: System.Threading.WaitOrTimerCallback
      description: "Den <xref href=&quot;System.Threading.WaitOrTimerCallback&quot;> </xref> representanten å kalle når den `waitObject` parameteren signalisert."
    - id: state
      type: System.Object
      description: "Objektet som er sendt til representanten."
    - id: millisecondsTimeOutInterval
      type: System.UInt32
      description: "Tidsavbrudd i millisekunder. Hvis den `millisecondsTimeOutInterval` parameteren er 0 (null), funksjonen tester objektets tilstand, og returnerer umiddelbart. Hvis `millisecondsTimeOutInterval` er -1, aldri går funksjonens tidsavbrudd."
    - id: executeOnlyOnce
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>for å angi at tråden vil ikke lenger vente den `waitObject` parameteren etter representanten er kalt; <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> til å angi at tidtakeren tilbakestilles hver gang Venteoperasjonen er fullført før ventetiden er fjernet."
    return:
      type: System.Threading.RegisteredWaitHandle
      description: "Den <xref href=&quot;System.Threading.RegisteredWaitHandle&quot;> </xref> som kan brukes til å avbryte Venteoperasjonen registrerte."
  overload: System.Threading.ThreadPool.RegisterWaitForSingleObject*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "Den <code> millisecondsTimeOutInterval </code> parameteren er mindre enn -1."
  platform:
  - net462
- uid: System.Threading.ThreadPool.SetMaxThreads(System.Int32,System.Int32)
  id: SetMaxThreads(System.Int32,System.Int32)
  parent: System.Threading.ThreadPool
  langs:
  - csharp
  name: SetMaxThreads(Int32,Int32)
  nameWithType: ThreadPool.SetMaxThreads(Int32,Int32)
  fullName: System.Threading.ThreadPool.SetMaxThreads(Int32,Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Angir antallet forespørsler til trådutvalget som kan være aktive samtidig. Alle forespørsler over dette nummeret forblir i kø til tråd applikasjonsutvalget tråder blir tilgjengelig."
  remarks: "Du kan ikke angi maksimalt antall arbeidstråder eller i/u-fullføring tråder til et tall mindre enn antallet prosessorer på datamaskinen. Hvis du vil finne ut hvor mange prosessorer finnes, kan du hente verdien for den <xref:System.Environment.ProcessorCount%2A?displayProperty=fullName>egenskapen.</xref:System.Environment.ProcessorCount%2A?displayProperty=fullName> I tillegg kan du angi maksimalt antall arbeidstråder eller i/u-fullføring tråder til et tall som er mindre enn det tilsvarende minste antallet arbeidstråder eller i/u-fullføring tråder. Hvis du vil finne den minste tråd størrelsen for tilkoblingsutvalg, kan du kalle den <xref:System.Threading.ThreadPool.GetMinThreads%2A>metoden.</xref:System.Threading.ThreadPool.GetMinThreads%2A>       Hvis common language runtime er plassert, for eksempel av Internet Information Services (IIS) eller SQL Server, kan verten begrense eller forhindre endringer i størrelse for tilkoblingsutvalg for tråd.       Vær forsiktig når du endrer det maksimale antallet tråder i trådutvalget. Mens koden kan fordelene med, vil endringene kan ha en negativ innvirkning på kodebiblioteker du bruker.       Angi størrelse for tilkoblingsutvalg for tråd for stor, kan det føre til problemer. Hvis for mange tråder kjøres samtidig, blir oppgaven bytter indirekte betydelige faktorer."
  syntax:
    content: public static bool SetMaxThreads (int workerThreads, int completionPortThreads);
    parameters:
    - id: workerThreads
      type: System.Int32
      description: "Maksimalt antall arbeidstråder i trådutvalget."
    - id: completionPortThreads
      type: System.Int32
      description: "Maksimalt antall tråder som asynkront i/u i trådutvalget."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Hvis endringen er fullført. Ellers <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Threading.ThreadPool.SetMaxThreads*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)
  id: SetMinThreads(System.Int32,System.Int32)
  parent: System.Threading.ThreadPool
  langs:
  - csharp
  name: SetMinThreads(Int32,Int32)
  nameWithType: ThreadPool.SetMinThreads(Int32,Int32)
  fullName: System.Threading.ThreadPool.SetMinThreads(Int32,Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Angir minimum antall tråder som trådutvalget oppretter ved behov, slik at nye forespørsler, før du bytter til en algoritme for administrasjon av tråd oppretting og ødelegges."
  remarks: "Thread pool gir nye arbeidstråder eller i/u-fullføring tråder ved behov før den når minimumsverdien for hver kategori. Når minimumsverdien er nådd, kan trådutvalget opprette flere tråder i denne kategorien eller vente til noen oppgaver er fullført. Begynner med den [!INCLUDE[net_v40_short](~/add/includes/net-v40-short-md.md)], trådutvalget oppretter og ødelegger tråder for å optimalisere ytelse, som er definert som antall oppgaver som fullfører per tidsenheten. For få tråder kan ikke gjøre optimalisere bruken av tilgjengelige ressurser mens for mange tråder kan øke ressursen konflikten.       Når behov er lavt, kan faktisk antall tråder som tråd applikasjonsutvalget faller under minimumsverdien.       Hvis du angir et negativt tall eller et tall som er større enn maksimalt antall aktive tråder applikasjonsutvalget tråder (hentet ved hjelp av <xref:System.Threading.ThreadPool.GetMaxThreads%2A>), SetMinThreads returnerer `false` og endres ikke ett av de laveste verdiene.</xref:System.Threading.ThreadPool.GetMaxThreads%2A>      > [!CAUTION] > Som standard er det minste antallet tråder satt til antallet prosessorer på et system. Du kan bruke SetMinThreads-metoden til å øke den minste tallet ofthreads. Uten grunn øke disse verdiene kan imidlertid føre til problemer. Hvis for mange oppgaver starter samtidig, vises alle kan derfor være treg. I de fleste tilfeller utfører trådutvalget bedre med sin egen algoritme for tilordning av tråder. Å redusere minimum til mindre enn antallet prosessorer kan også legge ytelse."
  example:
  - "The following example sets the minimum number of worker threads to four, and preserves the original value for the minimum number of asynchronous I/O completion threads.  \n  \n [!code-vb[System.Threading.ThreadPool.GetSetMinThreads#1](~/add/codesnippet/visualbasic/m-system.threading.threa_10_1.vb)]\n [!code-cs[System.Threading.ThreadPool.GetSetMinThreads#1](~/add/codesnippet/csharp/m-system.threading.threa_10_1.cs)]\n [!code-cpp[System.Threading.ThreadPool.GetSetMinThreads#1](~/add/codesnippet/cpp/m-system.threading.threa_10_1.cpp)]"
  syntax:
    content: public static bool SetMinThreads (int workerThreads, int completionPortThreads);
    parameters:
    - id: workerThreads
      type: System.Int32
      description: "Minste antall arbeidstråder som trådutvalget oppretter ved behov."
    - id: completionPortThreads
      type: System.Int32
      description: "Minste antall asynkrone i/u-tråder som trådutvalget oppretter ved behov."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Hvis endringen er fullført. Ellers <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Threading.ThreadPool.SetMinThreads*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.ThreadPool.UnsafeQueueNativeOverlapped(System.Threading.NativeOverlapped*)
  id: UnsafeQueueNativeOverlapped(System.Threading.NativeOverlapped*)
  parent: System.Threading.ThreadPool
  langs:
  - csharp
  name: UnsafeQueueNativeOverlapped(NativeOverlapped*)
  nameWithType: ThreadPool.UnsafeQueueNativeOverlapped(NativeOverlapped*)
  fullName: System.Threading.ThreadPool.UnsafeQueueNativeOverlapped(NativeOverlapped*)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "En overlappende i/u-operasjon for kjøring i kø."
  remarks: "For informasjon om bruk av opprinnelig Win32 overlapper i/u, kan du se den <xref:System.Threading.Overlapped>klassen den <xref:System.Threading.NativeOverlapped>strukturen og `OVERLAPPED` strukturen i Win32 SDK.</xref:System.Threading.NativeOverlapped> </xref:System.Threading.Overlapped>      > [!CAUTION] > Ved hjelp av UnsafeQueueNativeOverlapped metoden kan utilsiktet åpner et hull i sikkerheten. Kodetilgangssikkerhet baseres tillatelse kontrollen i tillatelsene for alle brukere på stakken. Når jobb er lagt i kø på en tråd applikasjonsutvalget tråd med UnsafeQueueNativeOverlapped, har ikke stakken tråd applikasjonsutvalget trådens konteksten for en faktisk brukere. Skadelig kode kanskje utnytte dette for å unngå tillatelse database."
  syntax:
    content: public static bool UnsafeQueueNativeOverlapped (System.Threading.NativeOverlapped* overlapped);
    parameters:
    - id: overlapped
      type: System.Threading.NativeOverlapped*
      description: "Den <xref href=&quot;System.Threading.NativeOverlapped&quot;> </xref> strukturen til køen."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Hvis operasjonen ble lagt i kø til en i/u-fullføring port; Ellers <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Threading.ThreadPool.UnsafeQueueNativeOverlapped*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.ThreadPool.UnsafeQueueUserWorkItem(System.Threading.WaitCallback,System.Object)
  id: UnsafeQueueUserWorkItem(System.Threading.WaitCallback,System.Object)
  parent: System.Threading.ThreadPool
  langs:
  - csharp
  name: UnsafeQueueUserWorkItem(WaitCallback,Object)
  nameWithType: ThreadPool.UnsafeQueueUserWorkItem(WaitCallback,Object)
  fullName: System.Threading.ThreadPool.UnsafeQueueUserWorkItem(WaitCallback,Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Køer angitte representanten til trådutvalget, men overføre ikke kall stakken til Arbeidstråden."
  remarks: "I motsetning til det <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>metode, UnsafeQueueUserWorkItem ikke overføre kall stakken til Arbeidstråden.</xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> Dette gjør at koden miste kall bunken, og dermed å utvide sikkerhetsprivilegier.      > [!CAUTION] > Ved hjelp av UnsafeQueueUserWorkItem utilsiktet kan åpne et hull i sikkerheten. Kodetilgangssikkerhet baseres tillatelse kontrollen i tillatelsene for alle brukere på stakken. Når jobb er lagt i kø på en tråd applikasjonsutvalget tråd med UnsafeQueueUserWorkItem, får ikke stakken tråd applikasjonsutvalget trådens konteksten for en faktisk brukere. Skadelig kode kanskje utnytte dette for å unngå tillatelse database."
  syntax:
    content: public static bool UnsafeQueueUserWorkItem (System.Threading.WaitCallback callBack, object state);
    parameters:
    - id: callBack
      type: System.Threading.WaitCallback
      description: "En <xref href=&quot;System.Threading.WaitCallback&quot;> </xref> som representerer representanten å aktivere når en tråd i thread pool plukker opp arbeidselementet."
    - id: state
      type: System.Object
      description: "Objektet som er sendt til representanten når vedlikeholdt fra trådutvalget."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Hvis metoden lykkes. <xref:System.OutOfMemoryException>oppstår hvis arbeidselementet ikke kan plasseres i kø.</xref:System.OutOfMemoryException>"
  overload: System.Threading.ThreadPool.UnsafeQueueUserWorkItem*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "Oppkalleren har ikke den nødvendige tillatelsen."
  - type: System.ApplicationException
    commentId: T:System.ApplicationException
    description: "Fant en betingelse for lite minne."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Arbeidselementet kan ikke plasseres i kø."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>callBack</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int32,System.Boolean)
  id: UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int32,System.Boolean)
  parent: System.Threading.ThreadPool
  langs:
  - csharp
  name: UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int32,Boolean)
  nameWithType: ThreadPool.UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int32,Boolean)
  fullName: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int32,Boolean)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Registrerer representant man skal vente på en <xref:System.Threading.WaitHandle>, ved hjelp av et 32-biters heltall med fortegn for tidsavbrudd i millisekunder.</xref:System.Threading.WaitHandle> Denne metoden overføre ikke kall stakken til Arbeidstråden."
  remarks: "I motsetning til det <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>metode, UnsafeRegisterWaitForSingleObject ikke overføre kall stakken til Arbeidstråden.</xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> Dette gjør at koden miste kall bunken, og dermed å utvide sikkerhetsprivilegier.      > [!CAUTION] > Ved hjelp av UnsafeRegisterWaitForSingleObject utilsiktet kan åpne et hull i sikkerheten. Kodetilgangssikkerhet baseres tillatelse kontrollen i tillatelsene for alle brukere på stakken. Når jobb er lagt i kø på en tråd applikasjonsutvalget tråd med UnsafeRegisterWaitForSingleObject, får ikke stakken tråd applikasjonsutvalget trådens konteksten for en faktisk brukere. Skadelig kode kanskje utnytte dette for å unngå tillatelse database.       Ved hjelp av en <xref:System.Threading.Mutex>for `waitObject` leverer ikke gjensidig unntak for tilbakeringinger fordi underliggende Win32 API bruker standard `WT_EXECUTEDEFAULT` flagget, slik at hver tilbakeringing fordele på en egen tråd applikasjonsutvalget tråd.</xref:System.Threading.Mutex>       Når du er ferdig med den <xref:System.Threading.RegisteredWaitHandle>som returneres av denne metoden, kan du kontakte den <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>metode for å frigjøre referanser til Vent håndtaket.</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> </xref:System.Threading.RegisteredWaitHandle> Vi anbefaler at du alltid ringer den <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>metoden, selv om du angir `true` for `executeOnlyOnce`.</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> Datasanering fungerer mer effektivt Hvis du kaller den <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>metoden i stedet for avhengig av den registrerte Vent referansen Sluttbehandler.</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>"
  syntax:
    content: public static System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, int millisecondsTimeOutInterval, bool executeOnlyOnce);
    parameters:
    - id: waitObject
      type: System.Threading.WaitHandle
      description: "Den <xref:System.Threading.WaitHandle>til å registrere.</xref:System.Threading.WaitHandle> Bruk en <xref:System.Threading.WaitHandle>enn <xref:System.Threading.Mutex>.</xref:System.Threading.Mutex> </xref:System.Threading.WaitHandle>"
    - id: callBack
      type: System.Threading.WaitOrTimerCallback
      description: "Representanten å kalle når den `waitObject` parameteren signalisert."
    - id: state
      type: System.Object
      description: "Objektet som er sendt til representanten."
    - id: millisecondsTimeOutInterval
      type: System.Int32
      description: "Tidsavbrudd i millisekunder. Hvis den `millisecondsTimeOutInterval` parameteren er 0 (null), funksjonen tester objektets tilstand, og returnerer umiddelbart. Hvis `millisecondsTimeOutInterval` er -1, aldri går funksjonens tidsavbrudd."
    - id: executeOnlyOnce
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>for å angi at tråden vil ikke lenger vente den `waitObject` parameteren etter representanten er kalt; <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> til å angi at tidtakeren tilbakestilles hver gang Venteoperasjonen er fullført før ventetiden er fjernet."
    return:
      type: System.Threading.RegisteredWaitHandle
      description: "Den <xref href=&quot;System.Threading.RegisteredWaitHandle&quot;> </xref> objekt som kan brukes til å avbryte Venteoperasjonen registrerte."
  overload: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "Den <code> millisecondsTimeOutInterval </code> parameteren er mindre enn -1."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "Oppkalleren har ikke den nødvendige tillatelsen."
  platform:
  - net462
- uid: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int64,System.Boolean)
  id: UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int64,System.Boolean)
  parent: System.Threading.ThreadPool
  langs:
  - csharp
  name: UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int64,Boolean)
  nameWithType: ThreadPool.UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int64,Boolean)
  fullName: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int64,Boolean)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Registrerer representant man skal vente på en <xref:System.Threading.WaitHandle>, angir et 64-biters fortegn for tidsavbrudd for i millisekunder.</xref:System.Threading.WaitHandle> Denne metoden overføre ikke kall stakken til Arbeidstråden."
  remarks: "I motsetning til det <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>metode, UnsafeRegisterWaitForSingleObject ikke overføre kall stakken til Arbeidstråden.</xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> Dette gjør at koden miste kall bunken, og dermed å utvide sikkerhetsprivilegier.      > [!CAUTION] > Ved hjelp av UnsafeRegisterWaitForSingleObject utilsiktet kan åpne et hull i sikkerheten. Kodetilgangssikkerhet baseres tillatelse kontrollen i tillatelsene for alle brukere på stakken. Når jobb er lagt i kø på en tråd applikasjonsutvalget tråd med UnsafeRegisterWaitForSingleObject, får ikke stakken tråd applikasjonsutvalget trådens konteksten for en faktisk brukere. Skadelig kode kanskje utnytte dette for å unngå tillatelse database.       Ved hjelp av en <xref:System.Threading.Mutex>for `waitObject` leverer ikke gjensidig unntak for tilbakeringinger fordi underliggende Win32 API bruker standard `WT_EXECUTEDEFAULT` flagget, slik at hver tilbakeringing fordele på en egen tråd applikasjonsutvalget tråd.</xref:System.Threading.Mutex>       Når du er ferdig med den <xref:System.Threading.RegisteredWaitHandle>som returneres av denne metoden, kan du kontakte den <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>metode for å frigjøre referanser til Vent håndtaket.</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> </xref:System.Threading.RegisteredWaitHandle> Vi anbefaler at du alltid ringer den <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>metoden, selv om du angir `true` for `executeOnlyOnce`.</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> Datasanering fungerer mer effektivt Hvis du kaller den <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>metoden i stedet for avhengig av den registrerte Vent referansen Sluttbehandler.</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>"
  syntax:
    content: public static System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, long millisecondsTimeOutInterval, bool executeOnlyOnce);
    parameters:
    - id: waitObject
      type: System.Threading.WaitHandle
      description: "Den <xref:System.Threading.WaitHandle>til å registrere.</xref:System.Threading.WaitHandle> Bruk en <xref:System.Threading.WaitHandle>enn <xref:System.Threading.Mutex>.</xref:System.Threading.Mutex> </xref:System.Threading.WaitHandle>"
    - id: callBack
      type: System.Threading.WaitOrTimerCallback
      description: "Representanten å kalle når den `waitObject` parameteren signalisert."
    - id: state
      type: System.Object
      description: "Objektet som er sendt til representanten."
    - id: millisecondsTimeOutInterval
      type: System.Int64
      description: "Tidsavbrudd i millisekunder. Hvis den `millisecondsTimeOutInterval` parameteren er 0 (null), funksjonen tester objektets tilstand, og returnerer umiddelbart. Hvis `millisecondsTimeOutInterval` er -1, aldri går funksjonens tidsavbrudd."
    - id: executeOnlyOnce
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>for å angi at tråden vil ikke lenger vente den `waitObject` parameteren etter representanten er kalt; <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> til å angi at tidtakeren tilbakestilles hver gang Venteoperasjonen er fullført før ventetiden er fjernet."
    return:
      type: System.Threading.RegisteredWaitHandle
      description: "Den <xref href=&quot;System.Threading.RegisteredWaitHandle&quot;> </xref> objekt som kan brukes til å avbryte Venteoperasjonen registrerte."
  overload: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "Den <code> millisecondsTimeOutInterval </code> parameteren er mindre enn -1."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "Oppkalleren har ikke den nødvendige tillatelsen."
  platform:
  - net462
- uid: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.TimeSpan,System.Boolean)
  id: UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.TimeSpan,System.Boolean)
  parent: System.Threading.ThreadPool
  langs:
  - csharp
  name: UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,TimeSpan,Boolean)
  nameWithType: ThreadPool.UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,TimeSpan,Boolean)
  fullName: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,TimeSpan,Boolean)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Registrerer representant man skal vente på en <xref:System.Threading.WaitHandle>, som angir en <xref:System.TimeSpan>verdien for tidsavbrudd for.</xref:System.TimeSpan> </xref:System.Threading.WaitHandle> Denne metoden overføre ikke kall stakken til Arbeidstråden."
  remarks: "I motsetning til det <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>metode, UnsafeRegisterWaitForSingleObject ikke overføre kall stakken til Arbeidstråden.</xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> Dette gjør at koden miste kall bunken, og dermed å utvide sikkerhetsprivilegier.      > [!CAUTION] > Ved hjelp av UnsafeRegisterWaitForSingleObject utilsiktet kan åpne et hull i sikkerheten. Kodetilgangssikkerhet baseres tillatelse kontrollen i tillatelsene for alle brukere på stakken. Når jobb er lagt i kø på en tråd applikasjonsutvalget tråd med UnsafeRegisterWaitForSingleObject, får ikke stakken tråd applikasjonsutvalget trådens konteksten for en faktisk brukere. Skadelig kode kanskje utnytte dette for å unngå tillatelse database.       Ved hjelp av en <xref:System.Threading.Mutex>for `waitObject` leverer ikke gjensidig unntak for tilbakeringinger fordi underliggende Win32 API bruker standard `WT_EXECUTEDEFAULT` flagget, slik at hver tilbakeringing fordele på en egen tråd applikasjonsutvalget tråd.</xref:System.Threading.Mutex>       Når du er ferdig med den <xref:System.Threading.RegisteredWaitHandle>som returneres av denne metoden, kan du kontakte den <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>metode for å frigjøre referanser til Vent håndtaket.</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> </xref:System.Threading.RegisteredWaitHandle> Vi anbefaler at du alltid ringer den <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>metoden, selv om du angir `true` for `executeOnlyOnce`.</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> Datasanering fungerer mer effektivt Hvis du kaller den <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>metoden i stedet for avhengig av den registrerte Vent referansen Sluttbehandler.</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>"
  syntax:
    content: public static System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, TimeSpan timeout, bool executeOnlyOnce);
    parameters:
    - id: waitObject
      type: System.Threading.WaitHandle
      description: "Den <xref:System.Threading.WaitHandle>til å registrere.</xref:System.Threading.WaitHandle> Bruk en <xref:System.Threading.WaitHandle>enn <xref:System.Threading.Mutex>.</xref:System.Threading.Mutex> </xref:System.Threading.WaitHandle>"
    - id: callBack
      type: System.Threading.WaitOrTimerCallback
      description: "Representanten å kalle når den `waitObject` parameteren signalisert."
    - id: state
      type: System.Object
      description: "Objektet som er sendt til representanten."
    - id: timeout
      type: System.TimeSpan
      description: "Tidsavbruddet som er representert av <xref:System.TimeSpan>.</xref:System.TimeSpan> Hvis `timeout` er 0 (null), funksjonen tester objektets tilstand, og returnerer umiddelbart. Hvis `timeout` er -1, aldri går funksjonens tidsavbrudd."
    - id: executeOnlyOnce
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>for å angi at tråden vil ikke lenger vente den `waitObject` parameteren etter representanten er kalt; <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> til å angi at tidtakeren tilbakestilles hver gang Venteoperasjonen er fullført før ventetiden er fjernet."
    return:
      type: System.Threading.RegisteredWaitHandle
      description: "Den <xref href=&quot;System.Threading.RegisteredWaitHandle&quot;> </xref> objekt som kan brukes til å avbryte Venteoperasjonen registrerte."
  overload: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "Den <code> timeout </code> parameteren er mindre enn -1."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Den <code> timeout </code> parameteren er større enn &lt;xref:System.Int32.MaxValue?displayProperty=fullName&gt;."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "Oppkalleren har ikke den nødvendige tillatelsen."
  platform:
  - net462
- uid: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.UInt32,System.Boolean)
  id: UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.UInt32,System.Boolean)
  parent: System.Threading.ThreadPool
  langs:
  - csharp
  name: UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,UInt32,Boolean)
  nameWithType: ThreadPool.UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,UInt32,Boolean)
  fullName: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,UInt32,Boolean)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Registrerer representant man skal vente på en <xref:System.Threading.WaitHandle>, angir et 32-biters heltall uten fortegn for tidsavbrudd for i millisekunder.</xref:System.Threading.WaitHandle> Denne metoden overføre ikke kall stakken til Arbeidstråden."
  remarks: "I motsetning til det <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>metode, UnsafeRegisterWaitForSingleObject ikke overføre kall stakken til Arbeidstråden.</xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> Dette gjør at koden miste kall bunken, og dermed å utvide sikkerhetsprivilegier.      > [!CAUTION] > Ved hjelp av UnsafeRegisterWaitForSingleObject utilsiktet kan åpne et hull i sikkerheten. Kodetilgangssikkerhet baseres tillatelse kontrollen i tillatelsene for alle brukere på stakken. Når jobb er lagt i kø på en tråd applikasjonsutvalget tråd med UnsafeRegisterWaitForSingleObject, får ikke stakken tråd applikasjonsutvalget trådens konteksten for en faktisk brukere. Skadelig kode kanskje utnytte dette for å unngå tillatelse database.       Ved hjelp av en <xref:System.Threading.Mutex>for `waitObject` leverer ikke gjensidig unntak for tilbakeringinger fordi underliggende Win32 API bruker standard `WT_EXECUTEDEFAULT` flagget, slik at hver tilbakeringing fordele på en egen tråd applikasjonsutvalget tråd.</xref:System.Threading.Mutex>       Når du er ferdig med den <xref:System.Threading.RegisteredWaitHandle>som returneres av denne metoden, kan du kontakte den <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>metode for å frigjøre referanser til Vent håndtaket.</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> </xref:System.Threading.RegisteredWaitHandle> Vi anbefaler at du alltid ringer den <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>metoden, selv om du angir `true` for `executeOnlyOnce`.</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> Datasanering fungerer mer effektivt Hvis du kaller den <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>metoden i stedet for avhengig av den registrerte Vent referansen Sluttbehandler.</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>"
  syntax:
    content: public static System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, uint millisecondsTimeOutInterval, bool executeOnlyOnce);
    parameters:
    - id: waitObject
      type: System.Threading.WaitHandle
      description: "Den <xref:System.Threading.WaitHandle>til å registrere.</xref:System.Threading.WaitHandle> Bruk en <xref:System.Threading.WaitHandle>enn <xref:System.Threading.Mutex>.</xref:System.Threading.Mutex> </xref:System.Threading.WaitHandle>"
    - id: callBack
      type: System.Threading.WaitOrTimerCallback
      description: "Representanten å kalle når den `waitObject` parameteren signalisert."
    - id: state
      type: System.Object
      description: "Objektet som er sendt til representanten."
    - id: millisecondsTimeOutInterval
      type: System.UInt32
      description: "Tidsavbrudd i millisekunder. Hvis den `millisecondsTimeOutInterval` parameteren er 0 (null), funksjonen tester objektets tilstand, og returnerer umiddelbart. Hvis `millisecondsTimeOutInterval` er -1, aldri går funksjonens tidsavbrudd."
    - id: executeOnlyOnce
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>for å angi at tråden vil ikke lenger vente den `waitObject` parameteren etter representanten er kalt; <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> til å angi at tidtakeren tilbakestilles hver gang Venteoperasjonen er fullført før ventetiden er fjernet."
    return:
      type: System.Threading.RegisteredWaitHandle
      description: "Den <xref href=&quot;System.Threading.RegisteredWaitHandle&quot;> </xref> objekt som kan brukes til å avbryte Venteoperasjonen registrerte."
  overload: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "Oppkalleren har ikke den nødvendige tillatelsen."
  platform:
  - net462
references:
- uid: System.Object
  isExternal: false
  name: System.Object
- uid: System.Security.SecurityException
  isExternal: true
  name: System.Security.SecurityException
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.NotSupportedException
  isExternal: true
  name: System.NotSupportedException
- uid: System.ArgumentOutOfRangeException
  isExternal: true
  name: System.ArgumentOutOfRangeException
- uid: System.ApplicationException
  parent: System
  isExternal: false
  name: ApplicationException
  nameWithType: ApplicationException
  fullName: System.ApplicationException
- uid: System.OutOfMemoryException
  isExternal: true
  name: System.OutOfMemoryException
- uid: System.Threading.ThreadPool.BindHandle(System.IntPtr)
  parent: System.Threading.ThreadPool
  isExternal: false
  name: BindHandle(IntPtr)
  nameWithType: ThreadPool.BindHandle(IntPtr)
  fullName: System.Threading.ThreadPool.BindHandle(IntPtr)
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.IntPtr
  parent: System
  isExternal: true
  name: IntPtr
  nameWithType: IntPtr
  fullName: System.IntPtr
- uid: System.Threading.ThreadPool.BindHandle(System.Runtime.InteropServices.SafeHandle)
  parent: System.Threading.ThreadPool
  isExternal: false
  name: BindHandle(SafeHandle)
  nameWithType: ThreadPool.BindHandle(SafeHandle)
  fullName: System.Threading.ThreadPool.BindHandle(SafeHandle)
- uid: System.Runtime.InteropServices.SafeHandle
  parent: System.Runtime.InteropServices
  isExternal: true
  name: SafeHandle
  nameWithType: SafeHandle
  fullName: System.Runtime.InteropServices.SafeHandle
- uid: System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)
  parent: System.Threading.ThreadPool
  isExternal: false
  name: GetAvailableThreads(Int32,Int32)
  nameWithType: ThreadPool.GetAvailableThreads(Int32,Int32)
  fullName: System.Threading.ThreadPool.GetAvailableThreads(Int32,Int32)
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)
  parent: System.Threading.ThreadPool
  isExternal: false
  name: GetMaxThreads(Int32,Int32)
  nameWithType: ThreadPool.GetMaxThreads(Int32,Int32)
  fullName: System.Threading.ThreadPool.GetMaxThreads(Int32,Int32)
- uid: System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)
  parent: System.Threading.ThreadPool
  isExternal: false
  name: GetMinThreads(Int32,Int32)
  nameWithType: ThreadPool.GetMinThreads(Int32,Int32)
  fullName: System.Threading.ThreadPool.GetMinThreads(Int32,Int32)
- uid: System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback)
  parent: System.Threading.ThreadPool
  isExternal: false
  name: QueueUserWorkItem(WaitCallback)
  nameWithType: ThreadPool.QueueUserWorkItem(WaitCallback)
  fullName: System.Threading.ThreadPool.QueueUserWorkItem(WaitCallback)
- uid: System.Threading.WaitCallback
  parent: System.Threading
  isExternal: false
  name: WaitCallback
  nameWithType: WaitCallback
  fullName: System.Threading.WaitCallback
- uid: System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback,System.Object)
  parent: System.Threading.ThreadPool
  isExternal: false
  name: QueueUserWorkItem(WaitCallback,Object)
  nameWithType: ThreadPool.QueueUserWorkItem(WaitCallback,Object)
  fullName: System.Threading.ThreadPool.QueueUserWorkItem(WaitCallback,Object)
- uid: System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int32,System.Boolean)
  parent: System.Threading.ThreadPool
  isExternal: false
  name: RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int32,Boolean)
  nameWithType: ThreadPool.RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int32,Boolean)
  fullName: System.Threading.ThreadPool.RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int32,Boolean)
- uid: System.Threading.RegisteredWaitHandle
  parent: System.Threading
  isExternal: false
  name: RegisteredWaitHandle
  nameWithType: RegisteredWaitHandle
  fullName: System.Threading.RegisteredWaitHandle
- uid: System.Threading.WaitHandle
  parent: System.Threading
  isExternal: true
  name: WaitHandle
  nameWithType: WaitHandle
  fullName: System.Threading.WaitHandle
- uid: System.Threading.WaitOrTimerCallback
  parent: System.Threading
  isExternal: false
  name: WaitOrTimerCallback
  nameWithType: WaitOrTimerCallback
  fullName: System.Threading.WaitOrTimerCallback
- uid: System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int64,System.Boolean)
  parent: System.Threading.ThreadPool
  isExternal: false
  name: RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int64,Boolean)
  nameWithType: ThreadPool.RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int64,Boolean)
  fullName: System.Threading.ThreadPool.RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int64,Boolean)
- uid: System.Int64
  parent: System
  isExternal: true
  name: Int64
  nameWithType: Int64
  fullName: System.Int64
- uid: System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.TimeSpan,System.Boolean)
  parent: System.Threading.ThreadPool
  isExternal: false
  name: RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,TimeSpan,Boolean)
  nameWithType: ThreadPool.RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,TimeSpan,Boolean)
  fullName: System.Threading.ThreadPool.RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,TimeSpan,Boolean)
- uid: System.TimeSpan
  parent: System
  isExternal: true
  name: TimeSpan
  nameWithType: TimeSpan
  fullName: System.TimeSpan
- uid: System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.UInt32,System.Boolean)
  parent: System.Threading.ThreadPool
  isExternal: false
  name: RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,UInt32,Boolean)
  nameWithType: ThreadPool.RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,UInt32,Boolean)
  fullName: System.Threading.ThreadPool.RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,UInt32,Boolean)
- uid: System.UInt32
  parent: System
  isExternal: true
  name: UInt32
  nameWithType: UInt32
  fullName: System.UInt32
- uid: System.Threading.ThreadPool.SetMaxThreads(System.Int32,System.Int32)
  parent: System.Threading.ThreadPool
  isExternal: false
  name: SetMaxThreads(Int32,Int32)
  nameWithType: ThreadPool.SetMaxThreads(Int32,Int32)
  fullName: System.Threading.ThreadPool.SetMaxThreads(Int32,Int32)
- uid: System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)
  parent: System.Threading.ThreadPool
  isExternal: false
  name: SetMinThreads(Int32,Int32)
  nameWithType: ThreadPool.SetMinThreads(Int32,Int32)
  fullName: System.Threading.ThreadPool.SetMinThreads(Int32,Int32)
- uid: System.Threading.ThreadPool.UnsafeQueueNativeOverlapped(System.Threading.NativeOverlapped*)
  parent: System.Threading.ThreadPool
  isExternal: false
  name: UnsafeQueueNativeOverlapped(NativeOverlapped*)
  nameWithType: ThreadPool.UnsafeQueueNativeOverlapped(NativeOverlapped*)
  fullName: System.Threading.ThreadPool.UnsafeQueueNativeOverlapped(NativeOverlapped*)
- uid: System.Threading.ThreadPool.UnsafeQueueUserWorkItem(System.Threading.WaitCallback,System.Object)
  parent: System.Threading.ThreadPool
  isExternal: false
  name: UnsafeQueueUserWorkItem(WaitCallback,Object)
  nameWithType: ThreadPool.UnsafeQueueUserWorkItem(WaitCallback,Object)
  fullName: System.Threading.ThreadPool.UnsafeQueueUserWorkItem(WaitCallback,Object)
- uid: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int32,System.Boolean)
  parent: System.Threading.ThreadPool
  isExternal: false
  name: UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int32,Boolean)
  nameWithType: ThreadPool.UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int32,Boolean)
  fullName: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int32,Boolean)
- uid: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int64,System.Boolean)
  parent: System.Threading.ThreadPool
  isExternal: false
  name: UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int64,Boolean)
  nameWithType: ThreadPool.UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int64,Boolean)
  fullName: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int64,Boolean)
- uid: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.TimeSpan,System.Boolean)
  parent: System.Threading.ThreadPool
  isExternal: false
  name: UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,TimeSpan,Boolean)
  nameWithType: ThreadPool.UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,TimeSpan,Boolean)
  fullName: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,TimeSpan,Boolean)
- uid: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.UInt32,System.Boolean)
  parent: System.Threading.ThreadPool
  isExternal: false
  name: UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,UInt32,Boolean)
  nameWithType: ThreadPool.UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,UInt32,Boolean)
  fullName: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,UInt32,Boolean)
- uid: System.Threading.ThreadPool.BindHandle*
  parent: System.Threading.ThreadPool
  isExternal: false
  name: BindHandle
  nameWithType: ThreadPool.BindHandle
- uid: System.Threading.ThreadPool.GetAvailableThreads*
  parent: System.Threading.ThreadPool
  isExternal: false
  name: GetAvailableThreads
  nameWithType: ThreadPool.GetAvailableThreads
- uid: System.Threading.ThreadPool.GetMaxThreads*
  parent: System.Threading.ThreadPool
  isExternal: false
  name: GetMaxThreads
  nameWithType: ThreadPool.GetMaxThreads
- uid: System.Threading.ThreadPool.GetMinThreads*
  parent: System.Threading.ThreadPool
  isExternal: false
  name: GetMinThreads
  nameWithType: ThreadPool.GetMinThreads
- uid: System.Threading.ThreadPool.QueueUserWorkItem*
  parent: System.Threading.ThreadPool
  isExternal: false
  name: QueueUserWorkItem
  nameWithType: ThreadPool.QueueUserWorkItem
- uid: System.Threading.ThreadPool.RegisterWaitForSingleObject*
  parent: System.Threading.ThreadPool
  isExternal: false
  name: RegisterWaitForSingleObject
  nameWithType: ThreadPool.RegisterWaitForSingleObject
- uid: System.Threading.ThreadPool.SetMaxThreads*
  parent: System.Threading.ThreadPool
  isExternal: false
  name: SetMaxThreads
  nameWithType: ThreadPool.SetMaxThreads
- uid: System.Threading.ThreadPool.SetMinThreads*
  parent: System.Threading.ThreadPool
  isExternal: false
  name: SetMinThreads
  nameWithType: ThreadPool.SetMinThreads
- uid: System.Threading.ThreadPool.UnsafeQueueNativeOverlapped*
  parent: System.Threading.ThreadPool
  isExternal: false
  name: UnsafeQueueNativeOverlapped
  nameWithType: ThreadPool.UnsafeQueueNativeOverlapped
- uid: System.Threading.ThreadPool.UnsafeQueueUserWorkItem*
  parent: System.Threading.ThreadPool
  isExternal: false
  name: UnsafeQueueUserWorkItem
  nameWithType: ThreadPool.UnsafeQueueUserWorkItem
- uid: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject*
  parent: System.Threading.ThreadPool
  isExternal: false
  name: UnsafeRegisterWaitForSingleObject
  nameWithType: ThreadPool.UnsafeRegisterWaitForSingleObject
